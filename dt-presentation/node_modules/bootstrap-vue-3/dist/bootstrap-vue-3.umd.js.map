{"version":3,"file":"bootstrap-vue-3.umd.js","sources":["../../../node_modules/.pnpm/@vueuse+shared@9.8.2_vue@3.2.45/node_modules/@vueuse/shared/index.mjs","../../../node_modules/.pnpm/@vueuse+core@9.8.2_vue@3.2.45/node_modules/@vueuse/core/index.mjs","../src/composables/useAlignment.ts","../src/utils/classes/BvEvent.ts","../src/utils/classes/BvModalEvent.ts","../src/utils/inspect.ts","../src/constants/regex.ts","../src/utils/stringUtils.ts","../src/utils/cssEscape.ts","../src/utils/env.ts","../src/constants/env.ts","../src/utils/dom.ts","../src/utils/getBreakpointProps.ts","../src/utils/getClasses.ts","../src/utils/getId.ts","../src/utils/resolveAriaInvalid.ts","../src/utils/mergeDeep.ts","../src/utils/normalizeSlot.ts","../src/utils/number.ts","../src/utils/object.ts","../src/utils/props.ts","../src/utils/booleanish.ts","../src/utils/isLink.ts","../src/composables/useBooleanish.ts","../src/composables/useBreadcrumb.ts","../src/composables/useEventListener.ts","../src/composables/useFormCheck.ts","../src/composables/useId.ts","../src/composables/useFormInput.ts","../src/composables/useFormSelect.ts","../src/composables/useColorMode.ts","../src/components/BAccordion/BAccordion.vue","../src/components/BCollapse.vue","../src/directives/BColorMode.ts","../src/directives/BPopover.ts","../src/directives/BToggle.ts","../src/directives/BTooltip.ts","../src/directives/BVisible.ts","../src/components/BAccordion/BAccordionItem.vue","../src/components/BTransition/BTransition.vue","../src/components/BButton/BCloseButton.vue","../src/components/BSpinner.vue","../src/components/BLink/BLink.vue","../src/components/BButton/BButton.vue","../src/composables/useCountdown.ts","../src/components/BAlert/BAlert.vue","../src/components/BAvatar/BAvatarGroup.vue","../src/components/BAvatar/BAvatar.vue","../src/components/BBadge/BBadge.vue","../src/components/BBreadcrumb/BBreadcrumbItem.vue","../src/components/BBreadcrumb/BBreadcrumb.vue","../src/components/BButton/BButtonGroup.vue","../src/components/BButton/BButtonToolbar.vue","../src/components/BImg.vue","../src/components/BCard/BCardImg.vue","../src/components/BCard/BCardHeadFoot.vue","../src/components/BCard/BCardSubtitle.vue","../src/components/BCard/BCardBody.vue","../src/components/BCard/BCard.vue","../src/components/BCard/BCardGroup.vue","../src/components/BCarousel/BCarousel.vue","../src/components/BCarousel/BCarouselSlide.vue","../src/components/BCol.vue","../src/components/BToast/plugin.ts","../src/components/BToast/BToast.vue","../src/components/BToast/BToaster.vue","../src/components/BContainer.vue","../src/components/BDropdown/BDropdown.vue","../src/components/BDropdown/BDropdownForm.vue","../src/components/BDropdown/BDropdownGroup.vue","../src/components/BDropdown/BDropdownHeader.vue","../src/components/BDropdown/BDropdownItem.vue","../src/components/BDropdown/BDropdownItemButton.vue","../src/components/BForm/BForm.vue","../src/components/BForm/BFormInvalidFeedback.vue","../src/components/BForm/BFormText.vue","../src/components/BForm/BFormValidFeedback.vue","../src/components/BFormCheckbox/BFormCheckbox.vue","../src/components/BFormCheckbox/BFormCheckboxGroup.vue","../src/components/BFormGroup/BFormGroup.vue","../src/components/BFormInput/BFormInput.vue","../src/components/BFormRadio/BFormRadio.vue","../src/components/BFormRadio/BFormRadioGroup.vue","../src/components/BFormSelect/BFormSelectOption.vue","../src/components/BFormSelect/BFormSelectOptionGroup.vue","../src/components/BFormSelect/BFormSelect.vue","../src/components/BFormTags/BFormTag.vue","../src/components/BFormTags/BFormTags.vue","../src/components/BFormTextarea/BFormTextarea.vue","../src/components/BInputGroup/BInputGroup.vue","../src/components/BInputGroup/BInputGroupAddon.vue","../src/components/BListGroup/BListGroup.vue","../src/components/BListGroup/BListGroupItem.vue","../src/components/BModal.vue","../src/components/BNav/BNav.vue","../src/components/BNav/BNavForm.vue","../src/components/BNav/BNavItem.vue","../src/components/BNavbar/BNavbar.vue","../src/components/BNavbar/BNavbarBrand.vue","../src/components/BNavbar/BNavbarNav.vue","../src/components/BNavbar/BNavbarToggle.vue","../src/components/BOffcanvas.vue","../src/components/BOverlay/BOverlay.vue","../src/components/BPagination/BPagination.vue","../src/components/BPlaceholder/BPlaceholder.vue","../src/components/BPlaceholder/BPlaceholderButton.vue","../src/components/BPlaceholder/BPlaceholderCard.vue","../src/components/BTable/BTableSimple.vue","../src/components/BPlaceholder/BPlaceholderTable.vue","../src/components/BPlaceholder/BPlaceholderWrapper.vue","../src/components/BPopover.vue","../src/components/BProgress/BProgressBar.vue","../src/components/BProgress/BProgress.vue","../src/components/BRow.vue","../src/components/BSkeleton/BSkeleton.vue","../src/components/BSkeleton/BSkeletonIcon.vue","../src/components/BSkeleton/BSkeletonTable.vue","../src/components/BSkeleton/BSkeletonWrapper.vue","../src/utils/locale.ts","../src/utils/event.ts","../src/constants/codes.ts","../src/components/BFormSpinButton/BFormSpinButton.vue","../src/components/BTable/helpers/filter-event.ts","../src/components/BTable/itemHelper.ts","../src/components/BTable/BTable.vue","../src/components/BTable/BTbody.vue","../src/components/BTable/BTd.vue","../src/components/BTable/BTfoot.vue","../src/components/BTable/BTh.vue","../src/components/BTable/BThead.vue","../src/components/BTable/BTr.vue","../src/components/BTabs/BTabs.vue","../src/components/BTabs/BTab.vue","../src/BootstrapVue.ts"],"sourcesContent":["import { shallowRef, watchEffect, readonly, unref, ref, isVue3, version, watch, customRef, getCurrentScope, onScopeDispose, effectScope, provide, inject, isRef, computed, reactive, toRefs as toRefs$1, toRef, isVue2, set as set$1, getCurrentInstance, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nvar __defProp$9 = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, __spreadProps$6(__spreadValues$9({}, options), {\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  }));\n  return readonly(result);\n}\n\nvar _a;\nconst isClient = typeof window !== \"undefined\";\nconst isDef = (val) => typeof val !== \"undefined\";\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isBoolean = (val) => typeof val === \"boolean\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isNumber = (val) => typeof val === \"number\";\nconst isString = (val) => typeof val === \"string\";\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst isWindow = (val) => typeof window !== \"undefined\" && toString.call(val) === \"[object Window]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\n\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    filter(() => fn.apply(this, args), { fn, thisArg: this, args });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  const filter = (invoke) => {\n    const duration = resolveUnref(ms);\n    const maxDuration = resolveUnref(options.maxWait);\n    if (timer)\n      clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return invoke();\n    }\n    if (maxDuration && !maxTimer) {\n      maxTimer = setTimeout(() => {\n        if (timer)\n          clearTimeout(timer);\n        maxTimer = null;\n        invoke();\n      }, maxDuration);\n    }\n    timer = setTimeout(() => {\n      if (maxTimer)\n        clearTimeout(maxTimer);\n      maxTimer = null;\n      invoke();\n    }, duration);\n  };\n  return filter;\n}\nfunction throttleFilter(ms, trailing = true, leading = true) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n  };\n  const filter = (invoke) => {\n    const duration = resolveUnref(ms);\n    const elapsed = Date.now() - lastExec;\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      timer = setTimeout(() => {\n        lastExec = Date.now();\n        isLeading = true;\n        clear();\n        invoke();\n      }, duration - elapsed);\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive, pause, resume, eventFilter };\n}\n\nfunction __onlyVue3(name = \"this function\") {\n  if (isVue3)\n    return;\n  throw new Error(`[VueUse] ${name} is only works on Vue 3.`);\n}\nfunction __onlyVue27Plus(name = \"this function\") {\n  if (isVue3 || version.startsWith(\"2.7.\"))\n    return;\n  throw new Error(`[VueUse] ${name} is only works on Vue 2.7 or above.`);\n}\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = isFunction(fn) ? fn : fn.get;\n  const set = isFunction(fn) ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = [];\n  const off = (fn) => {\n    const index = fns.indexOf(fn);\n    if (index !== -1)\n      fns.splice(index, 1);\n  };\n  const on = (fn) => {\n    fns.push(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (param) => {\n    fns.forEach((fn) => fn(param));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return () => {\n    if (!initialized) {\n      state = scope.run(stateFactory);\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nfunction createInjectionState(composable) {\n  const key = Symbol(\"InjectionState\");\n  const useProvidingState = (...args) => {\n    provide(key, composable(...args));\n  };\n  const useInjectedState = () => inject(key);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  __onlyVue27Plus();\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = __spreadValues$8({}, obj);\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : resolveUnref;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(keys.map((key) => {\n    const value = obj[key];\n    return [\n      key,\n      typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n    ];\n  }));\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  return reactiveComputed(() => Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  return reactive(Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = defaultValue;\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = defaultValue;\n      trigger();\n    }, resolveUnref(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(debounceFilter(ms, options), fn);\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true) {\n  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(ref, {\n    get,\n    set,\n    untrackedGet,\n    silentSet,\n    peek,\n    lay\n  }, { enumerable: true });\n}\nconst controlledRef = refWithControl;\n\nfunction resolveRef(r) {\n  return typeof r === \"function\" ? computed(r) : ref(r);\n}\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction syncRef(left, right, options = {}) {\n  var _a, _b;\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options;\n  let watchLeft;\n  let watchRight;\n  const transformLTR = (_a = transform.ltr) != null ? _a : (v) => v;\n  const transformRTL = (_b = transform.rtl) != null ? _b : (v) => v;\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchLeft = watch(left, (newValue) => right.value = transformLTR(newValue), { flush, deep, immediate });\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchRight = watch(right, (newValue) => left.value = transformRTL(newValue), { flush, deep, immediate });\n  }\n  return () => {\n    watchLeft == null ? void 0 : watchLeft();\n    watchRight == null ? void 0 : watchRight();\n  };\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(source, (newValue) => targets.forEach((target) => target.value = newValue), { flush, deep, immediate });\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction toRefs(objectRef) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        if (Array.isArray(objectRef.value)) {\n          const copy = [...objectRef.value];\n          copy[key] = v;\n          objectRef.value = copy;\n        } else {\n          const newObject = __spreadProps$5(__spreadValues$7({}, objectRef.value), { [key]: v });\n          Object.setPrototypeOf(newObject, objectRef.value);\n          objectRef.value = newObject;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true) {\n  if (getCurrentInstance())\n    onBeforeMount(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn) {\n  if (getCurrentInstance())\n    onBeforeUnmount(fn);\n}\n\nfunction tryOnMounted(fn, sync = true) {\n  if (getCurrentInstance())\n    onMounted(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn) {\n  if (getCurrentInstance())\n    onUnmounted(fn);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(r, (v) => {\n        if (condition(v) !== isNot) {\n          stop == null ? void 0 : stop();\n          resolve(v);\n        }\n      }, {\n        flush,\n        deep,\n        immediate: true\n      });\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => stop == null ? void 0 : stop()));\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch([r, value], ([v1, v2]) => {\n        if (isNot !== (v1 === v2)) {\n          stop == null ? void 0 : stop();\n          resolve(v1);\n        }\n      }, {\n        flush,\n        deep,\n        immediate: true\n      });\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => {\n        stop == null ? void 0 : stop();\n        return resolveUnref(r);\n      }));\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(resolveUnref(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(resolveUnref(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => resolveUnref(list).every((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => resolveUnref(resolveUnref(list).find((element, index, array) => fn(resolveUnref(element), index, array))));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => resolveUnref(list).findIndex((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).join(resolveUnref(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(resolveUnref(sum), resolveUnref(value), index);\n  return computed(() => {\n    const resolved = resolveUnref(list);\n    return args.length ? resolved.reduce(reduceCallback, resolveUnref(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => resolveUnref(list).some((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  const count = ref(initialValue);\n  const {\n    max = Infinity,\n    min = -Infinity\n  } = options;\n  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);\n  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = initialValue) => {\n    initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nconst REGEX_FORMAT = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nconst defaultMeridiem = (hours, minutes, isLowercase, hasPeriod) => {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n};\nconst formatDate = (date, formatStr, options = {}) => {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]());\n};\nconst normalizeDate = (date) => {\n  if (date === null)\n    return new Date(NaN);\n  if (date === void 0)\n    return new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n};\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(resolveUnref(date)), resolveUnref(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    if (unref(interval) <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, resolveUnref(interval));\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || isFunction(interval)) {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const controls = useIntervalFn(callback ? () => {\n    update();\n    callback(counter.value);\n  } : update, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues$6({\n      counter\n    }, controls);\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(source, () => ms.value = timestamp(), options);\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, resolveUnref(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending,\n    start,\n    stop\n  };\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$7.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(b)) {\n      if (__propIsEnum$7.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(callback != null ? callback : noop, interval, options);\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return __spreadValues$5({\n      ready\n    }, controls);\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = resolveUnref(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${resolveUnref(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = resolveUnref(truthyValue);\n      _value.value = _value.value === truthy ? resolveUnref(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [\n    ...source instanceof Function ? source() : Array.isArray(source) ? source : unref(source)\n  ];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = new Array(oldList.length);\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __objRest$5 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchWithFilter(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$5(_a, [\n    \"eventFilter\"\n  ]);\n  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);\n}\n\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __objRest$4 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchAtMost(source, cb, options) {\n  const _a = options, {\n    count\n  } = _a, watchOptions = __objRest$4(_a, [\n    \"count\"\n  ]);\n  const current = ref(0);\n  const stop = watchWithFilter(source, (...args) => {\n    current.value += 1;\n    if (current.value >= resolveUnref(count))\n      nextTick(() => stop());\n    cb(...args);\n  }, watchOptions);\n  return { count: current, stop };\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nvar __objRest$3 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchDebounced(source, cb, options = {}) {\n  const _a = options, {\n    debounce = 0,\n    maxWait = void 0\n  } = _a, watchOptions = __objRest$3(_a, [\n    \"debounce\",\n    \"maxWait\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps$4(__spreadValues$4({}, watchOptions), {\n    eventFilter: debounceFilter(debounce, { maxWait })\n  }));\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchIgnorable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$2(_a, [\n    \"eventFilter\"\n  ]);\n  const filteredCb = createFilterWrapper(eventFilter, cb);\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(source, (...args) => {\n      if (!ignore.value)\n        filteredCb(...args);\n    }, watchOptions);\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(watch(source, () => {\n      syncCounter.value++;\n    }, __spreadProps$3(__spreadValues$3({}, watchOptions), { flush: \"sync\" })));\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(watch(source, (...args) => {\n      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n      ignoreCounter.value = 0;\n      syncCounter.value = 0;\n      if (ignore)\n        return;\n      filteredCb(...args);\n    }, watchOptions));\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchPausable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter: filter\n  } = _a, watchOptions = __objRest$1(_a, [\n    \"eventFilter\"\n  ]);\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {\n    eventFilter\n  }));\n  return { stop, pause, resume, isActive };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchThrottled(source, cb, options = {}) {\n  const _a = options, {\n    throttle = 0,\n    trailing = true,\n    leading = true\n  } = _a, watchOptions = __objRest(_a, [\n    \"throttle\",\n    \"trailing\",\n    \"leading\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {\n    eventFilter: throttleFilter(throttle, trailing, leading)\n  }));\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return __spreadProps(__spreadValues({}, res), {\n    trigger\n  });\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => getOneWatchSource(item));\n  return getOneWatchSource(sources);\n}\nfunction getOneWatchSource(source) {\n  return typeof source === \"function\" ? source() : unref(source);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  return watch(source, (v, ov, onInvalidate) => {\n    if (v)\n      cb(v, ov, onInvalidate);\n  }, options);\n}\n\nexport { __onlyVue27Plus, __onlyVue3, assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, hasOwn, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isDefined, isFunction, isIOS, isNumber, isObject, isString, isWindow, makeDestructurable, noop, normalizeDate, now, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchIgnorable, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","import { noop, resolveUnref, isClient, isString, tryOnScopeDispose, tryOnMounted, computedWithControl, promiseTimeout, isFunction, resolveRef, increaseWithUnit, useTimeoutFn, pausableWatch, createEventHook, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, createSingletonPromise, toRefs, containsProp, until, hasOwn, isDef, throttleFilter, useDebounceFn, useThrottleFn, isObject, isNumber, useIntervalFn, clamp, syncRef, objectPick, tryOnUnmounted, isIOS, watchWithFilter, identity } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, watchEffect, computed, inject, unref, watch, getCurrentInstance, customRef, onUpdated, reactive, shallowRef, nextTick, onMounted, markRaw, getCurrentScope, readonly, isVue2, set, del, onBeforeUpdate } from 'vue-demi';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nconst createUnrefFn = (fn) => {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => unref(i)));\n  };\n};\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = resolveUnref(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (isString(args[0]) || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener) => {\n    el.addEventListener(event, listener, options);\n    return () => el.removeEventListener(event, listener, options);\n  };\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (!el)\n      return;\n    cleanups.push(...events.flatMap((event) => {\n      return listeners.map((listener) => register(el, event, listener));\n    }));\n  }, { immediate: true, flush: \"post\" });\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return;\n  let shouldListen = true;\n  let fallback;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    window.clearTimeout(fallback);\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      if (el)\n        shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);\n    }, { passive: true }),\n    useEventListener(window, \"pointerup\", (e) => {\n      if (e.button === 0) {\n        const path = e.composedPath();\n        e.composedPath = () => path;\n        fallback = window.setTimeout(() => listener(e), 50);\n      }\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      var _a;\n      const el = unrefElement(target);\n      if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement)))\n        handler(event);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nvar __defProp$m = Object.defineProperty;\nvar __defProps$9 = Object.defineProperties;\nvar __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$o = Object.getOwnPropertySymbols;\nvar __hasOwnProp$o = Object.prototype.hasOwnProperty;\nvar __propIsEnum$o = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$m = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$o.call(b, prop))\n      __defNormalProp$m(a, prop, b[prop]);\n  if (__getOwnPropSymbols$o)\n    for (var prop of __getOwnPropSymbols$o(b)) {\n      if (__propIsEnum$o.call(b, prop))\n        __defNormalProp$m(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));\nconst createKeyPredicate = (keyFilter) => {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n};\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const { target = defaultWindow, eventName = \"keydown\", passive = false } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$m({}, options), { eventName: \"keydown\" }));\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$m({}, options), { eventName: \"keypress\" }));\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$m({}, options), { eventName: \"keyup\" }));\n}\n\nconst DEFAULT_DELAY = 500;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    timeout = setTimeout(() => handler(ev), (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY);\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions);\n  useEventListener(elementRef, \"pointerup\", clear, listenerOptions);\n  useEventListener(elementRef, \"pointerleave\", clear, listenerOptions);\n}\n\nconst isFocusedElementEditable = () => {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n};\nconst isTypedCharValid = ({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) => {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  return false;\n};\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useActiveElement(options = {}) {\n  const { window = defaultWindow } = options;\n  const activeElement = computedWithControl(() => null, () => window == null ? void 0 : window.document.activeElement);\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget === null)\n        return;\n      activeElement.trigger();\n    }, true);\n    useEventListener(window, \"focus\", activeElement.trigger, true);\n  }\n  return activeElement;\n}\n\nfunction useAsyncQueue(tasks, options = {}) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop\n  } = options;\n  const promiseState = {\n    pending: \"pending\",\n    rejected: \"rejected\",\n    fulfilled: \"fulfilled\"\n  };\n  const initialResult = Array.from(new Array(tasks.length), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      return curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n    }).catch((e) => {\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = ref(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw error;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  return {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = resolveUnref(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if (isRef(target) || isFunction(target))\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useSupported(callback, sync = false) {\n  const isSupported = ref();\n  const update = () => isSupported.value = Boolean(callback());\n  update();\n  tryOnMounted(update, sync);\n  return isSupported;\n}\n\nfunction useBattery({ navigator = defaultNavigator } = {}) {\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator);\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      for (const event of events)\n        useEventListener(battery, event, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef(void 0);\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = ref();\n  const isConnected = computed(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    device,\n    requestDevice,\n    server,\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", update);\n    else\n      mediaQuery.removeListener(update);\n  };\n  const update = () => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(resolveRef(query).value);\n    matches.value = mediaQuery.matches;\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", update);\n    else\n      mediaQuery.addListener(update);\n  };\n  watchEffect(update);\n  tryOnScopeDispose(() => cleanup());\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetify = {\n  xs: 600,\n  sm: 960,\n  md: 1264,\n  lg: 1904\n};\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 600,\n  sm: 1024,\n  md: 1440,\n  lg: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\n\nvar __defProp$l = Object.defineProperty;\nvar __getOwnPropSymbols$n = Object.getOwnPropertySymbols;\nvar __hasOwnProp$n = Object.prototype.hasOwnProperty;\nvar __propIsEnum$n = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$l = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$n.call(b, prop))\n      __defNormalProp$l(a, prop, b[prop]);\n  if (__getOwnPropSymbols$n)\n    for (var prop of __getOwnPropSymbols$n(b)) {\n      if (__propIsEnum$n.call(b, prop))\n        __defNormalProp$l(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = breakpoints[k];\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(`(min-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => greaterOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  return __spreadValues$l({\n    greater(k) {\n      return useMediaQuery(`(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    greaterOrEqual,\n    smaller(k) {\n      return useMediaQuery(`(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    smallerOrEqual(k) {\n      return useMediaQuery(`(max-width: ${getValue(k)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    }\n  }, shortcutMethods);\n}\n\nconst useBroadcastChannel = (options) => {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = ref(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n};\n\nfunction useBrowserLocation({ window = defaultWindow } = {}) {\n  const buildState = (trigger) => {\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (window == null ? void 0 : window.location) || {};\n    return {\n      trigger,\n      state: state2,\n      length,\n      hash,\n      host,\n      hostname,\n      href,\n      origin,\n      pathname,\n      port,\n      protocol,\n      search\n    };\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const events = [\"copy\", \"cut\"];\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value) {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read) {\n    for (const event of events)\n      useEventListener(event, updateText);\n  }\n  async function copy(value = resolveUnref(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value)\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nvar __defProp$k = Object.defineProperty;\nvar __defProps$8 = Object.defineProperties;\nvar __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$m = Object.getOwnPropertySymbols;\nvar __hasOwnProp$m = Object.prototype.hasOwnProperty;\nvar __propIsEnum$m = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$k = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$m.call(b, prop))\n      __defNormalProp$k(a, prop, b[prop]);\n  if (__getOwnPropSymbols$m)\n    for (var prop of __getOwnPropSymbols$m(b)) {\n      if (__propIsEnum$m.call(b, prop))\n        __defNormalProp$k(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone(unref(source));\n  }\n  if (!manual && isRef(source)) {\n    watch(source, sync, __spreadProps$8(__spreadValues$k({}, options), {\n      deep,\n      immediate\n    }));\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\n_global[globalKey] = _global[globalKey] || {};\nconst handlers = _global[globalKey];\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nvar __defProp$j = Object.defineProperty;\nvar __getOwnPropSymbols$l = Object.getOwnPropertySymbols;\nvar __hasOwnProp$l = Object.prototype.hasOwnProperty;\nvar __propIsEnum$l = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$j = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$l.call(b, prop))\n      __defNormalProp$j(a, prop, b[prop]);\n  if (__getOwnPropSymbols$l)\n    for (var prop of __getOwnPropSymbols$l(b)) {\n      if (__propIsEnum$l.call(b, prop))\n        __defNormalProp$j(a, prop, b[prop]);\n    }\n  return a;\n};\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const data = (shallow ? shallowRef : ref)(defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = resolveUnref(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(data, () => write(data.value), { flush, deep, eventFilter });\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", update);\n  update();\n  return data;\n  function write(v) {\n    try {\n      if (v == null) {\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        const oldValue = storage.getItem(key);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          if (window) {\n            window == null ? void 0 : window.dispatchEvent(new StorageEvent(\"storage\", {\n              key,\n              oldValue,\n              newValue: serialized,\n              storageArea: storage\n            }));\n          }\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit !== null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (isFunction(mergeDefaults))\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return __spreadValues$j(__spreadValues$j({}, rawInit), value);\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nvar __defProp$i = Object.defineProperty;\nvar __getOwnPropSymbols$k = Object.getOwnPropertySymbols;\nvar __hasOwnProp$k = Object.prototype.hasOwnProperty;\nvar __propIsEnum$k = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$i = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$k.call(b, prop))\n      __defNormalProp$i(a, prop, b[prop]);\n  if (__getOwnPropSymbols$k)\n    for (var prop of __getOwnPropSymbols$k(b)) {\n      if (__propIsEnum$k.call(b, prop))\n        __defNormalProp$i(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto\n  } = options;\n  const modes = __spreadValues$i({\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\"\n  }, options.modes || {});\n  const preferredDark = usePreferredDark({ window });\n  const preferredMode = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? ref(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed({\n    get() {\n      return store.value === \"auto\" && !emitAuto ? preferredMode.value : store.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  const updateHTMLAttrs = getSSRHandler(\"updateHTMLAttrs\", (selector2, attribute2, value) => {\n    const el = window == null ? void 0 : window.document.querySelector(selector2);\n    if (!el)\n      return;\n    if (attribute2 === \"class\") {\n      const current = value.split(/\\s/g);\n      Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n        if (current.includes(v))\n          el.classList.add(v);\n        else\n          el.classList.remove(v);\n      });\n    } else {\n      el.setAttribute(attribute2, value);\n    }\n  });\n  function defaultOnChanged(mode) {\n    var _a;\n    const resolvedMode = mode === \"auto\" ? preferredMode.value : mode;\n    updateHTMLAttrs(selector, attribute, (_a = modes[resolvedMode]) != null ? _a : resolvedMode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  if (emitAuto)\n    watch(preferredMode, () => onChanged(state.value), { flush: \"post\" });\n  tryOnMounted(() => onChanged(state.value));\n  return state;\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useCssVar(prop, target, { window = defaultWindow, initialValue = \"\" } = {}) {\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  watch([elRef, () => resolveUnref(prop)], ([el, prop2]) => {\n    var _a;\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(prop2)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }, { immediate: true });\n  watch(variable, (val) => {\n    var _a;\n    if ((_a = elRef.value) == null ? void 0 : _a.style)\n      elRef.value.style.setProperty(resolveUnref(prop), val);\n  });\n  return variable;\n}\n\nfunction useCurrentElement() {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(() => null, () => vm.proxy.$el);\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  var _a;\n  const state = shallowRef((_a = options == null ? void 0 : options.initialValue) != null ? _a : list[0]);\n  const index = computed({\n    get() {\n      var _a2;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, list) : list.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a2 = options == null ? void 0 : options.fallbackIndex) != null ? _a2 : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const length = list.length;\n    const index2 = (i % length + length) % length;\n    const value = list[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  return {\n    state,\n    index,\n    next,\n    prev\n  };\n}\n\nvar __defProp$h = Object.defineProperty;\nvar __defProps$7 = Object.defineProperties;\nvar __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$j = Object.getOwnPropertySymbols;\nvar __hasOwnProp$j = Object.prototype.hasOwnProperty;\nvar __propIsEnum$j = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$h = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$j.call(b, prop))\n      __defNormalProp$h(a, prop, b[prop]);\n  if (__getOwnPropSymbols$j)\n    for (var prop of __getOwnPropSymbols$j(b)) {\n      if (__propIsEnum$j.call(b, prop))\n        __defNormalProp$h(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\",\n    window = defaultWindow\n  } = options;\n  const mode = useColorMode(__spreadProps$7(__spreadValues$h({}, options), {\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\");\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  }));\n  const preferredDark = usePreferredDark({ window });\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      if (v === preferredDark.value)\n        mode.value = \"auto\";\n      else\n        mode.value = v ? \"dark\" : \"light\";\n    }\n  });\n  return isDark;\n}\n\nconst fnBypass = (v) => v;\nconst fnSetSource = (source, value) => source.value = value;\nfunction defaultDump(clone) {\n  return clone ? isFunction(clone) ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? isFunction(clone) ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Infinity);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nvar __defProp$g = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$i = Object.getOwnPropertySymbols;\nvar __hasOwnProp$i = Object.prototype.hasOwnProperty;\nvar __propIsEnum$i = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$g = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$i.call(b, prop))\n      __defNormalProp$g(a, prop, b[prop]);\n  if (__getOwnPropSymbols$i)\n    for (var prop of __getOwnPropSymbols$i(b)) {\n      if (__propIsEnum$i.call(b, prop))\n        __defNormalProp$g(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(source, commit, { deep, flush, eventFilter: composedFilter });\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, __spreadProps$6(__spreadValues$g({}, options), { clone: options.clone || deep, setSource }));\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return __spreadProps$6(__spreadValues$g({}, manualHistory), {\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  });\n}\n\nvar __defProp$f = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$h = Object.getOwnPropertySymbols;\nvar __hasOwnProp$h = Object.prototype.hasOwnProperty;\nvar __propIsEnum$h = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$f = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$h.call(b, prop))\n      __defNormalProp$f(a, prop, b[prop]);\n  if (__getOwnPropSymbols$h)\n    for (var prop of __getOwnPropSymbols$h(b)) {\n      if (__propIsEnum$h.call(b, prop))\n        __defNormalProp$f(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, __spreadProps$5(__spreadValues$f({}, options), { eventFilter: filter }));\n  return __spreadValues$f({}, history);\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(eventFilter, (event) => {\n      acceleration.value = event.acceleration;\n      accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n      rotationRate.value = event.rotationRate;\n      interval.value = event.interval;\n    });\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio({\n  window = defaultWindow\n} = {}) {\n  if (!window) {\n    return {\n      pixelRatio: ref(1)\n    };\n  }\n  const pixelRatio = ref(1);\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.map((i) => i());\n    cleanups.length = 0;\n  };\n  const observe = () => {\n    pixelRatio.value = window.devicePixelRatio;\n    cleanup();\n    const media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n    media.addEventListener(\"change\", observe, { once: true });\n    cleanups.push(() => {\n      media.removeEventListener(\"change\", observe);\n    });\n  };\n  observe();\n  tryOnScopeDispose(cleanup);\n  return { pixelRatio };\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = ref();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = ref(false);\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      stream.getTracks().forEach((t) => t.stop());\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(enabled, (v) => {\n    if (v)\n      _start();\n    else\n      _stop();\n  }, { immediate: true });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility({ document = defaultDocument } = {}) {\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nvar __defProp$e = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$g = Object.getOwnPropertySymbols;\nvar __hasOwnProp$g = Object.prototype.hasOwnProperty;\nvar __propIsEnum$g = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$e = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$g.call(b, prop))\n      __defNormalProp$e(a, prop, b[prop]);\n  if (__getOwnPropSymbols$g)\n    for (var prop of __getOwnPropSymbols$g(b)) {\n      if (__propIsEnum$g.call(b, prop))\n        __defNormalProp$e(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nfunction useDraggable(target, options = {}) {\n  var _a, _b, _c;\n  const draggingElement = (_a = options.draggingElement) != null ? _a : defaultWindow;\n  const draggingHandle = (_b = options.handle) != null ? _b : target;\n  const position = ref((_c = resolveUnref(options.initialValue)) != null ? _c : { x: 0, y: 0 });\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (options.pointerTypes)\n      return options.pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (resolveUnref(options.preventDefault))\n      e.preventDefault();\n    if (resolveUnref(options.stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (resolveUnref(options.exact) && e.target !== resolveUnref(target))\n      return;\n    const rect = resolveUnref(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n    if (((_a2 = options.onStart) == null ? void 0 : _a2.call(options, pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    position.value = {\n      x: e.clientX - pressedDelta.value.x,\n      y: e.clientY - pressedDelta.value.y\n    };\n    (_a2 = options.onMove) == null ? void 0 : _a2.call(options, position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options, position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    useEventListener(draggingHandle, \"pointerdown\", start, true);\n    useEventListener(draggingElement, \"pointermove\", move, true);\n    useEventListener(draggingElement, \"pointerup\", end, true);\n  }\n  return __spreadProps$4(__spreadValues$e({}, toRefs(position)), {\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(() => `left:${position.value.x}px;top:${position.value.y}px;`)\n  });\n}\n\nfunction useDropZone(target, onDrop) {\n  const isOverDropZone = ref(false);\n  let counter = 0;\n  if (isClient) {\n    useEventListener(target, \"dragenter\", (event) => {\n      event.preventDefault();\n      counter += 1;\n      isOverDropZone.value = true;\n    });\n    useEventListener(target, \"dragover\", (event) => {\n      event.preventDefault();\n    });\n    useEventListener(target, \"dragleave\", (event) => {\n      event.preventDefault();\n      counter -= 1;\n      if (counter === 0)\n        isOverDropZone.value = false;\n    });\n    useEventListener(target, \"drop\", (event) => {\n      var _a, _b;\n      event.preventDefault();\n      counter = 0;\n      isOverDropZone.value = false;\n      const files = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\n      onDrop == null ? void 0 : onDrop(files.length === 0 ? null : files);\n    });\n  }\n  return {\n    isOverDropZone\n  };\n}\n\nvar __getOwnPropSymbols$f = Object.getOwnPropertySymbols;\nvar __hasOwnProp$f = Object.prototype.hasOwnProperty;\nvar __propIsEnum$f = Object.prototype.propertyIsEnumerable;\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$f.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$f)\n    for (var prop of __getOwnPropSymbols$f(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$f.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useResizeObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, observerOptions = __objRest$2(_a, [\"window\"]);\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (isSupported.value && window && el) {\n      observer = new ResizeObserver(callback);\n      observer.observe(el, observerOptions);\n    }\n  }, { immediate: true, flush: \"post\" });\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    const delta = timestamp - previousFrameTimestamp;\n    fn({ delta, timestamp });\n    previousFrameTimestamp = timestamp;\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$d = Object.defineProperty;\nvar __getOwnPropSymbols$e = Object.getOwnPropertySymbols;\nvar __hasOwnProp$e = Object.prototype.hasOwnProperty;\nvar __propIsEnum$e = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$d = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$e.call(b, prop))\n      __defNormalProp$d(a, prop, b[prop]);\n  if (__getOwnPropSymbols$e)\n    for (var prop of __getOwnPropSymbols$e(b)) {\n      if (__propIsEnum$e.call(b, prop))\n        __defNormalProp$d(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useElementByPoint(options) {\n  const element = ref(null);\n  const { x, y } = options;\n  const controls = useRafFn(() => {\n    element.value = document.elementFromPoint(resolveUnref(x), resolveUnref(y));\n  });\n  return __spreadValues$d({\n    element\n  }, controls);\n}\n\nfunction useElementHover(el) {\n  const isHovered = ref(false);\n  useEventListener(el, \"mouseenter\", () => isHovered.value = true);\n  useEventListener(el, \"mouseleave\", () => isHovered.value = false);\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { box = \"content-box\" } = options;\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  useResizeObserver(target, ([entry]) => {\n    const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n    if (boxSize) {\n      width.value = boxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n      height.value = boxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n    } else {\n      width.value = entry.contentRect.width;\n      height.value = entry.contentRect.height;\n    }\n  }, options);\n  watch(() => unrefElement(target), (ele) => {\n    width.value = ele ? initialSize.width : 0;\n    height.value = ele ? initialSize.height : 0;\n  });\n  return {\n    width,\n    height\n  };\n}\n\nfunction useElementVisibility(element, { window = defaultWindow, scrollTarget } = {}) {\n  const elementIsVisible = ref(false);\n  const testBounding = () => {\n    if (!window)\n      return;\n    const document = window.document;\n    const el = unrefElement(element);\n    if (!el) {\n      elementIsVisible.value = false;\n    } else {\n      const rect = el.getBoundingClientRect();\n      elementIsVisible.value = rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth) && rect.bottom >= 0 && rect.right >= 0;\n    }\n  };\n  watch(() => unrefElement(element), () => testBounding(), { immediate: true, flush: \"post\" });\n  if (window) {\n    useEventListener(scrollTarget || window, \"scroll\", testBounding, {\n      capture: false,\n      passive: true\n    });\n  }\n  return elementIsVisible;\n}\n\nconst events = new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || [];\n    listeners.push(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    const index = listeners.indexOf(listener);\n    if (index > -1)\n      listeners.splice(index, 1);\n    if (!listeners.length)\n      events.delete(key);\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = ref(null);\n  const {\n    withCredentials = false\n  } = options;\n  const close = () => {\n    if (eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n    }\n  };\n  const es = new EventSource(url, { withCredentials });\n  eventSource.value = es;\n  es.onopen = () => {\n    status.value = \"OPEN\";\n    error.value = null;\n  };\n  es.onerror = (e) => {\n    status.value = \"CLOSED\";\n    error.value = e;\n  };\n  es.onmessage = (e) => {\n    event.value = null;\n    data.value = e.data;\n  };\n  for (const event_name of events) {\n    useEventListener(es, event_name, (e) => {\n      event.value = event_name;\n      data.value = e.data || null;\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    close\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = resolveRef(newIcon);\n  const applyIcon = (icon) => {\n    document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`).forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(favicon, (i, o) => {\n    if (isString(i) && i !== o)\n      applyIcon(i);\n  }, { immediate: true });\n  return favicon;\n}\n\nvar __defProp$c = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$d = Object.getOwnPropertySymbols;\nvar __hasOwnProp$d = Object.prototype.hasOwnProperty;\nvar __propIsEnum$d = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$c = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$d.call(b, prop))\n      __defNormalProp$c(a, prop, b[prop]);\n  if (__getOwnPropSymbols$d)\n    for (var prop of __getOwnPropSymbols$d(b)) {\n      if (__propIsEnum$d.call(b, prop))\n        __defNormalProp$c(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\",\n  formData: \"multipart/form-data\"\n};\nfunction isFetchOptions(obj) {\n  return containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\");\n}\nfunction isAbsoluteURL(url) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries([...headers.entries()]);\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback !== void 0)\n        await callback(ctx);\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      await callbacks.reduce((prevCallback, callback) => prevCallback.then(async () => {\n        if (callback)\n          ctx = __spreadValues$c(__spreadValues$c({}, ctx), await callback(ctx));\n      }), Promise.resolve());\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = resolveUnref(config.baseUrl);\n      const targetUrl = resolveUnref(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = __spreadProps$3(__spreadValues$c(__spreadValues$c({}, options), args[0]), {\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        });\n      } else {\n        fetchOptions = __spreadProps$3(__spreadValues$c(__spreadValues$c({}, fetchOptions), args[0]), {\n          headers: __spreadValues$c(__spreadValues$c({}, headersToObject(fetchOptions.headers) || {}), headersToObject(args[0].headers) || {})\n        });\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = __spreadProps$3(__spreadValues$c(__spreadValues$c({}, options), args[1]), {\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      });\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = { immediate: true, refetch: false, timeout: 0 };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = __spreadValues$c(__spreadValues$c({}, options), args[0]);\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = __spreadValues$c(__spreadValues$c({}, options), args[1]);\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort && controller)\n      controller.abort();\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  const execute = async (throwOnFailed = false) => {\n    var _a2;\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    controller = void 0;\n    if (supportsAbort) {\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = __spreadProps$3(__spreadValues$c({}, fetchOptions), {\n        signal: controller.signal\n      });\n    }\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      const payload = resolveUnref(config.payload);\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = { url: resolveUnref(url), options: __spreadValues$c(__spreadValues$c({}, defaultFetchOptions), fetchOptions), cancel: () => {\n      isCanceled = true;\n    } };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return new Promise((resolve, reject) => {\n      var _a3;\n      fetch(context.url, __spreadProps$3(__spreadValues$c(__spreadValues$c({}, defaultFetchOptions), context.options), {\n        headers: __spreadValues$c(__spreadValues$c({}, headersToObject(defaultFetchOptions.headers)), headersToObject((_a3 = context.options) == null ? void 0 : _a3.headers))\n      })).then(async (fetchResponse) => {\n        response.value = fetchResponse;\n        statusCode.value = fetchResponse.status;\n        responseData = await fetchResponse[config.type]();\n        if (options.afterFetch && statusCode.value >= 200 && statusCode.value < 300)\n          ({ data: responseData } = await options.afterFetch({ data: responseData, response: fetchResponse }));\n        data.value = responseData;\n        if (!fetchResponse.ok)\n          throw new Error(fetchResponse.statusText);\n        responseEvent.trigger(fetchResponse);\n        return resolve(fetchResponse);\n      }).catch(async (fetchError) => {\n        let errorData = fetchError.message || fetchError.name;\n        if (options.onFetchError)\n          ({ data: responseData, error: errorData } = await options.onFetchError({ data: responseData, error: fetchError, response: response.value }));\n        data.value = responseData;\n        error.value = errorData;\n        errorEvent.trigger(fetchError);\n        if (throwOnFailed)\n          return reject(fetchError);\n        return resolve(null);\n      }).finally(() => {\n        loading(false);\n        if (timer)\n          timer.stop();\n        finallyEvent.trigger(null);\n      });\n    });\n  };\n  const refetch = resolveRef(options.refetch);\n  watch([\n    refetch,\n    resolveRef(url)\n  ], ([refetch2]) => refetch2 && execute(), { deep: true });\n  const shell = {\n    isFinished,\n    statusCode,\n    response,\n    error,\n    data,\n    isFetching,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch([\n            refetch,\n            resolveRef(config.payload)\n          ], ([refetch2]) => refetch2 && execute(), { deep: true });\n        }\n        const rawPayload = resolveUnref(config.payload);\n        if (!payloadType && rawPayload && Object.getPrototypeOf(rawPayload) === Object.prototype)\n          config.payloadType = \"json\";\n        return __spreadProps$3(__spreadValues$c({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return __spreadProps$3(__spreadValues$c({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    setTimeout(execute, 0);\n  return __spreadProps$3(__spreadValues$c({}, shell), {\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  });\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nvar __defProp$b = Object.defineProperty;\nvar __getOwnPropSymbols$c = Object.getOwnPropertySymbols;\nvar __hasOwnProp$c = Object.prototype.hasOwnProperty;\nvar __propIsEnum$c = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$b = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$c.call(b, prop))\n      __defNormalProp$b(a, prop, b[prop]);\n  if (__getOwnPropSymbols$c)\n    for (var prop of __getOwnPropSymbols$c(b)) {\n      if (__propIsEnum$c.call(b, prop))\n        __defNormalProp$b(a, prop, b[prop]);\n    }\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\"\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(null);\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n    };\n  }\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = __spreadValues$b(__spreadValues$b(__spreadValues$b({}, DEFAULT_OPTIONS), options), localOptions);\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    if (hasOwn(_options, \"capture\"))\n      input.capture = _options.capture;\n    input.click();\n  };\n  const reset = () => {\n    files.value = null;\n    if (input)\n      input.value = \"\";\n  };\n  return {\n    files: readonly(files),\n    open,\n    reset\n  };\n}\n\nvar __defProp$a = Object.defineProperty;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$a = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$a(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$a(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = unref(options);\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker(__spreadValues$a(__spreadValues$a({}, unref(options)), _options));\n    fileHandle.value = handle;\n    await updateFile();\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$a(__spreadValues$a({}, unref(options)), _options));\n    data.value = void 0;\n    await updateFile();\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$a(__spreadValues$a({}, unref(options)), _options));\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    if (unref(dataType) === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    if (unref(dataType) === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    if (unref(dataType) === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => unref(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false } = options;\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed({\n    get() {\n      return isDef(activeElement.value) && isDef(targetElement.value) && activeElement.value === targetElement.value;\n    },\n    set(value) {\n      var _a, _b;\n      if (!value && focused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      if (value && !focused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus();\n    }\n  });\n  watch(targetElement, () => {\n    focused.value = initialValue;\n  }, { immediate: true, flush: \"post\" });\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst functionsMap = [\n  [\n    \"requestFullscreen\",\n    \"exitFullscreen\",\n    \"fullscreenElement\",\n    \"fullscreenEnabled\",\n    \"fullscreenchange\",\n    \"fullscreenerror\"\n  ],\n  [\n    \"webkitRequestFullscreen\",\n    \"webkitExitFullscreen\",\n    \"webkitFullscreenElement\",\n    \"webkitFullscreenEnabled\",\n    \"webkitfullscreenchange\",\n    \"webkitfullscreenerror\"\n  ],\n  [\n    \"webkitRequestFullScreen\",\n    \"webkitCancelFullScreen\",\n    \"webkitCurrentFullScreenElement\",\n    \"webkitCancelFullScreen\",\n    \"webkitfullscreenchange\",\n    \"webkitfullscreenerror\"\n  ],\n  [\n    \"mozRequestFullScreen\",\n    \"mozCancelFullScreen\",\n    \"mozFullScreenElement\",\n    \"mozFullScreenEnabled\",\n    \"mozfullscreenchange\",\n    \"mozfullscreenerror\"\n  ],\n  [\n    \"msRequestFullscreen\",\n    \"msExitFullscreen\",\n    \"msFullscreenElement\",\n    \"msFullscreenEnabled\",\n    \"MSFullscreenChange\",\n    \"MSFullscreenError\"\n  ]\n];\nfunction useFullscreen(target, options = {}) {\n  const { document = defaultDocument, autoExit = false } = options;\n  const targetRef = target || (document == null ? void 0 : document.querySelector(\"html\"));\n  const isFullscreen = ref(false);\n  let map = functionsMap[0];\n  const isSupported = useSupported(() => {\n    if (!document) {\n      return false;\n    } else {\n      for (const m of functionsMap) {\n        if (m[1] in document) {\n          map = m;\n          return true;\n        }\n      }\n    }\n    return false;\n  });\n  const [REQUEST, EXIT, ELEMENT, , EVENT] = map;\n  async function exit() {\n    if (!isSupported.value)\n      return;\n    if (document == null ? void 0 : document[ELEMENT])\n      await document[EXIT]();\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value)\n      return;\n    await exit();\n    const target2 = unrefElement(targetRef);\n    if (target2) {\n      await target2[REQUEST]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    if (isFullscreen.value)\n      await exit();\n    else\n      await enter();\n  }\n  if (document) {\n    useEventListener(document, EVENT, () => {\n      isFullscreen.value = !!(document == null ? void 0 : document[ELEMENT]);\n    }, false);\n  }\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      id: gamepad.id,\n      hapticActuators,\n      index: gamepad.index,\n      mapping: gamepad.mapping,\n      connected: gamepad.connected,\n      timestamp: gamepad.timestamp,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (let i = 0; i < _gamepads.length; ++i) {\n      const gamepad = _gamepads[i];\n      if (gamepad) {\n        const index = gamepads.value.findIndex(({ index: index2 }) => index2 === gamepad.index);\n        if (index > -1)\n          gamepads.value[index] = stateFromGamepad(gamepad);\n      }\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    if (_gamepads) {\n      for (let i = 0; i < _gamepads.length; ++i) {\n        const gamepad = _gamepads[i];\n        if (gamepad)\n          onGamepadConnected(gamepad);\n      }\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = ref(null);\n  const error = ref(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Infinity,\n    longitude: Infinity,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(updatePosition, (err) => error.value = err, {\n        enableHighAccuracy,\n        maximumAge,\n        timeout\n      });\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const onEvent = createFilterWrapper(eventFilter, () => {\n    idle.value = false;\n    lastActive.value = timestamp();\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  });\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n  }\n  timer = setTimeout(() => idle.value = true, timeout);\n  return { idle, lastActive };\n}\n\nvar __defProp$9 = Object.defineProperty;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nconst useImage = (options, asyncStateOptions = {}) => {\n  const state = useAsyncState(() => loadImage(resolveUnref(options)), void 0, __spreadValues$9({\n    resetOnExecute: true\n  }, asyncStateOptions));\n  watch(() => resolveUnref(options), () => state.execute(asyncStateOptions.delay), { deep: true });\n  return state;\n};\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\"\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c;\n    const _element = resolveUnref(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = resolveUnref(_y)) != null ? _a : y.value,\n      left: (_b = resolveUnref(_x)) != null ? _b : x.value,\n      behavior: resolveUnref(behavior)\n    });\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = useDebounceFn((e) => {\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  }, throttle + idle);\n  const onScrollHandler = (e) => {\n    const eventTarget = e.target === document ? e.target.documentElement : e.target;\n    const scrollLeft = eventTarget.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalY.value;\n    arrivedState.left = scrollLeft <= 0 + (offset.left || 0);\n    arrivedState.right = scrollLeft + eventTarget.clientWidth >= eventTarget.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    internalX.value = scrollLeft;\n    let scrollTop = eventTarget.scrollTop;\n    if (e.target === document && !scrollTop)\n      scrollTop = document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    arrivedState.top = scrollTop <= 0 + (offset.top || 0);\n    arrivedState.bottom = scrollTop + eventTarget.clientHeight >= eventTarget.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    internalY.value = scrollTop;\n    isScrolling.value = true;\n    onScrollEnd(e);\n    onScroll(e);\n  };\n  useEventListener(element, \"scroll\", throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler, eventListenerOptions);\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions\n  };\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a, _b;\n  const direction = (_a = options.direction) != null ? _a : \"bottom\";\n  const state = reactive(useScroll(element, __spreadProps$2(__spreadValues$8({}, options), {\n    offset: __spreadValues$8({\n      [direction]: (_b = options.distance) != null ? _b : 0\n    }, options.offset)\n  })));\n  watch(() => state.arrivedState[direction], async (v) => {\n    var _a2, _b2;\n    if (v) {\n      const elem = resolveUnref(element);\n      const previous = {\n        height: (_a2 = elem == null ? void 0 : elem.scrollHeight) != null ? _a2 : 0,\n        width: (_b2 = elem == null ? void 0 : elem.scrollWidth) != null ? _b2 : 0\n      };\n      await onLoadMore(state);\n      if (options.preserveScrollPosition && elem) {\n        nextTick(() => {\n          elem.scrollTo({\n            top: elem.scrollHeight - previous.height,\n            left: elem.scrollWidth - previous.width\n          });\n        });\n      }\n    }\n  });\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  let cleanup = noop;\n  const stopWatch = isSupported.value ? watch(() => ({\n    el: unrefElement(target),\n    root: unrefElement(root)\n  }), ({ el, root: root2 }) => {\n    cleanup();\n    if (!el)\n      return;\n    const observer = new IntersectionObserver(callback, {\n      root: root2,\n      rootMargin,\n      threshold\n    });\n    observer.observe(el);\n    cleanup = () => {\n      observer.disconnect();\n      cleanup = noop;\n    };\n  }, { immediate: true, flush: \"post\" }) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(new Set());\n  const obj = { toJSON() {\n    return {};\n  }, current };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = new Set();\n  const usedKeys = new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(refs, {\n    get(target2, prop, rec) {\n      if (typeof prop !== \"string\")\n        return Reflect.get(target2, prop, rec);\n      prop = prop.toLowerCase();\n      if (prop in aliasMap)\n        prop = aliasMap[prop];\n      if (!(prop in refs)) {\n        if (/[+_-]/.test(prop)) {\n          const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n          refs[prop] = computed(() => keys.every((key) => unref(proxy[key])));\n        } else {\n          refs[prop] = ref(false);\n        }\n      }\n      const r = Reflect.get(target2, prop, rec);\n      return useReactive ? unref(r) : r;\n    }\n  });\n  return proxy;\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction usingElRef(source, cb) {\n  if (resolveUnref(source))\n    cb(resolveUnref(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  options = __spreadValues$7(__spreadValues$7({}, defaultOptions), options);\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = isNumber(track) ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = isNumber(track) ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    const src = resolveUnref(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (isString(src))\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch(volume, (vol) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.volume = vol;\n  });\n  watch(muted, (mute) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.muted = mute;\n  });\n  watch(rate, (rate2) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.playbackRate = rate2;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = resolveUnref(options.tracks);\n    const el = resolveUnref(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = resolveUnref(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = resolveUnref(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(resolveUnref(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, \"waiting\", () => waiting.value = true);\n  useEventListener(target, \"playing\", () => waiting.value = false);\n  useEventListener(target, \"ratechange\", () => rate.value = resolveUnref(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    volume,\n    muted,\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nconst getMapVue2Compat = () => {\n  const data = reactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => hasOwn(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n};\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return reactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return reactive(new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  onMounted(() => {\n    isMounted.value = true;\n  });\n  return isMounted;\n}\n\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    eventFilter\n  } = options;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const mouseHandler = (event) => {\n    if (type === \"page\") {\n      x.value = event.pageX;\n      y.value = event.pageY;\n    } else if (type === \"client\") {\n      x.value = event.clientX;\n      y.value = event.clientY;\n    }\n    sourceType.value = \"mouse\";\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const touch2 = event.touches[0];\n      if (type === \"page\") {\n        x.value = touch2.pageX;\n        y.value = touch2.pageY;\n      } else if (type === \"client\") {\n        x.value = touch2.clientX;\n        y.value = touch2.clientY;\n      }\n      sourceType.value = \"touch\";\n    }\n  };\n  const mouseHandlerWrapper = (event) => {\n    return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});\n  };\n  const touchHandlerWrapper = (event) => {\n    return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});\n  };\n  if (window) {\n    useEventListener(window, \"mousemove\", mouseHandlerWrapper, { passive: true });\n    useEventListener(window, \"dragover\", mouseHandlerWrapper, { passive: true });\n    if (touch) {\n      useEventListener(window, \"touchstart\", touchHandlerWrapper, { passive: true });\n      useEventListener(window, \"touchmove\", touchHandlerWrapper, { passive: true });\n      if (resetOnTouchEnds)\n        useEventListener(window, \"touchend\", reset, { passive: true });\n    }\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch([targetRef, x, y], () => {\n      const el = unrefElement(targetRef);\n      if (!el)\n        return;\n      const {\n        left,\n        top,\n        width,\n        height\n      } = el.getBoundingClientRect();\n      elementPositionX.value = left + window.pageXOffset;\n      elementPositionY.value = top + window.pageYOffset;\n      elementHeight.value = height;\n      elementWidth.value = width;\n      const elX = x.value - elementPositionX.value;\n      const elY = y.value - elementPositionY.value;\n      isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n      if (handleOutside || !isOutside.value) {\n        elementX.value = elX;\n        elementY.value = elY;\n      }\n    }, { immediate: true });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true });\n    useEventListener(window, \"drop\", onReleased, { passive: true });\n    useEventListener(window, \"dragend\", onReleased, { passive: true });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true });\n    useEventListener(window, \"touchend\", onReleased, { passive: true });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useMutationObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, mutationOptions = __objRest$1(_a, [\"window\"]);\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (isSupported.value && window && el) {\n      observer = new MutationObserver(callback);\n      observer.observe(el, mutationOptions);\n    }\n  }, { immediate: true });\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nconst useNavigatorLanguage = (options = {}) => {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n};\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$6.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(b)) {\n      if (__propIsEnum$6.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(new Date());\n  const update = () => now.value = new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return __spreadValues$6({\n      now\n    }, controls);\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = ref();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(() => unref(object), (newObject) => {\n    release();\n    if (newObject)\n      url.value = URL.createObjectURL(newObject);\n  }, { immediate: true });\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\nfunction useClamp(value, min, max) {\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, resolveUnref(min), resolveUnref(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, resolveUnref(min), resolveUnref(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Infinity,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Infinity);\n  const pageCount = computed(() => Math.max(1, Math.ceil(unref(total) / unref(currentPageSize))));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page))\n    syncRef(page, currentPage);\n  if (isRef(pageSize))\n    syncRef(pageSize, currentPageSize);\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0))\n      return \"deviceOrientation\";\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = -orientation.beta / 90;\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = orientation.gamma / 90;\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$5.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(b)) {\n      if (__propIsEnum$5.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    useEventListener(target, \"pointerdown\", handler, { passive: true });\n    useEventListener(target, \"pointermove\", handler, { passive: true });\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, { passive: true });\n  }\n  return __spreadProps$1(__spreadValues$5({}, toRefs(state)), {\n    isInside\n  });\n}\n\nvar SwipeDirection;\n(function(SwipeDirection2) {\n  SwipeDirection2[\"UP\"] = \"UP\";\n  SwipeDirection2[\"RIGHT\"] = \"RIGHT\";\n  SwipeDirection2[\"DOWN\"] = \"DOWN\";\n  SwipeDirection2[\"LEFT\"] = \"LEFT\";\n  SwipeDirection2[\"NONE\"] = \"NONE\";\n})(SwipeDirection || (SwipeDirection = {}));\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return SwipeDirection.NONE;\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;\n    } else {\n      return diffY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchend\", onTouchEnd, listenerOptions),\n    useEventListener(target, \"touchcancel\", onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = resolveRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return SwipeDirection.NONE;\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;\n    } else {\n      return distanceY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"initial\");\n    })\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nconst useScreenOrientation = (options = {}) => {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (!isSupported.value)\n      return Promise.reject(new Error(\"Not supported\"));\n    return screenOrientation.lock(type);\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value)\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n};\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${resolveUnref(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = resolveUnref(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${resolveUnref(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow;\n  watch(resolveRef(element), (el) => {\n    if (el) {\n      const ele = el;\n      initialOverflow = ele.style.overflow;\n      if (isLocked.value)\n        ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const ele = resolveUnref(element);\n    if (!ele || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(ele, \"touchmove\", preventDefault, { passive: false });\n    }\n    ele.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const ele = resolveUnref(element);\n    if (!ele || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    ele.style.overflow = initialOverflow;\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else\n        unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = __spreadValues$4(__spreadValues$4({}, resolveUnref(shareOptions)), resolveUnref(overrideOptions));\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...unref(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(unref(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = resolveRef(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = unref(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const transcript = Array.from(event.results).map((result2) => {\n        isFinal.value = result2.isFinal;\n        return result2[0];\n      }).map((result2) => result2.transcript).join(\"\");\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = unref(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const spokenText = resolveRef(text || \"\");\n  const lang = resolveRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = unref(lang);\n    utterance2.voice = unref(options.voice) || null;\n    utterance2.pitch = pitch;\n    utterance2.rate = rate;\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = resolveUnref(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => setTimeout(() => read(e), 0));\n  if (storage) {\n    watchWithFilter(data, async () => {\n      try {\n        if (data.value == null)\n          await storage.removeItem(key);\n        else\n          await storage.setItem(key, await serializer.write(data.value));\n      } catch (e) {\n        onError(e);\n      }\n    }, {\n      flush,\n      deep,\n      eventFilter\n    });\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.type = \"text/css\";\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(cssRef, (value) => {\n      el.textContent = value;\n    }, { immediate: true });\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(document.querySelector(selector), () => dir.value = getValue(), { attributes: true });\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  const ranges = new Array(rangeCount);\n  for (let i = 0; i < rangeCount; i++) {\n    const range = selection.getRangeAt(i);\n    ranges[i] = range;\n  }\n  return ranges;\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  const textarea = ref(options == null ? void 0 : options.element);\n  const input = ref(options == null ? void 0 : options.input);\n  function triggerResize() {\n    var _a, _b;\n    if (!textarea.value)\n      return;\n    textarea.value.style.height = \"1px\";\n    textarea.value.style.height = `${(_a = textarea.value) == null ? void 0 : _a.scrollHeight}px`;\n    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);\n  }\n  watch([input, textarea], triggerResize, { immediate: true });\n  useResizeObserver(textarea, () => triggerResize());\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, __spreadProps(__spreadValues$3({}, options), { eventFilter: filter }));\n  return __spreadValues$3({}, history);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Infinity, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nconst DEFAULT_FORMATTER = (date) => date.toISOString().slice(0, 10);\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const _a = useNow({ interval: updateInterval, controls: true }), { now } = _a, controls = __objRest(_a, [\"now\"]);\n  const timeAgo = computed(() => foramtTimeAgo(new Date(resolveUnref(time)), options, unref(now.value)));\n  if (exposeControls) {\n    return __spreadValues$2({\n      timeAgo\n    }, controls);\n  } else {\n    return timeAgo;\n  }\n}\nfunction foramtTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval);\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues$1({\n      timestamp: ts\n    }, controls);\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b;\n  const {\n    document = defaultDocument\n  } = options;\n  const title = resolveRef((_a = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _a : null);\n  const isReadonly = newTitle && isFunction(newTitle);\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return isFunction(template) ? template(t) : unref(template).replace(/%s/g, t);\n  }\n  watch(title, (t, o) => {\n    if (t !== o && document)\n      document.title = format(isString(t) ? t : \"\");\n  }, { immediate: true });\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver((_b = document.head) == null ? void 0 : _b.querySelector(\"title\"), () => {\n      if (document && document.title !== title.value)\n        title.value = format(document.title);\n    }, { childList: true });\n  }\n  return title;\n}\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = __spreadValues({\n  linear: identity\n}, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction useTransition(source, options = {}) {\n  const {\n    delay = 0,\n    disabled = false,\n    duration = 1e3,\n    onFinished = noop,\n    onStarted = noop,\n    transition = identity\n  } = options;\n  const currentTransition = computed(() => {\n    const t = unref(transition);\n    return isFunction(t) ? t : createEasingFunction(t);\n  });\n  const sourceValue = computed(() => {\n    const s = unref(source);\n    return isNumber(s) ? s : s.map(unref);\n  });\n  const sourceVector = computed(() => isNumber(sourceValue.value) ? [sourceValue.value] : sourceValue.value);\n  const outputVector = ref(sourceVector.value.slice(0));\n  let currentDuration;\n  let diffVector;\n  let endAt;\n  let startAt;\n  let startVector;\n  const { resume, pause } = useRafFn(() => {\n    const now = Date.now();\n    const progress = clamp(1 - (endAt - now) / currentDuration, 0, 1);\n    outputVector.value = startVector.map((val, i) => {\n      var _a;\n      return val + ((_a = diffVector[i]) != null ? _a : 0) * currentTransition.value(progress);\n    });\n    if (progress >= 1) {\n      pause();\n      onFinished();\n    }\n  }, { immediate: false });\n  const start = () => {\n    pause();\n    currentDuration = unref(duration);\n    diffVector = outputVector.value.map((n, i) => {\n      var _a, _b;\n      return ((_a = sourceVector.value[i]) != null ? _a : 0) - ((_b = outputVector.value[i]) != null ? _b : 0);\n    });\n    startVector = outputVector.value.slice(0);\n    startAt = Date.now();\n    endAt = startAt + currentDuration;\n    resume();\n    onStarted();\n  };\n  const timeout = useTimeoutFn(start, delay, { immediate: false });\n  watch(sourceVector, () => {\n    if (unref(disabled))\n      return;\n    if (unref(delay) <= 0)\n      start();\n    else\n      timeout.start();\n  }, { deep: true });\n  watch(() => unref(disabled), (v) => {\n    if (v) {\n      outputVector.value = sourceVector.value.slice(0);\n      pause();\n    }\n  });\n  return computed(() => {\n    const targetVector = unref(disabled) ? sourceVector : outputVector;\n    return isNumber(sourceValue.value) ? targetVector.value[0] : targetVector.value;\n  });\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(state, () => {\n    const params = new URLSearchParams(\"\");\n    Object.keys(state).forEach((key) => {\n      const mapEntry = state[key];\n      if (Array.isArray(mapEntry))\n        mapEntry.forEach((value) => params.append(key, value));\n      else if (removeNullishValues && mapEntry == null)\n        params.delete(key);\n      else if (removeFalsyValues && !mapEntry)\n        params.delete(key);\n      else\n        params.set(key, mapEntry);\n    });\n    write(params);\n  }, { deep: true });\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(window.history.state, window.document.title, window.location.pathname + constructQuery(params));\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const videoDeviceId = ref(options.videoDeviceId);\n  const audioDeviceId = ref(options.audioDeviceId);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(device) {\n    if (device.value === \"none\" || device.value === false)\n      return false;\n    if (device.value == null)\n      return true;\n    return {\n      deviceId: device.value\n    };\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(videoDeviceId),\n      audio: getDeviceOptions(audioDeviceId)\n    });\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(enabled, (v) => {\n    if (v)\n      _start();\n    else\n      _stop();\n  }, { immediate: true });\n  watch([videoDeviceId, audioDeviceId], () => {\n    if (autoSwitch.value && stream.value)\n      restart();\n  }, { immediate: true });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    videoDeviceId,\n    audioDeviceId,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = eventName || event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : isFunction(clone) ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    watch(() => props[key], (v) => proxy.value = cloneFn(v));\n    watch(proxy, (v) => {\n      if (v !== props[key] || deep)\n        _emit(event, v);\n    }, { deep });\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        _emit(event, value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props)\n    ret[key] = useVModel(props, key, emit, options);\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = resolveRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(vibrate, interval, {\n      immediate: false,\n      immediateCallback: false\n    });\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResourses(list) {\n  const containerRef = ref(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerHeight) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerHeight / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const height = itemSize(i);\n      sum += height;\n      if (sum >= containerHeight) {\n        capacity = i;\n        break;\n      }\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, calculateRange) {\n  watch([size.width, size.height, list], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResourses(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResourses(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nconst useWakeLock = (options = {}) => {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = ref(false);\n  async function onVisibilityChange() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported.value)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n};\n\nconst useWebNotification = (defaultOptions = {}) => {\n  const {\n    window = defaultWindow\n  } = defaultOptions;\n  const isSupported = useSupported(() => !!window && \"Notification\" in window);\n  const notification = ref(null);\n  const requestPermission = async () => {\n    if (!isSupported.value)\n      return;\n    if (\"permission\" in Notification && Notification.permission !== \"denied\")\n      await Notification.requestPermission();\n  };\n  const onClick = createEventHook();\n  const onShow = createEventHook();\n  const onError = createEventHook();\n  const onClose = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value)\n      return;\n    await requestPermission();\n    const options = Object.assign({}, defaultOptions, overrides);\n    notification.value = new Notification(options.title || \"\", options);\n    notification.value.onclick = (event) => onClick.trigger(event);\n    notification.value.onshow = (event) => onShow.trigger(event);\n    notification.value.onerror = (event) => onError.trigger(event);\n    notification.value.onclose = (event) => onClose.trigger(event);\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  tryOnMounted(async () => {\n    if (isSupported.value)\n      await requestPermission();\n  });\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n};\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = resolveRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const close = (code = 1e3, reason) => {\n    if (!wsRef.value)\n      return;\n    explicitlyClosed = true;\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n  };\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed)\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      wsRef.value = void 0;\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === message)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(() => {\n      send(message, false);\n      if (pongTimeoutWait != null)\n        return;\n      pongTimeoutWait = setTimeout(() => {\n        close();\n      }, pongTimeout);\n    }, interval, { immediate: false });\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    useEventListener(window, \"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    watch(urlRef, open, { immediate: true });\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = function post2(val) {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(val);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (isString(arg0))\n      worker.value = new Worker(arg0, workerOptions);\n    else if (isFunction(arg0))\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nconst jobRunner = (userFunc) => (e) => {\n  const userFuncArgs = e.data[0];\n  return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n    postMessage([\"SUCCESS\", result]);\n  }).catch((error) => {\n    postMessage([\"ERROR\", error]);\n  });\n};\n\nconst depsParser = (deps) => {\n  if (deps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  return `importScripts(${depsString})`;\n};\n\nconst createWorkerBlobUrl = (fn, deps) => {\n  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n};\n\nconst useWebWorkerFn = (fn, options = {}) => {\n  const {\n    dependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(() => workerTerminate(\"TIMEOUT_EXPIRED\"), timeout);\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\"[useWebWorkerFn] You can only run one instance of the worker at a time.\");\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n};\n\nfunction useWindowFocus({ window = defaultWindow } = {}) {\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll({ window = defaultWindow } = {}) {\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const x = ref(window.pageXOffset);\n  const y = ref(window.pageYOffset);\n  useEventListener(window, \"scroll\", () => {\n    x.value = window.pageXOffset;\n    y.value = window.pageYOffset;\n  }, {\n    capture: false,\n    passive: true\n  });\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Infinity,\n    initialHeight = Infinity,\n    listenOrientation = true,\n    includeScrollbar = true\n  } = options;\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation)\n    useEventListener(\"orientationchange\", update, { passive: true });\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, SwipeDirection, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsMasterCss, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, cloneFnJSON, computedAsync, computedInject, createFetch, createUnrefFn, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, foramtTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, usePermission, usePointer, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","import {eagerComputed} from '@vueuse/core'\nimport type {Ref} from 'vue'\nimport type {Alignment} from '../types'\n\n/**\n *\n * @param align\n * @returns\n */\nexport default (align: Ref<Alignment.JustifyContent | undefined>): Readonly<Ref<string>> =>\n  eagerComputed(() => (!align.value ? '' : `justify-content-${align.value}`))\n","/**\n * Items that are omitted from the BvEventInit constructor arg\n */\ntype BvEventConstructorOmittables = 'eventType' | 'defaultPrevented'\n\nexport type {BvEventConstructorOmittables}\n\n/**\n * @external\n */\nexport default class BvEvent {\n  readonly cancelable: boolean = true\n  readonly componentId: string | null = null\n  private _defaultPrevented = false\n  readonly eventType: string = ''\n  readonly nativeEvent: string | null = null\n  private _preventDefault: () => void\n  readonly relatedTarget: string | null = null\n  readonly target: EventTarget | null = null\n  // Readable by everyone,\n  // But only overwritten by inherrited constructors\n  public get defaultPrevented() {\n    return this._defaultPrevented\n  }\n  protected set defaultPrevented(prop) {\n    this._defaultPrevented = prop\n  }\n  // I think this is right\n  // We want to be able to have it callable to everyone,\n  // But only overwritten by inherrited constructors\n  public get preventDefault() {\n    return this._preventDefault\n  }\n  // This may not be correct, because it doesn't get correct type inferences in children\n  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue\n  protected set preventDefault(setter: () => void) {\n    this._preventDefault = setter\n  }\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvEvent, BvEventConstructorOmittables>> = {}\n  ) {\n    if (!eventType) {\n      throw new TypeError(\n        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`\n      )\n    }\n\n    // Merge defaults first, the eventInit, and the type last\n    // so, it can't be overwritten\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n\n    this._preventDefault = function _preventDefault() {\n      if (this.cancelable) {\n        this.defaultPrevented = true\n      }\n    }\n  }\n\n  static get Defaults() {\n    return {\n      cancelable: true,\n      componentId: null,\n      eventType: '',\n      nativeEvent: null,\n      relatedTarget: null,\n      target: null,\n    }\n  }\n}\n","import BvEvent, {type BvEventConstructorOmittables} from './BvEvent'\n\n/**\n * @external\n */\nexport default class BvModalEvent extends BvEvent {\n  readonly trigger: string | null = null\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvModalEvent, BvEventConstructorOmittables>> = {}\n  ) {\n    super(eventType, eventInit)\n\n    // Merge defaults first, the eventInit, and the type last\n    // so, it can't be overwritten\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n  }\n\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n      trigger: null,\n    }\n  }\n}\n","/**\n * @param obj\n * @returns\n */\nexport const isObject = (obj: unknown): obj is Record<PropertyKey, unknown> =>\n  obj !== null && typeof obj === 'object'\n\n/**\n * @param value\n * @returns\n */\nexport const isNumeric = (value: unknown): boolean => /^[0-9]*\\.?[0-9]+$/.test(String(value))\n\n/**\n * Strict object type check. Only returns true for plain JavaScript objects\n *\n * @param obj\n * @returns\n */\nexport const isPlainObject = (obj: unknown): obj is Record<PropertyKey, unknown> =>\n  Object.prototype.toString.call(obj) === '[object Object]'\n\n/**\n * Strict object type check. Only returns true for plain JavaScript objects\n *\n * @param obj\n * @returns\n */\nexport const isNull = (value: unknown): value is null => value === null\n","export const RX_UNDERSCORE = /_/g\nexport const RX_LOWER_UPPER = /([a-z])([A-Z])/g\nexport const RX_START_SPACE_WORD = /(\\s|^)(\\w)/g\nexport const RX_FIRST_START_SPACE_WORD = /(\\s|^)(\\w)/\nexport const RX_SPACE_SPLIT = /\\s+/\nexport const RX_HASH = /^#/\nexport const RX_HASH_ID = /^#[A-Za-z]+[\\w\\-:.]*$/\n\nexport const RX_STRIP_LOCALE_MODS = /-u-.+/\n","import {isPlainObject} from './inspect'\nimport {\n  RX_FIRST_START_SPACE_WORD,\n  RX_LOWER_UPPER,\n  RX_START_SPACE_WORD,\n  RX_UNDERSCORE,\n} from '../constants/regex'\n\n/**\n * Convert a value to a string that can be rendered `undefined`/`null` will be converted to `''` Plain objects and arrays will be JSON stringified\n *\n * @param val\n * @param spaces\n * @returns\n */\nexport const toString = (val: unknown, spaces = 2): string =>\n  typeof val === 'string'\n    ? val\n    : val === undefined || val === null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === Object.prototype.toString)\n    ? JSON.stringify(val, null, spaces)\n    : String(val)\n\n/**\n * @param str\n * @returns\n */\nexport const startCase = (str: string): string =>\n  str\n    .replace(RX_UNDERSCORE, ' ')\n    .replace(RX_LOWER_UPPER, (_, $1, $2) => `${$1} ${$2}`)\n    .replace(RX_FIRST_START_SPACE_WORD, (_, $1, $2) => $1 + $2.toUpperCase())\n\n/**\n * @param str\n * @returns\n */\nexport const titleCase = (str: string): string =>\n  str\n    .replace(RX_UNDERSCORE, ' ')\n    .replace(RX_LOWER_UPPER, (_, $1, $2) => `${$1} ${$2}`)\n    .replace(RX_START_SPACE_WORD, (_, $1, $2) => $1 + $2.toUpperCase())\n\n/**\n * Uppercases the first letter of a string and returns a new string\n *\n * @param str\n * @returns\n */\nexport const upperFirst = (str: string): string => {\n  const trim = str.trim()\n  return trim.charAt(0).toUpperCase() + trim.slice(1)\n}\n","import {toString} from './stringUtils'\n\nconst escapeChar = (value: string) => `\\\\${value}`\n\n/**\n * The `cssEscape()` util is based on this `CSS.escape()` polyfill: https://github.com/mathiasbynens/CSS.escape\n *\n * @param {unknown} value\n */\nexport default (value: unknown): string => {\n  const val = toString(value)\n\n  const {length} = val\n  const firstCharCode = val.charCodeAt(0)\n\n  return val.split('').reduce((result: string, char: string, index: number) => {\n    const charCode = val.charCodeAt(index)\n\n    // If the character is NULL (U+0000), use (U+FFFD) as replacement\n    if (charCode === 0x0000) {\n      return `${result}\\uFFFD`\n    }\n\n    // If the character ...\n    if (\n      // ... is U+007F OR\n      charCode === 0x007f ||\n      // ... is in the range [\\1-\\1F] (U+0001 to U+001F) OR ...\n      (charCode >= 0x0001 && charCode <= 0x001f) ||\n      // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...\n      (index === 0 && charCode >= 0x0030 && charCode <= 0x0039) ||\n      // ... is the second character and is in the range [0-9] (U+0030 to U+0039)\n      // and the first character is a `-` (U+002D) ...\n      (index === 1 && charCode >= 0x0030 && charCode <= 0x0039 && firstCharCode === 0x002d)\n    ) {\n      // ... https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n      return result + escapeChar(`${charCode.toString(16)} `)\n    }\n\n    // If the character ...\n    if (\n      // ... is the first character AND ...\n      index === 0 &&\n      // ... is a `-` (U+002D) AND ...\n      charCode === 0x002d &&\n      // ... there is no second character ...\n      length === 1\n    ) {\n      // ... use the escaped character\n      return result + escapeChar(char)\n    }\n\n    // If the character ...\n    if (\n      // ... is greater than or equal to U+0080 OR ...\n      charCode >= 0x0080 ||\n      // ... is `-` (U+002D) OR ...\n      charCode === 0x002d ||\n      // ... is `_` (U+005F) OR ...\n      charCode === 0x005f ||\n      // ... is in the range [0-9] (U+0030 to U+0039) OR ...\n      (charCode >= 0x0030 && charCode <= 0x0039) ||\n      // ... is in the range [A-Z] (U+0041 to U+005A) OR ...\n      (charCode >= 0x0041 && charCode <= 0x005a) ||\n      // ... is in the range [a-z] (U+0061 to U+007A) ...\n      (charCode >= 0x0061 && charCode <= 0x007a)\n    ) {\n      // ... use the character itself\n      return result + char\n    }\n\n    // Otherwise use the escaped character\n    // See: https://drafts.csswg.org/cssom/#escape-a-character\n    return result + escapeChar(char)\n  }, '')\n}\n","export const HAS_WINDOW_SUPPORT = typeof window !== 'undefined'\nexport const HAS_DOCUMENT_SUPPORT = typeof document !== 'undefined'\nexport const HAS_NAVIGATOR_SUPPORT = typeof navigator !== 'undefined'\nexport const IS_BROWSER = HAS_WINDOW_SUPPORT && HAS_DOCUMENT_SUPPORT && HAS_NAVIGATOR_SUPPORT\nexport const WINDOW = HAS_WINDOW_SUPPORT ? window : {}\n\n// Determine if the browser supports the option passive for events\nexport const HAS_PASSIVE_EVENT_SUPPORT = (() => {\n  let passiveEventSupported = false\n  if (IS_BROWSER) {\n    try {\n      const options = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          passiveEventSupported = true\n          // eslint-disable-next-line no-useless-return\n          return\n        },\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      WINDOW.addEventListener('test', options, options)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      WINDOW.removeEventListener('test', options, options)\n    } catch {\n      passiveEventSupported = false\n    }\n  }\n  return passiveEventSupported\n})()\n","// eslint-disable-next-line no-var\ndeclare var WebKitMutationObserver: any\n// eslint-disable-next-line no-var\ndeclare var MozMutationObserver: any\n\nexport const HAS_WINDOW_SUPPORT = typeof window !== 'undefined'\nexport const HAS_DOCUMENT_SUPPORT = typeof document !== 'undefined'\nexport const HAS_ELEMENT_SUPPORT = typeof Element !== 'undefined'\nexport const HAS_NAVIGATOR_SUPPORT = typeof navigator !== 'undefined'\nexport const HAS_PROMISE_SUPPORT = typeof Promise !== 'undefined'\n\nexport const HAS_MUTATION_OBSERVER_SUPPORT =\n  typeof MutationObserver !== 'undefined' ||\n  typeof WebKitMutationObserver !== 'undefined' ||\n  typeof MozMutationObserver !== 'undefined'\n\nexport const IS_BROWSER = HAS_WINDOW_SUPPORT && HAS_DOCUMENT_SUPPORT && HAS_NAVIGATOR_SUPPORT\n\nexport const WINDOW = HAS_WINDOW_SUPPORT ? window : ({} as Record<string, any>)\nexport const DOCUMENT = HAS_DOCUMENT_SUPPORT ? document : ({} as Record<string, any>)\nexport const NAVIGATOR = HAS_NAVIGATOR_SUPPORT ? navigator : ({} as Record<string, any>)\nexport const USER_AGENT = (NAVIGATOR.userAgent || '').toLowerCase()\n\nexport const IS_JSDOM = USER_AGENT.indexOf('jsdom') > 0\nexport const IS_IE = /msie|trident/.test(USER_AGENT)\n\n// Determine if the browser supports the option passive for events\nexport const HAS_PASSIVE_EVENT_SUPPORT = (() => {\n  let passiveEventSupported = false\n  if (IS_BROWSER) {\n    try {\n      const options = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          passiveEventSupported = true\n          return passiveEventSupported\n        },\n      }\n      WINDOW.addEventListener('test', options, options)\n      WINDOW.removeEventListener('test', options, options)\n    } catch {\n      passiveEventSupported = false\n    }\n  }\n  return passiveEventSupported\n})()\n\nexport const HAS_TOUCH_SUPPORT =\n  IS_BROWSER && ('ontouchstart' in DOCUMENT.documentElement || NAVIGATOR.maxTouchPoints > 0)\n\nexport const HAS_POINTER_EVENT_SUPPORT =\n  IS_BROWSER && Boolean(WINDOW.PointerEvent || WINDOW.MSPointerEvent)\n\nexport const HAS_INTERACTION_OBSERVER_SUPPORT =\n  IS_BROWSER &&\n  'IntersectionObserver' in WINDOW &&\n  'IntersectionObserverEntry' in WINDOW &&\n  // Edge 15 and UC Browser lack support for `isIntersecting`\n  // but we an use `intersectionRatio > 0` instead\n  // 'isIntersecting' in window.IntersectionObserverEntry.prototype &&\n  'intersectionRatio' in WINDOW.IntersectionObserverEntry.prototype\n","import {Comment, type Slot, type VNode} from 'vue'\nimport {DOCUMENT, HAS_ELEMENT_SUPPORT} from '../constants/env'\nimport {AnimationFrame} from '../types/safeTypes'\nimport {HAS_WINDOW_SUPPORT} from './env'\nimport {toString} from './stringUtils'\n\nconst ELEMENT_PROTO = HAS_ELEMENT_SUPPORT ? Element.prototype : undefined\n\n// See: https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\nexport const matchesEl =\n  ELEMENT_PROTO?.matches ||\n  (ELEMENT_PROTO as any)?.msMatchesSelector ||\n  ELEMENT_PROTO?.webkitMatchesSelector\n\n/**\n * @param el\n * @returns\n */\nexport const isElement = (el: HTMLElement | Element): boolean =>\n  !!(el && el.nodeType === Node.ELEMENT_NODE)\n\n/**\n * @param el\n * @returns\n */\nexport const getBCR = (el: HTMLElement) => (isElement(el) ? el.getBoundingClientRect() : null)\n\n/**\n * @param excludes\n * @returns\n */\nexport const getActiveElement = (excludes = []): Element | null => {\n  const {activeElement} = document\n  return activeElement && !excludes.some((el: HTMLElement) => el === activeElement)\n    ? activeElement\n    : null\n}\n\n/**\n * @param el\n * @returns\n */\nexport const isActiveElement = (el: HTMLElement): boolean =>\n  isElement(el) && el === getActiveElement()\n\n/**\n * @param el\n * @param options\n * @returns\n */\nexport const attemptFocus = (el: HTMLElement, options = {}): boolean => {\n  try {\n    el.focus(options)\n  } catch (e) {\n    console.error(e)\n  }\n  return isActiveElement(el)\n}\n\n/**\n * Attempt to blur an element, and return `true` if successful\n *\n * @param el\n * @returns\n */\nexport const attemptBlur = (el: HTMLElement): boolean => {\n  try {\n    el.blur()\n  } catch (e) {\n    console.error(e)\n  }\n  return !isActiveElement(el)\n}\n\n/**\n * @param el\n * @param prop\n * @returns\n */\nexport const getStyle = (el: HTMLElement, prop: string) =>\n  prop && isElement(el) ? el.getAttribute(prop) || null : null\n\n/**\n * @param parent\n * @param child\n * @returns\n */\nexport const contains = (parent: Node, child: Node): boolean => parent.contains(child)\n\n/**\n * @param el\n * @returns\n */\nexport const isVisible = (el: HTMLElement): boolean => {\n  //if (!isElement(el) || !el.parentNode || !contains(DOCUMENT.body, el)) {\n  // Note this can fail for shadow dom elements since they\n  // are not a direct descendant of document.body\n  //return false\n  //}\n  if (getStyle(el, 'display') === 'none') {\n    // We do this check to help with vue-test-utils when using v-show\n    return false\n  }\n  // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(\n  // So any tests that need isVisible will fail in JSDOM\n  // Except when we override the getBCR prototype in some tests\n  const bcr = getBCR(el)\n  return !!(bcr && bcr.height > 0 && bcr.width > 0)\n}\n\n/**\n * @param slot\n * @param data\n * @returns\n */\nexport const isEmptySlot = (slot: Slot | undefined, data?: any) =>\n  !slot || slot(data).filter((vnode: VNode) => vnode.type !== Comment).length < 1\n\n/**\n * @param el\n * @returns\n */\nexport const offset = (el: HTMLElement) => {\n  const _offset = {top: 0, left: 0}\n  if (!isElement(el) || el.getClientRects().length === 0) {\n    return _offset\n  }\n  const bcr = getBCR(el)\n  if (bcr) {\n    const win = el.ownerDocument.defaultView\n    _offset.top = bcr.top + (win?.pageYOffset || 0)\n    _offset.left = bcr.left + (win?.pageXOffset || 0)\n  }\n  return _offset\n}\n\n/**\n * Select a single element, returns `null` if not found\n *\n * @param selector\n * @param root\n * @returns\n */\nexport const select = (selector: any, root: any) =>\n  (isElement(root) ? root : DOCUMENT).querySelector(selector) || null\n\n/**\n * @param selector\n * @param root\n * @returns\n */\nexport const selectAll = (selector: any, root: any) =>\n  Array.from([(isElement(root) ? root : DOCUMENT).querySelectorAll(selector)])\n\n/**\n * @param el\n * @param attr\n * @returns\n */\nexport const getAttr = (el: HTMLElement | Element, attr: string): string | null =>\n  attr && isElement(el) ? el.getAttribute(attr) : null\n\n// Get an element given an ID\nexport const getById = (id: string) =>\n  DOCUMENT.getElementById(/^#/.test(id) ? id.slice(1) : id) || null\n\n/**\n * @param el\n * @param attr\n * @param value\n */\nexport const setAttr = (el: HTMLElement, attr: string, value: string): void => {\n  if (attr && isElement(el)) {\n    el.setAttribute(attr, value)\n  }\n}\n\n/**\n * Remove an attribute from an element\n *\n * @param el\n * @param attr\n */\nexport const removeAttr = (el: HTMLElement, attr: string): void => {\n  if (attr && isElement(el)) {\n    el.removeAttribute(attr)\n  }\n}\n\n/**\n * @param tag\n * @param name\n * @returns\n */\nexport const isTag = (tag: any, name: any): boolean =>\n  toString(tag).toLowerCase() === toString(name).toLowerCase()\n\nexport const requestAF: AnimationFrame = HAS_WINDOW_SUPPORT\n  ? window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    // Fallback, but not a true polyfill\n    // Only needed for Opera Mini\n    ((cb) => setTimeout(cb, 16))\n  : (cb) => setTimeout(cb, 0)\n\n// Determine if an element matches a selector\nexport const matches = (el: Element, selector: string) =>\n  isElement(el) ? matchesEl.call(el, selector) : false\n\n// See: https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n/* eslint-disable @typescript-eslint/no-this-alias */\nexport const closestEl =\n  ELEMENT_PROTO?.closest ||\n  function (this: Element, sel: string) {\n    let el = this\n    if (!el) return null\n    do {\n      // Use our \"patched\" matches function\n      if (matches(el, sel)) {\n        return el\n      }\n      el = el.parentElement || (el.parentNode as any)\n    } while (el !== null && el.nodeType === Node.ELEMENT_NODE)\n    return null\n  }\n\n// Finds closest element matching selector. Returns `null` if not found\nexport const closest = (selector: string, root: Element, includeRoot = false) => {\n  if (!isElement(root)) {\n    return null\n  }\n  const el = closestEl.call(root, selector)\n\n  // Native closest behaviour when `includeRoot` is truthy,\n  // else emulate jQuery closest and return `null` if match is\n  // the passed in root element when `includeRoot` is falsey\n  return includeRoot ? el : el === root ? null : el\n}\n","type PropDefinition = {\n  type: any[]\n  default: any\n}\n\nexport interface ComponentProps {\n  [key: string]: PropDefinition\n}\n\n/**\n * @param prefix\n * @param breakpoints\n * @param definition\n * @returns\n */\nexport default (\n  prefix: string,\n  breakpoints: string[],\n  definition: PropDefinition\n): ComponentProps =>\n  breakpoints.concat(['sm', 'md', 'lg', 'xl', 'xxl']).reduce((props, breakpoint) => {\n    props[\n      !prefix ? breakpoint : `${prefix}${breakpoint.charAt(0).toUpperCase() + breakpoint.slice(1)}`\n    ] = definition\n    return props\n  }, Object.create(null))\n","export interface ComponentProps {\n  [key: string]: {type: any[]; default: any}\n}\n\n/**\n * @param props\n * @param els\n * @param propPrefix\n * @param classPrefix\n * @returns\n */\nexport default (\n  props: Record<PropertyKey, unknown>,\n  els: ComponentProps,\n  propPrefix: string,\n  classPrefix = propPrefix\n): string[] =>\n  Object.keys(els).reduce((arr: string[], prop) => {\n    if (!props[prop]) return arr\n\n    arr.push(\n      [classPrefix, prop.replace(propPrefix, ''), props[prop]]\n        .filter((e) => e && typeof e !== 'boolean')\n        .join('-')\n        .toLowerCase()\n    )\n\n    return arr\n  }, [])\n","/**\n * @param suffix\n * @returns\n */\nexport default (suffix = ''): string =>\n  `__BVID__${Math.random().toString().slice(2, 8)}___BV_${suffix}__`\n","import type {AriaInvalid} from '../types'\n\n/**\n * Resolves the aria-invalid and state props to a basic aria-invalid attribute\n *\n * @param {AriaInvalid} ariaInvalid `Truthy` values, and more specific `'grammar' | 'spelling'` values have higher priority than 'state' param, `Falsy` values have lower priority than 'state'\n * @param {boolean} state If the prop state is `false`, it will render the aria-invalid attribute to be `'true'`, as the value would be considered invalid\n * @returns Truthy > Grammar | Spelling > State > Falsy\n */\nexport default (ariaInvalid?: AriaInvalid, state?: boolean): Exclude<AriaInvalid, ''> | undefined =>\n  ariaInvalid === true || ariaInvalid === 'true' || ariaInvalid === ''\n    ? 'true'\n    : ariaInvalid === 'grammar' || ariaInvalid === 'spelling'\n    ? ariaInvalid\n    : state === false\n    ? 'true'\n    : ariaInvalid === false || ariaInvalid === 'false'\n    ? 'false'\n    : undefined\n","const _isObject = (item: unknown): boolean =>\n  !!item && typeof item === 'object' && item.constructor === Object\n\n/**\n * @param target\n * @param source\n * @param extendArray\n * @returns\n */\nconst mergeDeep = (target: any, source: any, extendArray = true) => {\n  const output =\n    target instanceof Date && typeof target.getMonth === 'function'\n      ? new Date(target.getTime())\n      : Object.assign({}, target)\n  if (_isObject(target) && _isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (_isObject(source[key])) {\n        if (!(key in target)) Object.assign(output, {[key]: source[key]})\n        else output[key] = mergeDeep(target[key], source[key], extendArray)\n      } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {\n        Object.assign(output, {\n          [key]: !extendArray\n            ? source[key]\n            : target[key].concat(\n                source[key].filter((item: unknown) => !target[key].includes(item))\n              ),\n        })\n      } else {\n        Object.assign(output, {[key]: source[key]})\n      }\n    })\n  }\n  return output\n}\n\nexport default mergeDeep\n","import type {Slots, VNode} from 'vue'\n\n/**\n * @param name\n * @param scope\n * @param $slots\n * @returns\n */\nexport default (name: string, scope = {}, $slots: Slots = {}): VNode => {\n  // Ensure names is an array\n  const names = [name]\n  let slot\n  for (let i = 0; i < names.length && !slot; i++) {\n    const name = names[i]\n    slot = $slots[name]\n  }\n  // Note: in Vue 3.x, slots have been unified. No more scoped slots and all slots are exposed as functions\n  return (slot && typeof slot === 'function' ? slot(scope) : slot) as unknown as VNode\n}\n","/**\n * Validates a number is an integer. If not return NaN\n *\n * @param value\n * @param defaultValue\n * @returns\n */\nexport const toInteger = (value: number, defaultValue = NaN): number =>\n  Number.isInteger(value) ? value : defaultValue\n\n/**\n * @param value\n * @param defaultValue\n * @returns\n */\nexport const stringToInteger = (value: string, defaultValue = NaN): number => {\n  const integer = Number.parseInt(value, 10)\n  return Number.isNaN(integer) ? defaultValue : integer\n}\n\n/**\n * Validates a number is a float. If not return NaN\n *\n * @param value\n * @param defaultValue\n * @returns\n */\nexport const toFloat = (value: number | string, defaultValue = NaN): number => {\n  const float = Number.parseFloat(value.toString())\n  return Number.isNaN(float) ? defaultValue : float\n}\n\n/**\n * Float given to a certain decimal place\n *\n * @param val\n * @param precision\n * @returns\n */\nexport const toPercison = (val: number, precision: number): string =>\n  toFloat(val).toPrecision(precision)\n","/**\n * Removes properties from an object, based on the values in an array, and returns the new object.\n * Equivalent to an object version of TS Omit<>\n *\n * @param {Record<PropertyKey, unknown>} objToPluck\n * @param {ReadonlyArray<PropertyKey>} keysToPluck\n * @returns\n */\nexport const omit = <A extends Record<PropertyKey, unknown>, B extends ReadonlyArray<PropertyKey>>(\n  objToPluck: A,\n  keysToPluck: B\n): Omit<A, B[number]> =>\n  Object.keys(objToPluck)\n    .filter((key) => !keysToPluck.includes(key))\n    .reduce((result, key) => ({...result, [key]: objToPluck[key]}), {} as Omit<A, B[number]>)\n\n/**\n * Convenience method to create a read-only descriptor\n *\n * @returns\n */\nexport const readonlyDescriptor = () => ({enumerable: true, configurable: false, writable: false})\n\n/**\n * Deeply clones an item\n *\n * @param {T} source\n * @returns\n */\nexport const cloneDeep = <T>(source: T): T =>\n  Array.isArray(source)\n    ? source.map((item) => cloneDeep(item))\n    : source instanceof Date\n    ? new Date(source.getTime())\n    : source && typeof source === 'object'\n    ? Object.getOwnPropertyNames(source).reduce((o, prop) => {\n        Object.defineProperty(o, prop, Object.getOwnPropertyDescriptor(source, prop) ?? {})\n        o[prop] = cloneDeep((source as unknown as {[key: string]: unknown})[prop])\n        return o\n      }, Object.create(Object.getPrototypeOf(source)))\n    : source\n\nexport const cloneDeepAsync = <T>(source: T): Promise<T> =>\n  new Promise((resolve) => resolve(cloneDeep(source)))\n","// Suffix can be a falsey value so nothing is appended to string\n// (helps when looping over props & some shouldn't change)\n\nimport {upperFirst} from './stringUtils'\n\n/**\n * Use data last parameters to allow for currying\n *\n * @param suffix\n * @param value\n * @returns\n */\nexport const suffixPropName = (suffix: string, value: string): string =>\n  value + (suffix ? upperFirst(suffix) : '')\n\n/**\n * Given an array of properties or an object of property keys, plucks all the values off the target object, returning a new object that has props that reference the original prop values.\n * An object equivelent to TS Pick<>\n *\n * @param {ReadonlyArray<PropertyKey> | Record<PropertyKey, unknown>} keysToPluck\n * @param {Record<PropertyKey, unknown>} objToPluck\n * @returns\n */\nexport const pluckProps = <\n  A extends Record<PropertyKey, unknown>,\n  B extends ReadonlyArray<PropertyKey> | Record<PropertyKey, unknown>\n>(\n  objToPluck: A,\n  keysToPluck: B\n): B extends readonly PropertyKey[] ? Pick<A, B[number]> : Pick<A, keyof B> =>\n  (Array.isArray(keysToPluck) ? keysToPluck.slice() : Object.keys(keysToPluck)).reduce(\n    (memo, prop) => {\n      memo[prop] = objToPluck[prop]\n      return memo\n    },\n    {}\n  )\n","import type {Booleanish} from '../types'\n\n/**\n * Type predicate function to check if the input is Booleanish type\n *\n * @param  {unknown} input\n * @returns inputisBooleanish\n */\nexport const isBooleanish = (input: unknown): input is Booleanish =>\n  typeof input === 'boolean' || input === '' || input === 'true' || input === 'false'\n\n/**\n * Converts a Booleanish type to boolean\n *\n * @param {Booleanish} input\n * @returns\n */\nexport const resolveBooleanish = (input: Booleanish): boolean =>\n  typeof input === 'boolean' ? input : input === '' ? true : input === 'true' ? true : false\n","import type {RouteLocationRaw} from 'vue-router'\n\n/**\n * @param {{href?: string; to?: RouteLocationRaw}} props\n * @returns\n */\nexport default (props: {href?: string; to?: RouteLocationRaw}): boolean =>\n  !!(props.href || props.to)\n","import type {Booleanish} from '../types'\nimport type {Ref} from 'vue'\nimport {resolveBooleanish} from '../utils'\nimport {computedEager} from '@vueuse/core'\n\n// function useBooleanish<T>(el: Ref<Booleanish | T>): ComputedRef<boolean | T>\n// This may possibily be used in Vue 3.3 to include Booleanish and complex types ie Booleanish | string\n/**\n * Resolves a Booleanish type reactively to type boolean\n */\nfunction useBooleanish(el: Ref<Booleanish>): Readonly<Ref<boolean>>\nfunction useBooleanish(el: Ref<Booleanish | null>): Readonly<Ref<boolean | null>>\nfunction useBooleanish(el: Ref<Booleanish | undefined>): Readonly<Ref<boolean | undefined>>\nfunction useBooleanish(\n  el: Ref<Booleanish | undefined | null>\n): Readonly<Ref<boolean | undefined | null>>\nfunction useBooleanish(\n  el:\n    | Ref<Booleanish>\n    | Ref<Booleanish | undefined>\n    | Ref<Booleanish | null>\n    | Ref<Booleanish | undefined | null>\n):\n  | Readonly<Ref<boolean>>\n  | Readonly<Ref<boolean | undefined>>\n  | Readonly<Ref<boolean | null>>\n  | Readonly<Ref<boolean | undefined | null>> {\n  return computedEager(() =>\n    el.value === undefined || el.value === null ? el.value : resolveBooleanish(el.value)\n  )\n}\n\nexport default useBooleanish\n","import {type App, inject, type InjectionKey, reactive} from 'vue'\nimport type {BreadcrumbItem} from '../types'\n\nexport interface UseBreadcrumbOptions {\n  items: BreadcrumbItem[]\n  readonly reset: () => void\n}\n\nexport const BREADCRUMB_SYMBOL: InjectionKey<UseBreadcrumbOptions> = Symbol()\n\nconst BREADCRUMB_OBJECT: UseBreadcrumbOptions = {\n  items: reactive<BreadcrumbItem[]>([]),\n  reset(): void {\n    this.items = reactive<BreadcrumbItem[]>([])\n  },\n}\n\n/**\n * @param app\n */\nexport const createBreadcrumb = (app: App): void => {\n  app.provide(BREADCRUMB_SYMBOL, BREADCRUMB_OBJECT)\n}\n\n/**\n * @external\n *\n * @returns\n */\nexport const useBreadcrumb = (): UseBreadcrumbOptions =>\n  inject(BREADCRUMB_SYMBOL) ?? BREADCRUMB_OBJECT\n","import {onBeforeUnmount, onMounted, type Ref} from 'vue'\n\n/**\n * @param element\n * @param event\n * @param callback\n */\nexport default (\n  element: Ref<HTMLElement | undefined>,\n  event: string,\n  callback: EventListener\n): void => {\n  onMounted(() => {\n    element?.value?.addEventListener(event, callback)\n  })\n  onBeforeUnmount(() => {\n    element?.value?.removeEventListener(event, callback)\n  })\n}\n","import type {AriaInvalid, ButtonVariant, InputSize} from '../types'\nimport {computed, type ComputedRef} from 'vue'\nimport {resolveAriaInvalid} from '../utils'\n\n/**\n * @param items must be a reactive object ex: reactive({ plain: toRef(plainBoolean, 'value')})\n * @returns\n */\nconst getClasses = (items: {\n  plain?: boolean\n  button?: boolean\n  inline?: boolean\n  switch?: boolean\n  size?: InputSize\n}) =>\n  computed(() => ({\n    'form-check': items.plain === false && items.button === false,\n    'form-check-inline': items.inline === true,\n    'form-switch': items.switch === true,\n    [`form-control-${items.size}`]: items.size !== undefined && items.size !== 'md',\n  }))\n\n/**\n * @param items must be a reactive object ex: reactive({ plain: toRef(plainBoolean, 'value')})\n * @returns\n */\nconst getInputClasses = (items: {plain?: boolean; button?: boolean; state?: boolean}) =>\n  computed(() => ({\n    'form-check-input': items.plain === false && items.button === false,\n    'is-valid': items.state === true,\n    'is-invalid': items.state === false,\n    'btn-check': items.button === true,\n  }))\n\n/**\n * @param items must be a reactive object ex: reactive({ plain: toRef(plainBoolean, 'value')})\n * @returns\n */\nconst getLabelClasses = (items: {\n  plain?: boolean\n  button?: boolean\n  buttonVariant?: ButtonVariant\n  size?: InputSize\n}) =>\n  computed(() => ({\n    'form-check-label': items.plain === false && items.button === false,\n    'btn': items.button === true,\n    [`btn-${items.buttonVariant}`]: items.button === true && items.buttonVariant !== undefined,\n    [`btn-${items.size}`]: items.button && items.size && items.size !== 'md',\n  }))\n\n/**\n * @param items must be a reactive object ex: reactive({ plain: toRef(plainBoolean, 'value')})\n * @returns\n */\nconst getGroupAttr = (items: {required?: boolean; ariaInvalid?: AriaInvalid; state?: boolean}) =>\n  computed(() => ({\n    'aria-invalid': resolveAriaInvalid(items.ariaInvalid, items.state),\n    'aria-required': items.required === true ? true : undefined,\n  }))\n\n/**\n * @param items must be a reactive object ex: reactive({ plain: toRef(plainBoolean, 'value')})\n * @returns\n */\nconst getGroupClasses = (items: {\n  validated?: boolean\n  buttons?: boolean\n  stacked?: boolean\n  size?: InputSize\n}) =>\n  computed(() => ({\n    'was-validated': items.validated === true,\n    'btn-group': items.buttons === true && items.stacked === false,\n    'btn-group-vertical': items.stacked === true, // Does this need items.buttons?\n    [`btn-group-${items.size}`]: items.size !== undefined,\n  }))\n\n// TODO this function is similarly used in BTabs and may be capable of being a util function\n// Investigate if it can be done to reduce complexity\n/**\n * @param slots\n * @param nodeType\n * @param disabled\n * @returns\n */\nconst slotsToElements = (slots: Array<any>, nodeType: string, disabled: boolean) =>\n  slots\n    .reduce(\n      (acc: Array<any>, slot: any) =>\n        slot.type.toString() === 'Symbol(Fragment)'\n          ? acc.concat(slot.children)\n          : acc.concat([slot]),\n      []\n    )\n    .filter((e: any) => e.type.__name === nodeType || e.type.name === nodeType)\n    .map((e: any) => {\n      const txtChild = (e.children.default ? e.children.default() : []).find(\n        (e: any) => e.type.toString() === 'Symbol(Text)'\n      )\n\n      return {\n        props: {\n          disabled,\n          ...e.props,\n        },\n        text: txtChild ? txtChild.children : '',\n      }\n    })\n\n/**\n * @param option\n * @param props\n * @returns\n */\nconst optionToElement = (option: any, props: any): any => {\n  if (typeof option === 'string') {\n    return {\n      props: {\n        value: option,\n        disabled: props.disabled,\n      },\n      text: option,\n    }\n  }\n\n  return {\n    props: {\n      value: option[props.valueField],\n      disabled: props.disabled || option[props.disabledField],\n      ...option.props,\n    },\n    text: option[props.textField],\n    html: option[props.htmlField],\n  }\n}\n\n/**\n * @param el\n * @param idx\n * @param props\n * @param computedName\n * @param computedId\n * @returns\n */\nconst bindGroupProps = (\n  el: any,\n  idx: number,\n  props: any,\n  computedName: ComputedRef<string>,\n  computedId: ComputedRef<string>\n) => ({\n  ...el,\n  props: {\n    'button-variant': props.buttonVariant,\n    'form': props.form,\n    'name': computedName.value,\n    'id': `${computedId.value}_option_${idx}`,\n    'button': props.buttons,\n    'state': props.state,\n    'plain': props.plain,\n    'size': props.size,\n    'inline': !props.stacked,\n    'required': props.required,\n    ...el.props,\n  },\n})\n\nexport {\n  getClasses,\n  getInputClasses,\n  getLabelClasses,\n  getGroupAttr,\n  getGroupClasses,\n  slotsToElements,\n  optionToElement,\n  bindGroupProps,\n}\n","import {getId} from '../utils'\nimport {computed, type ComputedRef, type Ref} from 'vue'\n\n/**\n * @param id\n * @param suffix\n * @returns\n */\nexport default (id?: Ref<string | undefined>, suffix?: string): ComputedRef<string> =>\n  computed(() => id?.value || getId(suffix))\n","import type {AriaInvalid, Size} from '../types'\nimport {\n  computed,\n  type ExtractPropTypes,\n  nextTick,\n  onActivated,\n  onMounted,\n  type PropType,\n  ref,\n  toRef,\n  watch,\n} from 'vue'\nimport useId from './useId'\nimport {resolveAriaInvalid} from '../utils'\n\nexport const COMMON_INPUT_PROPS = {\n  ariaInvalid: {\n    type: [Boolean, String] as PropType<AriaInvalid>,\n    default: undefined,\n  },\n  autocomplete: {type: String, required: false},\n  autofocus: {type: Boolean, default: false},\n  disabled: {type: Boolean, default: false},\n  form: {type: String, required: false},\n  formatter: {type: Function, required: false},\n  id: {type: String, required: false},\n  lazy: {type: Boolean, default: false},\n  lazyFormatter: {type: Boolean, default: false},\n  list: {type: String, required: false},\n  modelValue: {type: [String, Number] as PropType<string | number>, default: ''},\n  name: {type: String, required: false},\n  number: {type: Boolean, default: false},\n  placeholder: {type: String, required: false},\n  plaintext: {type: Boolean, default: false},\n  readonly: {type: Boolean, default: false},\n  required: {type: Boolean, default: false},\n  size: {type: String as PropType<Size>, required: false},\n  state: {type: Boolean as PropType<boolean | null | undefined>, default: null},\n  trim: {type: Boolean, default: false},\n}\n\ntype InputProps = ExtractPropTypes<typeof COMMON_INPUT_PROPS>\ntype InputEmitType = (\n  event: 'update:modelValue' | 'change' | 'blur' | 'input',\n  ...args: any[]\n) => void\n\n/**\n * @param props\n * @param emit\n * @returns\n */\nexport default (props: Readonly<InputProps>, emit: InputEmitType) => {\n  const input = ref<HTMLInputElement>()\n  let inputValue: string | null = null\n  let neverFormatted = true\n  const computedId = useId(toRef(props, 'id'), 'input')\n\n  const _formatValue = (value: unknown, evt: any, force = false) => {\n    value = String(value)\n    if (typeof props.formatter === 'function' && (!props.lazyFormatter || force)) {\n      neverFormatted = false\n      return props.formatter(value, evt)\n    }\n    return value\n  }\n\n  const _getModelValue = (value: any) => {\n    if (props.trim) return value.trim()\n    if (props.number) return Number.parseFloat(value)\n\n    return value\n  }\n\n  const handleAutofocus = () => {\n    nextTick(() => {\n      if (props.autofocus) input.value?.focus()\n    })\n  }\n\n  onMounted(handleAutofocus)\n  onMounted(() => {\n    if (input.value) {\n      input.value.value = props.modelValue as string\n    }\n  })\n\n  onActivated(handleAutofocus)\n\n  const computedAriaInvalid = computed(() =>\n    resolveAriaInvalid(props.ariaInvalid, props.state ?? undefined)\n  )\n\n  const onInput = (evt: Event) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (formattedValue === false || evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    if (props.lazy) return\n\n    const nextModel = _getModelValue(formattedValue)\n\n    if (props.modelValue !== nextModel) {\n      inputValue = value\n      emit('update:modelValue', nextModel)\n    }\n\n    emit('input', formattedValue)\n  }\n\n  const onChange = (evt: Event) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (formattedValue === false || evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    if (!props.lazy) return\n    inputValue = value\n    emit('update:modelValue', formattedValue)\n\n    const nextModel = _getModelValue(formattedValue)\n    if (props.modelValue !== nextModel) {\n      emit('change', formattedValue)\n    }\n  }\n\n  const onBlur = (evt: FocusEvent) => {\n    emit('blur', evt)\n    if (!props.lazy && !props.lazyFormatter) return\n\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt, true)\n\n    inputValue = value\n    emit('update:modelValue', formattedValue)\n  }\n\n  const focus = () => {\n    if (!props.disabled) input.value?.focus()\n  }\n\n  const blur = () => {\n    if (!props.disabled) {\n      input.value?.blur()\n    }\n  }\n\n  watch(\n    () => props.modelValue,\n    (newValue) => {\n      if (!input.value) return\n      input.value.value = inputValue && neverFormatted ? inputValue : (newValue as string)\n      inputValue = null\n      neverFormatted = true\n    }\n  )\n\n  return {\n    input,\n    computedId,\n    computedAriaInvalid,\n    onInput,\n    onChange,\n    onBlur,\n    focus,\n    blur,\n  }\n}\n","const _getNested = (obj: any, path: string): any => {\n  if (!obj) return obj\n  if (path in obj) return obj[path]\n\n  const paths = path.split('.')\n\n  return _getNested(obj[paths[0]], paths.splice(1).join('.'))\n}\n\nconst _normalizeOption = (\n  option: any,\n  key: string | null = null,\n  componentName: string,\n  props: any\n) => {\n  if (Object.prototype.toString.call(option) === '[object Object]') {\n    const value = _getNested(option, props.valueField)\n    const text = _getNested(option, props.textField)\n    const html = _getNested(option, props.htmlField)\n    const disabled = _getNested(option, props.disabledField)\n\n    const options = option[props.optionsField] || null\n    if (options !== null) {\n      return {\n        label: String(_getNested(option, props.labelField) || text),\n        options: normalizeOptions(options, componentName, props),\n      }\n    }\n\n    return {\n      value: typeof value === 'undefined' ? key || text : value,\n      text: String(typeof text === 'undefined' ? key : text),\n      html,\n      disabled: Boolean(disabled),\n    }\n  }\n  return {\n    value: key || option,\n    text: String(option),\n    disabled: false,\n  }\n}\n\n/**\n * @param options\n * @param componentName\n * @param props\n * @returns\n */\nconst normalizeOptions = (\n  options: any[],\n  componentName: string,\n  props: Record<string, unknown>\n): any => {\n  if (Array.isArray(options)) {\n    return options.map((option) => _normalizeOption(option, null, componentName, props))\n  } else if (Object.prototype.toString.call(options) === '[object Object]') {\n    console.warn(\n      `[BootstrapVue warn]: ${componentName} - Setting prop \"options\" to an object is deprecated. Use the array format instead.`\n    )\n\n    return Object.keys(options).map((key: string) => {\n      const el: any = options[key]\n      switch (typeof el) {\n        case 'object':\n          return _normalizeOption(el.text, String(el.value), componentName, props)\n        default:\n          return _normalizeOption(el, String(key), componentName, props)\n      }\n    })\n  }\n\n  return []\n}\n\nexport {normalizeOptions}\n","import {useColorMode, type UseColorModeOptions} from '@vueuse/core'\n\nexport default (persist = false, opts: UseColorModeOptions = {}) => {\n  const attribute = 'data-bs-theme'\n  const selector = 'body'\n  return useColorMode({\n    attribute,\n    selector,\n    storageKey: persist ? `${opts.attribute ?? attribute}-${opts.selector ?? selector}` : null,\n    ...opts,\n  })\n}\n","<template>\n  <div :id=\"computedId\" class=\"accordion\" :class=\"computedClasses\">\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// https://vuejs.org/guide/typescript/composition-api.html#syntax-limitations , may be possible in a future release\n// import type {BAccordionProps} from '../types/components'\nimport type {Booleanish} from '../../types'\nimport {computed, InjectionKey, provide, toRef} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\n\ninterface BAccordionProps {\n  flush?: Booleanish\n  free?: Booleanish\n  id?: string\n}\n\nconst props = withDefaults(defineProps<BAccordionProps>(), {\n  flush: false,\n  free: false,\n})\n\nconst computedId = useId(toRef(props, 'id'), 'accordion')\n\nconst flushBoolean = useBooleanish(toRef(props, 'flush'))\nconst freeBoolean = useBooleanish(toRef(props, 'free'))\n\nconst computedClasses = computed(() => ({\n  'accordion-flush': flushBoolean.value,\n}))\n\nif (!freeBoolean.value) {\n  provide(injectionKey, computedId.value)\n}\n</script>\n\n<script lang=\"ts\">\nexport const injectionKey: InjectionKey<string> = Symbol()\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"id\"\n    ref=\"element\"\n    class=\"collapse\"\n    :class=\"computedClasses\"\n    :data-bs-parent=\"accordion || null\"\n    :is-nav=\"isNavBoolean\"\n  >\n    <slot :visible=\"modelValueBoolean\" :close=\"close\" />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCollapseEmits, BCollapseProps} from '../types/components'\nimport {computed, onMounted, ref, toRef, watch} from 'vue'\nimport {Collapse} from 'bootstrap'\nimport {useBooleanish, useEventListener} from '../composables'\nimport {getId} from '../utils'\nimport type {Booleanish} from '../types'\n\ninterface BCollapseProps {\n  accordion?: string\n  // appear?: Booleanish\n  id?: string\n  modelValue?: Booleanish\n  tag?: string\n  toggle?: Booleanish\n  visible?: Booleanish\n  isNav?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BCollapseProps>(), {\n  id: getId(),\n  modelValue: false,\n  tag: 'div',\n  toggle: false,\n  visible: false,\n  isNav: false,\n})\n\nconst modelValueBoolean = useBooleanish(toRef(props, 'modelValue'))\nconst toggleBoolean = useBooleanish(toRef(props, 'toggle'))\nconst visibleBoolean = useBooleanish(toRef(props, 'visible'))\nconst isNavBoolean = useBooleanish(toRef(props, 'isNav'))\n\ninterface BCollapseEmits {\n  (e: 'update:modelValue', value: boolean): void\n  (e: 'show'): void\n  (e: 'shown'): void\n  (e: 'hide'): void\n  (e: 'hidden'): void\n}\n\nconst emit = defineEmits<BCollapseEmits>()\n\nconst element = ref<HTMLElement>()\nconst instance = ref<Collapse>()\n\nconst computedClasses = computed(() => ({\n  'show': modelValueBoolean.value,\n  'navbar-collapse': isNavBoolean.value,\n}))\n\nconst close = () => emit('update:modelValue', false)\n\nwatch(\n  () => modelValueBoolean.value,\n  (value) => {\n    if (value) {\n      instance.value?.show()\n    } else {\n      instance.value?.hide()\n    }\n  }\n)\nwatch(\n  () => visibleBoolean.value,\n  (value) => {\n    if (value) {\n      emit('update:modelValue', !!value)\n      instance.value?.show()\n    } else {\n      emit('update:modelValue', !!value)\n      instance.value?.hide()\n    }\n  }\n)\n\nuseEventListener(element, 'show.bs.collapse', () => {\n  emit('show')\n  emit('update:modelValue', true)\n})\n\nuseEventListener(element, 'hide.bs.collapse', () => {\n  emit('hide')\n  emit('update:modelValue', false)\n})\nuseEventListener(element, 'shown.bs.collapse', () => emit('shown'))\nuseEventListener(element, 'hidden.bs.collapse', () => emit('hidden'))\n\nonMounted(() => {\n  instance.value = new Collapse(element.value as HTMLElement, {\n    parent: props.accordion ? `#${props.accordion}` : undefined,\n    toggle: toggleBoolean.value,\n  })\n  if (visibleBoolean.value || modelValueBoolean.value) {\n    emit('update:modelValue', true)\n    instance.value?.show()\n  }\n})\n</script>\n","import type {Directive, DirectiveBinding} from 'vue'\n\nconst setTheme = (el: HTMLElement, value: string): void => el.setAttribute('data-bs-theme', value)\n\nexport default {\n  mounted(el, binding: DirectiveBinding): void {\n    setTheme(el, binding.value)\n  },\n  updated(el, binding: DirectiveBinding): void {\n    setTheme(el, binding.value)\n  },\n} as Directive<HTMLElement>\n","import type {Directive, DirectiveBinding} from 'vue'\nimport {Popover} from 'bootstrap'\n\n/**\n * @external\n */\nexport default {\n  mounted(el, binding: DirectiveBinding) {\n    const placement: Popover.Options['placement'] = binding.modifiers.left\n      ? 'left'\n      : binding.modifiers.right\n      ? 'right'\n      : binding.modifiers.bottom\n      ? 'bottom'\n      : binding.modifiers.top\n      ? 'top'\n      : 'right'\n\n    const trigger: Array<string> = []\n\n    if (binding.modifiers.manual) {\n      trigger.push('manual')\n    } else {\n      if (binding.modifiers.click) {\n        trigger.push('click')\n      }\n\n      if (binding.modifiers.hover) {\n        trigger.push('hover')\n      }\n\n      if (binding.modifiers.focus) {\n        trigger.push('focus')\n      }\n    }\n\n    el.setAttribute('data-bs-toggle', 'popover')\n\n    new Popover(el, {\n      trigger: trigger.length === 0 ? 'click' : (trigger.join(' ') as Popover.Options['trigger']),\n      placement,\n      content: binding.value,\n      html: binding.modifiers.html,\n    })\n  },\n  unmounted(el) {\n    const instance = Popover.getInstance(el)\n    if (instance !== null) {\n      instance.dispose()\n    }\n  },\n} as Directive<HTMLElement>\n","import {RX_HASH, RX_HASH_ID, RX_SPACE_SPLIT} from '../constants/regex'\nimport {getAttr, isTag} from '../utils'\nimport type {Directive, DirectiveBinding} from 'vue'\n\n/**\n *\n * @param el\n * @returns\n */\nconst resolveToggleType = (el: HTMLElement): string => {\n  if (el.classList.contains('offcanvas')) {\n    return 'offcanvas'\n  }\n\n  if (el.classList.contains('collapse')) {\n    return 'collapse'\n  }\n\n  throw Error(\"Couldn't resolve toggle type\")\n}\n\n/**\n *\n * @param binding\n * @param el\n * @returns\n */\nconst getTargets = (binding: DirectiveBinding<string>, el: HTMLElement) => {\n  const {modifiers, arg, value} = binding\n  // Any modifiers are considered target Ids\n  const targets = Object.keys(modifiers || {})\n\n  // If value is a string, split out individual targets (if space delimited)\n  const localValue = typeof value === 'string' ? value.split(RX_SPACE_SPLIT) : value\n\n  // Support target Id as link href (`href=\"#id\"`)\n  if (isTag(el.tagName, 'a')) {\n    const href = getAttr(el, 'href') || ''\n    if (RX_HASH_ID.test(href)) {\n      targets.push(href.replace(RX_HASH, ''))\n    }\n  }\n\n  // Add Id from `arg` (if provided), and support value\n  // as a single string Id or an array of string Ids\n  // If `value` is not an array or string, then it gets filtered out\n  Array.prototype.concat\n    .apply([], [arg, localValue])\n    .forEach((t) => typeof t === 'string' && targets.push(t))\n\n  // Return only unique and truthy target Ids\n  return targets.filter((t, index, arr) => t && arr.indexOf(t) === index)\n}\n\n/**\n * @external\n */\nexport default {\n  mounted(el, binding: DirectiveBinding<string>): void {\n    const targetIds = getTargets(binding, el)\n    const targetAttrs: Array<string> = []\n\n    const targetAttr = el.tagName === 'a' ? 'href' : 'data-bs-target'\n\n    targetIds.forEach((targetId) => {\n      const target = document.getElementById(targetId)\n\n      if (target !== null) {\n        el.setAttribute('data-bs-toggle', resolveToggleType(target))\n\n        targetAttrs.push(`#${targetId}`)\n      }\n    })\n\n    if (targetAttrs.length > 0) {\n      el.setAttribute(targetAttr, targetAttrs.join(','))\n    }\n\n    // if (typeof binding.arg === 'string') {\n    //   const target = document.getElementById(binding.arg)\n    //   let targetAttr = 'data-bs-target'\n\n    //   if (target) {\n    //     el.setAttribute('data-bs-toggle', resolveToggleType(target))\n\n    //     if (el.tagName === 'a') {\n    //       targetAttr = 'href'\n    //     }\n\n    //     el.setAttribute(targetAttr, `#${binding.arg}`)\n    //   }\n    // }\n\n    // TODO support class selector\n\n    // if (binding.arg) {\n    //     let toggle = 'collapse';\n    //     let selector = `#${binding.arg}`\n    //     const elements = document.querySelectorAll(`.${binding.arg}`);\n\n    //     if (elements.length > 1) {\n    //         selector = selector.replace('#', '.');\n    //     }\n\n    //     el.setAttribute('data-bs-target', selector)\n    // }\n  },\n} as Directive<HTMLElement>\n","import type {Directive, DirectiveBinding} from 'vue'\nimport {Tooltip} from 'bootstrap'\n\nconst resolveTrigger = (\n  modifiers: DirectiveBinding['modifiers'],\n  value: DirectiveBinding['value']\n): Tooltip.Options['trigger'] => {\n  if (value?.trigger) {\n    return value.trigger\n  }\n\n  if (modifiers.manual) {\n    return 'manual'\n  }\n\n  const trigger: Array<string> = []\n\n  if (modifiers.click) {\n    trigger.push('click')\n  }\n\n  if (modifiers.hover) {\n    trigger.push('hover')\n  }\n\n  if (modifiers.focus) {\n    trigger.push('focus')\n  }\n\n  return trigger.length > 0 ? (trigger.join(' ') as Tooltip.Options['trigger']) : 'hover focus'\n}\n\nconst resolvePlacement = (\n  modifiers: DirectiveBinding['modifiers'],\n  value: DirectiveBinding['value']\n): Tooltip.Options['placement'] =>\n  value?.placement\n    ? value.placement\n    : modifiers.left\n    ? 'left'\n    : modifiers.right\n    ? 'right'\n    : modifiers.bottom\n    ? 'bottom'\n    : 'top'\n\nconst resolveDelay = (values: DirectiveBinding['value']): Tooltip.Options['delay'] =>\n  values?.delay ? values.delay : 0\n\nconst resolveTitle = (values: DirectiveBinding['value']): Tooltip.Options['title'] => {\n  if (typeof values === 'undefined') {\n    console.warn(\n      'Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip=\\'{title: \"my title\"}\\'` nor `v-b-tooltip=\"\\'my title\\'\"` to define a title'\n    )\n    return ''\n  }\n  return typeof values === 'object' ? values?.title : values\n}\n\n/**\n * @external\n */\nexport default {\n  beforeMount(el, binding) {\n    el.setAttribute('data-bs-toggle', 'tooltip')\n    if (!el.getAttribute('title')) {\n      el.setAttribute('title', resolveTitle(binding.value).toString())\n    }\n\n    const isHtml = /<(\"[^\"]*\"|'[^']*'|[^'\">])*>/.test(el.title)\n    const trigger = resolveTrigger(binding.modifiers, binding.value)\n    const placement = resolvePlacement(binding.modifiers, binding.value)\n    const delay = resolveDelay(binding.value)\n    const title = el.getAttribute('title')\n\n    new Tooltip(el, {\n      trigger,\n      placement,\n      delay,\n      html: isHtml,\n    })\n\n    if (title) {\n      el.setAttribute('data-bs-original-title', title)\n    }\n  },\n  updated(el, binding) {\n    if (!el.getAttribute('title')) {\n      el.setAttribute('title', resolveTitle(binding.value).toString())\n    }\n\n    const title = el.getAttribute('title')\n    const originalTitle = el.getAttribute('data-bs-original-title')\n    const instance = Tooltip.getInstance(el)\n\n    el.removeAttribute('title')\n\n    if (title && title !== originalTitle) {\n      instance?.setContent({'.tooltip-inner': title})\n      el.setAttribute('data-bs-original-title', title)\n    }\n  },\n  unmounted(el) {\n    const instance = Tooltip.getInstance(el)\n    if (instance !== null) {\n      instance.dispose()\n    }\n  },\n} as Directive<HTMLElement>\n","import type {Directive, DirectiveBinding} from 'vue'\n\nconst observerInstances = new Map()\n\nclass VisibilityObserver {\n  private element: HTMLElement\n  private margin: string\n  private once: boolean\n  private callback: any\n  private instance: any\n  private observer: any\n\n  private doneOnce!: boolean\n  private visible!: boolean\n\n  constructor(element: HTMLElement, margin: string, once: boolean, callback: any, instance: any) {\n    this.element = element\n    this.margin = margin\n    this.once = once\n    this.callback = callback\n    this.instance = instance\n    this.createObserver()\n  }\n\n  createObserver() {\n    if (this.observer) {\n      this.stop()\n    }\n\n    if (this.doneOnce || typeof this.callback !== 'function') {\n      return\n    }\n\n    try {\n      this.observer = new IntersectionObserver(this.handler.bind(this), {\n        root: null,\n        rootMargin: this.margin,\n        threshold: 0,\n      })\n    } catch (e) {\n      console.error('Intersection Observer not supported')\n      this.doneOnce = true\n      this.observer = undefined\n      this.callback(null)\n      return\n    }\n\n    this.instance.$nextTick(() => {\n      if (this.observer) {\n        this.observer.observe(this.element)\n      }\n    })\n  }\n\n  handler(entries: IntersectionObserverEntry[]) {\n    const [entry] = entries\n    const isIntersecting = Boolean(entry.isIntersecting || entry.intersectionRatio > 0.0)\n    if (isIntersecting !== this.visible) {\n      this.visible = isIntersecting\n      this.callback(isIntersecting)\n      if (this.once && this.visible) {\n        this.doneOnce = true\n        this.stop()\n      }\n    }\n  }\n\n  stop() {\n    this.observer && this.observer.disconnect()\n    this.observer = null\n  }\n}\n\n/**\n *\n * @param el\n */\nconst destroy = (el: HTMLElement) => {\n  if (observerInstances.has(el)) {\n    const observer = observerInstances.get(el)\n    if (observer && observer.stop) {\n      observer.stop()\n    }\n    observerInstances.delete(el)\n  }\n}\n\n/**\n *\n * @param el\n * @param binding\n */\nconst bind = (el: HTMLElement, binding: DirectiveBinding) => {\n  const options = {\n    margin: '0px',\n    once: false,\n    callback: binding.value,\n  }\n  // Parse modifiers\n  Object.keys(binding.modifiers).forEach((mod) => {\n    if (Number.isInteger(mod)) {\n      options.margin = `${mod}px`\n    } else if (mod.toLowerCase() === 'once') {\n      options.once = true\n    }\n  })\n  // Destroy any previous observer\n  destroy(el)\n  // Create new observer\n  const observer = new VisibilityObserver(\n    el,\n    options.margin,\n    options.once,\n    options.callback,\n    binding.instance\n  )\n  observerInstances.set(el, observer)\n}\n\n/**\n * @external\n */\nexport default {\n  beforeMount(el, binding) {\n    bind(el, binding)\n  },\n  updated(el, binding) {\n    bind(el, binding)\n  },\n  unmounted(el) {\n    destroy(el)\n  },\n} as Directive<HTMLElement>\n","<template>\n  <div class=\"accordion-item\">\n    <h2 :id=\"`${computedId}heading`\" class=\"accordion-header\">\n      <button\n        v-b-toggle:[computedId]\n        class=\"accordion-button\"\n        :class=\"{collapsed: !visibleBoolean}\"\n        type=\"button\"\n        :aria-expanded=\"visibleBoolean ? 'true' : 'false'\"\n        :aria-controls=\"computedId\"\n      >\n        <slot name=\"title\">\n          {{ title }}\n        </slot>\n      </button>\n    </h2>\n    <b-collapse\n      :id=\"computedId\"\n      class=\"accordion-collapse\"\n      :visible=\"visible\"\n      :accordion=\"parent\"\n      :aria-labelledby=\"`heading${computedId}`\"\n    >\n      <div class=\"accordion-body\">\n        <slot />\n      </div>\n    </b-collapse>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {inject, toRef} from 'vue'\nimport BCollapse from '../BCollapse.vue'\nimport {BToggle as vBToggle} from '../../directives'\nimport {useBooleanish, useId} from '../../composables'\nimport {injectionKey} from './BAccordion.vue'\nimport type {Booleanish} from '../../types'\n// import type {BAccordionItemProps} from '../types/components'\n\ninterface BAccordionItemProps {\n  id?: string\n  title?: string\n  visible?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BAccordionItemProps>(), {visible: false})\n\nconst parent = inject<string>(injectionKey, '')\n\nconst computedId = useId(toRef(props, 'id'), 'accordion_item')\n\nconst visibleBoolean = useBooleanish(toRef(props, 'visible'))\n</script>\n","<template>\n  <Transition v-bind=\"computedAttrs\">\n    <slot />\n  </Transition>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, TransitionMode} from '../../types'\nimport {computed, toRef, TransitionProps} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ninterface Props {\n  appear?: Booleanish\n  mode?: TransitionMode\n  noFade?: Booleanish\n  transProps?: TransitionProps\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  appear: false,\n  noFade: false,\n})\n\nconst appearBoolean = useBooleanish(toRef(props, 'appear'))\nconst noFadeBoolean = useBooleanish(toRef(props, 'noFade'))\n\nconst fadeProperties = computed(() => {\n  const NO_FADE_PROPS = {\n    name: '',\n    enterActiveClass: '',\n    enterToClass: '',\n    leaveActiveClass: '',\n    leaveToClass: 'showing',\n    enterFromClass: 'showing',\n    leaveFromClass: '',\n  }\n  const FADE_PROPS = {\n    ...NO_FADE_PROPS,\n    enterActiveClass: 'fade showing',\n    leaveActiveClass: 'fade showing',\n  }\n  return noFadeBoolean.value ? NO_FADE_PROPS : FADE_PROPS\n})\n\nconst baseProperties = computed(() => ({mode: props.mode, css: true, ...fadeProperties.value}))\n\nconst computedAttrs = computed(() =>\n  props.transProps !== undefined\n    ? {\n        // Order matters here since the props.transProps would get overwritten if it came first\n        // But the goal of props.transProps is to overwrite base properties\n        ...baseProperties.value,\n        ...props.transProps,\n      }\n    : appearBoolean.value\n    ? {\n        ...baseProperties.value,\n        appear: true,\n        appearActiveClass: fadeProperties.value.enterActiveClass,\n        appearToClass: fadeProperties.value.enterToClass,\n      }\n    : baseProperties.value\n)\n</script>\n","<template>\n  <button\n    :type=\"type\"\n    class=\"btn-close\"\n    :disabled=\"disabledBoolean\"\n    :class=\"computedClasses\"\n    :aria-label=\"ariaLabel\"\n    @click=\"emit('click', $event)\"\n  />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCloseButtonProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, ButtonType} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BCloseButtonProps {\n  ariaLabel?: string\n  disabled?: Booleanish\n  white?: Booleanish\n  type?: ButtonType\n}\n\nconst props = withDefaults(defineProps<BCloseButtonProps>(), {\n  ariaLabel: 'Close',\n  disabled: false,\n  white: false,\n  type: 'button',\n})\n\ninterface BCloseButtonEmits {\n  (e: 'click', value: MouseEvent): void\n}\n\nconst emit = defineEmits<BCloseButtonEmits>()\n\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst whiteBoolean = useBooleanish(toRef(props, 'white'))\n\nconst computedClasses = computed(() => ({\n  'btn-close-white': whiteBoolean.value,\n}))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :class=\"computedClasses\"\n    :role=\"label || hasLabelSlot ? role : null\"\n    :aria-hidden=\"label || hasLabelSlot ? null : true\"\n  >\n    <span v-if=\"label || hasLabelSlot\" class=\"visually-hidden\">\n      <slot name=\"label\">{{ label }}</slot>\n    </span>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSpinnerProps} from '../types/components'\nimport {computed, toRef, useSlots} from 'vue'\nimport type {Booleanish, ColorVariant, SpinnerType} from '../types'\nimport {useBooleanish} from '../composables'\nimport {isEmptySlot} from '../utils'\n\ninterface BSpinnerProps {\n  label?: string\n  role?: string\n  small?: Booleanish\n  tag?: string\n  type?: SpinnerType\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BSpinnerProps>(), {\n  role: 'status',\n  small: false,\n  tag: 'span',\n  type: 'border',\n})\n\nconst slots = useSlots()\n\nconst smallBoolean = useBooleanish(toRef(props, 'small'))\n\nconst computedClasses = computed(() => ({\n  'spinner-border': props.type === 'border',\n  'spinner-border-sm': props.type === 'border' && smallBoolean.value,\n  'spinner-grow': props.type === 'grow',\n  'spinner-grow-sm': props.type === 'grow' && smallBoolean.value,\n  [`text-${props.variant}`]: props.variant !== undefined,\n}))\n\nconst hasLabelSlot = computed<boolean>(() => !isEmptySlot(slots.label))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    v-if=\"tag === 'router-link'\"\n    v-slot=\"{href, navigate, isActive, isExactActive}\"\n    v-bind=\"routerAttr\"\n    custom\n  >\n    <component\n      :is=\"routerTag\"\n      ref=\"link\"\n      :href=\"href\"\n      :class=\"[\n        (isActive || activeBoolean) && activeClass,\n        (isExactActive || exactBoolean) && exactActiveClass,\n      ]\"\n      v-bind=\"$attrs\"\n      @click=\"navigate\"\n    >\n      <slot />\n    </component>\n  </component>\n  <component\n    :is=\"tag\"\n    v-else\n    ref=\"link\"\n    :class=\"computedLinkClasses\"\n    v-bind=\"routerAttr\"\n    @click=\"clicked\"\n  >\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport type {Booleanish, LinkTarget} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, defineComponent, getCurrentInstance, type PropType, ref, toRef} from 'vue'\nimport type {RouteLocation, RouteLocationRaw} from 'vue-router'\n\nexport const BLINK_PROPS = {\n  active: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  activeClass: {type: String, default: 'router-link-active'},\n  append: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  event: {type: [String, Array], default: 'click'},\n  exact: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  exactActiveClass: {type: String, default: 'router-link-exact-active'},\n  href: {type: String},\n  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n  rel: {type: String, default: null},\n  replace: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  routerComponentName: {type: String, default: 'router-link'},\n  routerTag: {type: String, default: 'a'},\n  target: {type: String as PropType<LinkTarget>, default: '_self'},\n  to: {type: [String, Object] as PropType<RouteLocationRaw>, default: null},\n}\n\nexport default defineComponent({\n  props: BLINK_PROPS,\n  emits: ['click'],\n  setup(props, {emit, attrs}) {\n    const activeBoolean = useBooleanish(toRef(props, 'active'))\n    const appendBoolean = useBooleanish(toRef(props, 'append'))\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n    const exactBoolean = useBooleanish(toRef(props, 'exact'))\n    const replaceBoolean = useBooleanish(toRef(props, 'replace'))\n\n    const instance = getCurrentInstance()\n    const link = ref<HTMLElement>(null as unknown as HTMLElement)\n\n    const tag = computed<string>(() => {\n      const routerName = props.routerComponentName\n        .split('-')\n        .map((e) => e.charAt(0).toUpperCase() + e.slice(1))\n        .join('')\n      const hasRouter = instance?.appContext.app.component(routerName) !== undefined\n      if (!hasRouter || disabledBoolean.value || !props.to) {\n        return 'a'\n      }\n      return props.routerComponentName\n    })\n\n    const computedHref = computed<string>(() => {\n      const toFallback = '#'\n      if (props.href) return props.href\n\n      if (typeof props.to === 'string') return props.to || toFallback\n\n      const to = props.to as RouteLocation\n\n      if (\n        Object.prototype.toString.call(to) === '[object Object]' &&\n        (to.path || to.query || to.hash)\n      ) {\n        const path = to.path || ''\n        const query = to.query\n          ? `?${Object.keys(to.query)\n              .map((e) => `${e}=${to.query[e]}`)\n              .join('=')}`\n          : ''\n        const hash = !to.hash || to.hash.charAt(0) === '#' ? to.hash || '' : `#${to.hash}`\n        return `${path}${query}${hash}` || toFallback\n      }\n\n      return toFallback\n    })\n\n    const routerAttr = computed(() => ({\n      'to': props.to,\n      'href': computedHref.value,\n      'target': props.target,\n      'rel': props.target === '_blank' && props.rel === null ? 'noopener' : props.rel || null,\n      'tabindex': disabledBoolean.value\n        ? '-1'\n        : typeof attrs.tabindex === 'undefined'\n        ? null\n        : attrs.tabindex,\n      'aria-disabled': disabledBoolean.value ? 'true' : null,\n    }))\n\n    const computedLinkClasses = computed(() => ({\n      active: activeBoolean.value,\n      disabled: disabledBoolean.value,\n    }))\n\n    const clicked = (e: MouseEvent): void => {\n      if (disabledBoolean.value) {\n        e.preventDefault()\n        e.stopImmediatePropagation()\n        return\n      }\n      emit('click', e)\n    }\n\n    return {\n      computedLinkClasses,\n      tag,\n      routerAttr,\n      link,\n      clicked,\n      activeBoolean,\n      appendBoolean,\n      disabledBoolean,\n      replaceBoolean,\n      exactBoolean,\n    }\n  },\n})\n</script>\n","<template>\n  <component\n    :is=\"computedTag\"\n    class=\"btn\"\n    :class=\"computedClasses\"\n    v-bind=\"computedAttrs\"\n    @click=\"clicked\"\n  >\n    <div\n      v-if=\"loadingBoolean\"\n      class=\"btn-loading\"\n      :class=\"{'mode-fill': loadingMode === 'fill', 'mode-inline': loadingMode === 'inline'}\"\n    >\n      <slot name=\"loading\">\n        <b-spinner class=\"btn-spinner\" :small=\"size !== 'lg'\" />\n      </slot>\n    </div>\n    <div\n      class=\"btn-content\"\n      :class=\"{'btn-loading-fill': loadingBoolean && loadingMode === 'fill'}\"\n    >\n      <slot />\n    </div>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, toRef} from 'vue'\nimport BSpinner from '../BSpinner.vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ButtonType, ButtonVariant, InputSize, LinkTarget} from '../../types'\nimport {isLink} from '../../utils'\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\n\nexport default defineComponent({\n  components: {BLink, BSpinner},\n  props: {\n    ...BLINK_PROPS,\n    active: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    href: {type: String, required: false},\n    pill: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    pressed: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    rel: {type: String, default: undefined},\n    size: {type: String as PropType<InputSize>, default: 'md'},\n    squared: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    tag: {type: String, default: 'button'},\n    target: {type: String as PropType<LinkTarget>, default: '_self'},\n    type: {type: String as PropType<ButtonType>, default: 'button'},\n    variant: {type: String as PropType<ButtonVariant>, default: 'secondary'},\n    loading: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    loadingMode: {type: String as PropType<'fill' | 'inline'>, default: 'inline'},\n  },\n  emits: ['click', 'update:pressed'],\n  setup(props, {emit}) {\n    const activeBoolean = useBooleanish(toRef(props, 'active'))\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n    const pillBoolean = useBooleanish(toRef(props, 'pill'))\n    const pressedBoolean = useBooleanish(toRef(props, 'pressed'))\n    const squaredBoolean = useBooleanish(toRef(props, 'squared'))\n    const loadingBoolean = useBooleanish(toRef(props, 'loading'))\n\n    const isToggle = computed<boolean>(() => pressedBoolean.value === true)\n    const isButton = computed<boolean>(\n      () => props.tag === 'button' && props.href === undefined && props.to === null\n    )\n    const computedLink = computed<boolean>(() => isLink(props))\n    const isBLink = computed<boolean>(() => props.to !== null)\n    const nonStandardTag = computed<boolean>(() =>\n      props.href !== undefined ? false : !isButton.value\n    )\n\n    const computedClasses = computed(() => [\n      [`btn-${props.variant}`],\n      [`btn-${props.size}`],\n      {\n        'active': activeBoolean.value || pressedBoolean.value,\n        'rounded-pill': pillBoolean.value,\n        'rounded-0': squaredBoolean.value,\n        'disabled': disabledBoolean.value,\n      },\n    ])\n\n    const computedAttrs = computed(() => ({\n      'aria-disabled': nonStandardTag.value ? disabledBoolean.value : null,\n      'aria-pressed': isToggle.value ? pressedBoolean.value : null,\n      'autocomplete': isToggle.value ? 'off' : null,\n      'disabled': isButton.value ? disabledBoolean.value : null,\n      'href': props.href,\n      'rel': computedLink.value ? props.rel : null,\n      'role': nonStandardTag.value || computedLink.value ? 'button' : null,\n      'target': computedLink.value ? props.target : null,\n      'type': isButton.value ? props.type : null,\n      'to': !isButton.value ? props.to : null,\n      'append': computedLink.value ? props.append : null,\n      'activeClass': isBLink.value ? props.activeClass : null,\n      'event': isBLink.value ? props.event : null,\n      'exact': isBLink.value ? props.exact : null,\n      'exactActiveClass': isBLink.value ? props.exactActiveClass : null,\n      'replace': isBLink.value ? props.replace : null,\n      'routerComponentName': isBLink.value ? props.routerComponentName : null,\n      'routerTag': isBLink.value ? props.routerTag : null,\n    }))\n\n    const computedTag = computed<string | typeof BLink>(() =>\n      isBLink.value ? BLink : props.href ? 'a' : props.tag\n    )\n\n    const clicked = (e: MouseEvent): void => {\n      if (disabledBoolean.value) {\n        e.preventDefault()\n        e.stopPropagation()\n        return\n      }\n      emit('click', e)\n      if (isToggle.value) {\n        emit('update:pressed', !pressedBoolean.value)\n      }\n    }\n\n    return {\n      computedClasses,\n      computedAttrs,\n      computedTag,\n      clicked,\n      loadingBoolean,\n    }\n  },\n})\n</script>\n","import {\n  type MaybeComputedRef,\n  resolveUnref,\n  useIntervalFn,\n  type UseIntervalFnOptions,\n} from '@vueuse/core'\nimport {computed, type ComputedRef, readonly, type Ref, ref, watchEffect} from 'vue'\n\ntype VoidFn = () => void\n\ninterface CountdownReturn {\n  isActive: Readonly<Ref<boolean>>\n  isPaused: Readonly<Ref<boolean>>\n  restart: VoidFn\n  stop: VoidFn\n  resume: VoidFn\n  pause: VoidFn\n  value: ComputedRef<number>\n}\n\n/**\n * A simple interval timer that counts down the remaining seconds\n *\n * @param {MaybeComputedRef<number>} length the total amount of time to loop through in ms\n * @param {MaybeComputedRef<number>} interval how often the interval should refresh. Default 1000\n * @param {UseIntervalFnOptions} intervalOpts opts to pass to the interval fn. Default {}\n * @important ensure that you call `stop()` before unmount in the component\n */\nexport default (\n  length: MaybeComputedRef<number>,\n  interval: MaybeComputedRef<number> = ref(1000),\n  intervalOpts: UseIntervalFnOptions = {}\n): CountdownReturn => {\n  const isPaused = ref(false)\n\n  const intervalsPassed = ref<number>(0)\n\n  // Has watchEffect to set\n  const resolvedLength = ref(resolveUnref(length))\n\n  // Has watchEffect to set\n  const intervalLength = ref(resolveUnref(interval))\n\n  const amountOfIntervals = computed(() => Math.ceil(resolvedLength.value / intervalLength.value))\n\n  const value = computed(() =>\n    isActive.value || isPaused.value\n      ? Math.round(resolvedLength.value - intervalsPassed.value * intervalLength.value)\n      : 0\n  )\n\n  const {pause, resume, isActive} = useIntervalFn(\n    () => (intervalsPassed.value = intervalsPassed.value + 1),\n    interval,\n    intervalOpts\n  )\n\n  const restart = () => {\n    isPaused.value = false\n    intervalsPassed.value = 0\n    resume()\n  }\n\n  const stop = () => {\n    isPaused.value = false\n    intervalsPassed.value = amountOfIntervals.value\n    // pause() // Only here for the sake of demonstrating the flow. It will be called in the watchEffect\n  }\n\n  watchEffect(() => {\n    const newVal = resolveUnref(length)\n    const oldVal = resolvedLength.value\n    if (newVal === oldVal) return\n    resolvedLength.value = newVal\n    stop()\n    restart()\n  })\n\n  watchEffect(() => {\n    const newVal = resolveUnref(interval)\n    const oldVal = intervalLength.value\n    if (newVal === oldVal) return\n    intervalLength.value = newVal\n    stop()\n    restart()\n  })\n\n  watchEffect(() => {\n    if (intervalsPassed.value > amountOfIntervals.value) {\n      intervalsPassed.value = amountOfIntervals.value\n    }\n    if (intervalsPassed.value === amountOfIntervals.value) {\n      pause()\n    }\n  })\n\n  const myPause = () => {\n    if (isActive.value === false) return\n    isPaused.value = true\n    pause()\n  }\n\n  const myResume = () => {\n    if (intervalsPassed.value === amountOfIntervals.value) return\n    isPaused.value = false\n    resume()\n  }\n\n  return {\n    isActive: readonly(isActive),\n    isPaused: readonly(isPaused),\n    restart,\n    stop,\n    pause: myPause,\n    resume: myResume,\n    value,\n  }\n}\n","<template>\n  <b-transition :no-fade=\"!fadeBoolean\" :trans-props=\"{enterToClass: 'show'}\">\n    <div\n      v-if=\"isAlertVisible\"\n      class=\"alert\"\n      role=\"alert\"\n      aria-live=\"polite\"\n      aria-atomic=\"true\"\n      :class=\"computedClasses\"\n    >\n      <slot />\n      <template v-if=\"dismissibleBoolean\">\n        <!-- TODO this renders incorrectly -->\n        <b-button v-if=\"hasCloseSlot || closeContent\" type=\"button\" @click=\"closeClicked\">\n          <slot name=\"close\">\n            {{ closeContent }}\n          </slot>\n        </b-button>\n        <b-close-button v-else :aria-label=\"dismissLabel\" @click=\"closeClicked\" />\n      </template>\n    </div>\n  </b-transition>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BAlertEmits, BAlertProps} from '../types/components'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BButton from '../BButton/BButton.vue'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {computed, onBeforeUnmount, type Ref, toRef, useSlots, watchEffect} from 'vue'\nimport {isEmptySlot} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport useCountdown from '../../composables/useCountdown'\n\ninterface BAlertProps {\n  dismissLabel?: string\n  dismissible?: Booleanish\n  fade?: Booleanish\n  modelValue?: boolean | number\n  variant?: ColorVariant\n  closeContent?: string\n  immediate?: Booleanish\n  interval?: number\n  showOnPause?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BAlertProps>(), {\n  interval: 1000,\n  dismissLabel: 'Close',\n  dismissible: false,\n  fade: false,\n  modelValue: false,\n  variant: 'info',\n  immediate: true,\n  showOnPause: true,\n})\n\nconst dismissibleBoolean = useBooleanish(toRef(props, 'dismissible'))\nconst fadeBoolean = useBooleanish(toRef(props, 'fade'))\nconst immediateBoolean = useBooleanish(toRef(props, 'immediate'))\nconst showOnPauseBoolean = useBooleanish(toRef(props, 'showOnPause'))\n\ninterface BAlertEmits {\n  (e: 'closed'): void\n  (e: 'close-countdown', value: number): void\n  (e: 'update:modelValue', value: boolean | number): void\n}\n\nconst emit = defineEmits<BAlertEmits>()\n\nconst slots = useSlots()\n\nconst hasCloseSlot = computed<boolean>(() => !isEmptySlot(slots.close))\n\nconst computedClasses = computed(() => [\n  [`alert-${props.variant}`],\n  {\n    'alert-dismissible': dismissibleBoolean.value,\n  },\n])\n\nconst {\n  isActive,\n  pause,\n  restart,\n  resume,\n  stop,\n  isPaused,\n  value: remainingMs,\n} = useCountdown(\n  typeof props.modelValue === 'boolean' ? 0 : (toRef(props, 'modelValue') as Ref<number>),\n  toRef(props, 'interval'),\n  {\n    immediate: typeof props.modelValue === 'number' && immediateBoolean.value,\n  }\n)\n\nconst isAlertVisible = computed<boolean>(() =>\n  typeof props.modelValue === 'boolean'\n    ? props.modelValue\n    : isActive.value || (showOnPauseBoolean.value && isPaused.value)\n)\n\nwatchEffect(() => emit('close-countdown', remainingMs.value))\n\nconst closeClicked = (): void => {\n  if (typeof props.modelValue === 'boolean') {\n    emit('update:modelValue', false)\n  } else {\n    emit('update:modelValue', 0)\n    stop()\n  }\n  emit('closed')\n}\n\nonBeforeUnmount(() => stop())\n\ndefineExpose({pause, resume, restart, stop})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"b-avatar-group\" role=\"group\">\n    <div class=\"b-avatar-group-inner\" :style=\"paddingStyle\">\n      <slot />\n    </div>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type { BAvatarGroupParentData, BAvatarGroupProps, InputSize } from '../types/components'\nimport type {BAvatarGroupParentData} from '../../types/components'\nimport {computed, InjectionKey, provide, type StyleValue, toRef} from 'vue'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {isNumeric, toFloat} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {computeSize} from './BAvatar.vue'\n\ninterface BAvatarGroupProps {\n  overlap?: number | string\n  rounded?: boolean | string\n  size?: 'sm' | 'md' | 'lg' | string // size?: InputSize | string\n  square?: Booleanish\n  tag?: string\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BAvatarGroupProps>(), {\n  overlap: 0.3,\n  rounded: false,\n  square: false,\n  tag: 'div',\n})\n\nconst squareBoolean = useBooleanish(toRef(props, 'square'))\n\nconst computedSize = computed<string | null>(() => computeSize(props.size))\n\nconst overlapScale = computed<number>(\n  () => Math.min(Math.max(computeOverlap(props.overlap), 0), 1) / 2\n)\n\nconst paddingStyle = computed<StyleValue>(() => {\n  const value = computedSize.value ? `calc(${computedSize.value} * ${overlapScale.value})` : null\n  return value ? {paddingLeft: value, paddingRight: value} : {}\n})\n\nconst computeOverlap = (value: any): number =>\n  typeof value === 'string' && isNumeric(value) ? toFloat(value, 0) : value || 0\n\nprovide<BAvatarGroupParentData>(injectionKey, {\n  overlapScale,\n  size: props.size,\n  square: squareBoolean.value,\n  rounded: props.rounded,\n  variant: props.variant,\n})\n</script>\n\n<script lang=\"ts\">\nexport const injectionKey: InjectionKey<BAvatarGroupParentData> = Symbol()\n</script>\n","<template>\n  <component\n    :is=\"computedTag\"\n    class=\"b-avatar\"\n    :class=\"computedClasses\"\n    :style=\"computedStyle\"\n    v-bind=\"computedAttrs\"\n    @click=\"clicked\"\n  >\n    <span v-if=\"hasDefaultSlot\" class=\"b-avatar-custom\">\n      <slot />\n    </span>\n    <span v-else-if=\"!!src\" class=\"b-avatar-img\">\n      <img :src=\"src\" :alt=\"alt\" @error=\"onImgError\" />\n    </span>\n    <span v-else-if=\"!!text\" class=\"b-avatar-text\" :class=\"textClasses\" :style=\"textFontStyle\">\n      {{ text }}\n    </span>\n    <span v-if=\"showBadge\" class=\"b-avatar-badge\" :class=\"badgeClasses\" :style=\"badgeStyle\">\n      <slot v-if=\"hasBadgeSlot\" name=\"badge\" />\n      <span v-else :class=\"badgeTextClasses\">{{ badgeText }}</span>\n    </span>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type { BAvatarProps, BAvatarEmits, InputSize } from '../types/components'\nimport {isEmptySlot, isNumeric, toFloat} from '../../utils'\nimport type {BAvatarGroupParentData} from '../../types/components'\nimport {computed, inject, type StyleValue, toRef, useSlots} from 'vue'\nimport type {Booleanish, ButtonType, ColorVariant, TextColorVariant} from '../../types'\nimport {injectionKey} from './BAvatarGroup.vue'\nimport {useBooleanish} from '../../composables'\n\ninterface BAvatarProps {\n  alt?: string\n  ariaLabel?: string\n  badge?: boolean | string\n  badgeLeft?: Booleanish\n  badgeOffset?: string\n  badgeTop?: Booleanish\n  badgeVariant?: ColorVariant\n  button?: Booleanish\n  buttonType?: ButtonType\n  disabled?: Booleanish\n  icon?: string\n  rounded?: boolean | string\n  size?: 'sm' | 'md' | 'lg' | string // InputSize | string\n  square?: Booleanish\n  src?: string\n  text?: string\n  textVariant?: TextColorVariant\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BAvatarProps>(), {\n  alt: 'avatar',\n  badge: false,\n  badgeLeft: false,\n  badgeTop: false,\n  badgeVariant: 'primary',\n  button: false,\n  buttonType: 'button',\n  disabled: false,\n  rounded: 'circle',\n  square: false,\n  variant: 'secondary',\n})\n\ninterface BAvatarEmits {\n  (e: 'click', value: MouseEvent): void\n  (e: 'img-error', value: Event): void\n}\n\nconst emit = defineEmits<BAvatarEmits>()\n\nconst slots = useSlots()\n\nconst parentData = inject<BAvatarGroupParentData | null>(injectionKey, null)\n\nconst SIZES = ['sm', null, 'lg']\nconst FONT_SIZE_SCALE = 0.4\nconst BADGE_FONT_SIZE_SCALE = FONT_SIZE_SCALE * 0.7\n\nconst badgeLeftBoolean = useBooleanish(toRef(props, 'badgeLeft'))\nconst badgeTopBoolean = useBooleanish(toRef(props, 'badgeTop'))\nconst buttonBoolean = useBooleanish(toRef(props, 'button'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst squareBoolean = useBooleanish(toRef(props, 'square'))\n\nconst hasDefaultSlot = computed<boolean>(() => !isEmptySlot(slots.default))\n\nconst hasBadgeSlot = computed<boolean>(() => !isEmptySlot(slots.badge))\n\nconst showBadge = computed<boolean>(() => !!props.badge || props.badge === '' || hasBadgeSlot.value)\n\nconst computedSize = computed<string | null>(() =>\n  parentData?.size ? parentData.size : computeSize(props.size)\n)\n\nconst computedVariant = computed<ColorVariant>(() =>\n  parentData?.variant ? parentData.variant : props.variant\n)\n\nconst computedRounded = computed<string | boolean>(() =>\n  parentData?.rounded ? parentData.rounded : props.rounded\n)\n\nconst computedAttrs = computed(() => ({\n  'type': buttonBoolean.value ? props.buttonType : undefined,\n  'aria-label': props.ariaLabel || null,\n  'disabled': disabledBoolean.value || null,\n}))\n\nconst badgeClasses = computed(() => [`bg-${props.badgeVariant}`])\n\nconst badgeText = computed<string | false>(() => (props.badge === true ? '' : props.badge))\n\nconst badgeTextClasses = computed(() => [[`text-${computeContrastVariant(props.badgeVariant)}`]])\n\nconst computedClasses = computed(() => ({\n  [`b-avatar-${props.size}`]: !!props.size && SIZES.indexOf(computeSize(props.size)) !== -1,\n  [`bg-${computedVariant.value}`]: !!computedVariant.value,\n  [`badge`]: !buttonBoolean.value && computedVariant.value && hasDefaultSlot.value,\n  rounded: computedRounded.value === '' || computedRounded.value === true,\n  [`rounded-circle`]: !squareBoolean.value && computedRounded.value === 'circle',\n  [`rounded-0`]: squareBoolean.value || computedRounded.value === '0',\n  [`rounded-1`]: !squareBoolean.value && computedRounded.value === 'sm',\n  [`rounded-3`]: !squareBoolean.value && computedRounded.value === 'lg',\n  [`rounded-top`]: !squareBoolean.value && computedRounded.value === 'top',\n  [`rounded-bottom`]: !squareBoolean.value && computedRounded.value === 'bottom',\n  [`rounded-start`]: !squareBoolean.value && computedRounded.value === 'left',\n  [`rounded-end`]: !squareBoolean.value && computedRounded.value === 'right',\n  btn: buttonBoolean.value,\n  [`btn-${computedVariant.value}`]: buttonBoolean.value ? !!computedVariant.value : false,\n}))\n\nconst textClasses = computed(() => [\n  [`text-${props.textVariant || computeContrastVariant(computedVariant.value)}`],\n])\n\nconst badgeStyle = computed<StyleValue>(() => {\n  const offset = props.badgeOffset || '0px'\n  const fontSize =\n    SIZES.indexOf(computedSize.value || null) === -1\n      ? `calc(${computedSize.value} * ${BADGE_FONT_SIZE_SCALE})`\n      : ''\n  return {\n    fontSize: fontSize || '',\n    top: badgeTopBoolean.value ? offset : '',\n    bottom: badgeTopBoolean.value ? '' : offset,\n    left: badgeLeftBoolean.value ? offset : '',\n    right: badgeLeftBoolean.value ? '' : offset,\n  }\n})\n\nconst textFontStyle = computed<StyleValue>(() => {\n  const fontSize =\n    SIZES.indexOf(computedSize.value || null) === -1\n      ? `calc(${computedSize.value} * ${FONT_SIZE_SCALE})`\n      : null\n  return fontSize ? {fontSize} : {}\n})\n\nconst marginStyle = computed(() => {\n  const overlapScale = parentData?.overlapScale?.value || 0\n\n  const value =\n    computedSize.value && overlapScale ? `calc(${computedSize.value} * -${overlapScale})` : null\n  return value ? {marginLeft: value, marginRight: value} : {}\n})\n\nconst computedTag = computed<'button' | 'span'>(() => (buttonBoolean.value ? 'button' : 'span'))\n\nconst computedStyle = computed(() => ({\n  ...marginStyle.value,\n  width: computedSize.value,\n  height: computedSize.value,\n}))\n\nconst computeContrastVariant = (colorVariant: ColorVariant): 'dark' | 'light' =>\n  colorVariant === 'light' || colorVariant === 'warning' ? 'dark' : 'light'\n\nconst clicked = (e: MouseEvent): void => {\n  if (!disabledBoolean.value && buttonBoolean.value) emit('click', e)\n}\n\nconst onImgError = (e: Event): void => emit('img-error', e)\n</script>\n\n<script lang=\"ts\">\nexport const computeSize = (value: any): string | null => {\n  const calcValue = typeof value === 'string' && isNumeric(value) ? toFloat(value, 0) : value\n  return typeof calcValue === 'number' ? `${calcValue}px` : calcValue || null\n}\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"badge\" :class=\"computedClasses\" v-bind=\"computedLinkProps\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {isLink, omit, pluckProps} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {computed, defineComponent, type PropType, toRef} from 'vue'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\n\nconst linkProps = omit(BLINK_PROPS, ['event', 'routerTag'] as const)\n\nexport default defineComponent({\n  components: {BLink},\n  props: {\n    pill: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    tag: {type: String, default: 'span'},\n    variant: {type: String as PropType<ColorVariant>, default: 'secondary'},\n    textIndicator: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    dotIndicator: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    ...linkProps,\n  },\n  setup(props) {\n    const pillBoolean = useBooleanish(toRef(props, 'pill'))\n    const textIndicatorBoolean = useBooleanish(toRef(props, 'textIndicator'))\n    const dotIndicatorBoolean = useBooleanish(toRef(props, 'dotIndicator'))\n    const activeBoolean = useBooleanish(toRef(props, 'active'))\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\n    const computedLink = computed<boolean>(() => isLink(props))\n\n    const computedTag = computed<string | typeof BLink>(() =>\n      computedLink.value ? BLink : props.tag\n    )\n\n    const computedClasses = computed(() => [\n      [`bg-${props.variant}`],\n      {\n        'active': activeBoolean.value,\n        'disabled': disabledBoolean.value,\n        'text-dark': ['warning', 'info', 'light'].includes(props.variant),\n        'rounded-pill': pillBoolean.value,\n        'position-absolute top-0 start-100 translate-middle':\n          textIndicatorBoolean.value || dotIndicatorBoolean.value,\n        'p-2 border border-light rounded-circle': dotIndicatorBoolean.value,\n        'text-decoration-none': computedLink.value,\n      },\n    ])\n\n    const computedLinkProps = computed(() =>\n      computedLink.value ? pluckProps(props, linkProps) : {}\n    )\n\n    return {\n      computedClasses,\n      computedLinkProps,\n      computedTag,\n    }\n  },\n})\n</script>\n","<template>\n  <li class=\"breadcrumb-item\" :class=\"computedClasses\">\n    <component\n      :is=\"computedTag\"\n      :aria-current=\"computedAriaCurrent\"\n      v-bind=\"computedLinkProps\"\n      @click=\"clicked\"\n    >\n      <slot>\n        {{ text }}\n      </slot>\n    </component>\n  </li>\n</template>\n\n<script lang=\"ts\">\nimport {omit, pluckProps} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {computed, defineComponent, type PropType, toRef} from 'vue'\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\nimport type {Booleanish} from '../../types'\n\nconst linkProps = omit(BLINK_PROPS, ['event', 'routerTag'] as const)\n\nexport default defineComponent({\n  components: {BLink},\n  props: {\n    ...linkProps,\n    active: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    ariaCurrent: {type: String, default: 'location'},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    text: {type: String, required: false},\n  },\n  emits: ['click'],\n  setup(props, {emit}) {\n    const activeBoolean = useBooleanish(toRef(props, 'active'))\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\n    const computedClasses = computed(() => ({\n      active: activeBoolean.value,\n    }))\n\n    const computedTag = computed<'span' | typeof BLink>(() =>\n      activeBoolean.value ? 'span' : BLink\n    )\n\n    const computedAriaCurrent = computed(() =>\n      activeBoolean.value ? props.ariaCurrent : undefined\n    )\n\n    const computedLinkProps = computed(() =>\n      computedTag.value !== 'span' ? pluckProps(props, linkProps) : {}\n    )\n\n    const clicked = (e: MouseEvent): void => {\n      if (disabledBoolean.value || activeBoolean.value) {\n        e.preventDefault()\n        e.stopImmediatePropagation()\n        return\n      }\n      if (!disabledBoolean.value) emit('click', e)\n    }\n\n    return {\n      computedLinkProps,\n      computedClasses,\n      computedTag,\n      computedAriaCurrent,\n      clicked,\n    }\n  },\n})\n</script>\n","<template>\n  <nav aria-label=\"breadcrumb\">\n    <ol class=\"breadcrumb\">\n      <slot name=\"prepend\" />\n      <b-breadcrumb-item v-for=\"(item, i) in breadcrumbItemObjects\" :key=\"i\" v-bind=\"item\">\n        {{ item.text }}\n      </b-breadcrumb-item>\n      <slot />\n      <slot name=\"append\" />\n    </ol>\n  </nav>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport {useBreadcrumb} from '../../composables'\nimport type {BreadcrumbItem, BreadcrumbItemObject} from '../../types'\nimport BBreadcrumbItem from './BBreadcrumbItem.vue'\n// import type {BBreadcrumbProps} from '../types/components'\n\ninterface BBreadcrumbProps {\n  items?: Array<BreadcrumbItem>\n}\n\nconst props = defineProps<BBreadcrumbProps>()\n\nconst breadcrumb = useBreadcrumb()\n\nconst breadcrumbItemObjects = computed<Array<BreadcrumbItemObject>>(() => {\n  const localItems = props.items || breadcrumb?.items || []\n  let activeDefined = false\n  const items = localItems.map((item, idx) => {\n    if (typeof item === 'string') {\n      item = {text: item}\n      if (idx < localItems.length - 1) item.href = '#'\n    }\n    if (item.active) activeDefined = true\n\n    // Auto-detect active by position in list\n    if (!item.active && !activeDefined) {\n      item.active = idx + 1 === localItems.length\n    }\n    return item\n  })\n  return items\n})\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\" role=\"group\" :aria-label=\"ariaLabel\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BButtonGroupProps} from '../../types/components'\nimport type {Booleanish} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ninterface BButtonGroupProps {\n  ariaLabel?: string\n  size?: 'sm' | 'lg' // Exclude<InputSize, 'md'>\n  tag?: string\n  vertical?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BButtonGroupProps>(), {\n  ariaLabel: 'Group',\n  tag: 'div',\n  vertical: false,\n})\n\nconst verticalBoolean = useBooleanish(toRef(props, 'vertical'))\n\nconst computedClasses = computed(() => ({\n  'btn-group': !verticalBoolean.value,\n  [`btn-group-${props.size}`]: props.size !== undefined,\n  'btn-group-vertical': verticalBoolean.value,\n}))\n</script>\n","<template>\n  <div :class=\"computedClasses\" class=\"btn-toolbar\" :role=\"role\" :aria-label=\"ariaLabel\">\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BButtonToolbarProps} from '../../types/components'\nimport type {Booleanish} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ninterface BButtonToolbarProps {\n  ariaLabel?: string\n  justify?: Booleanish\n  role?: string\n  // keyNav?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BButtonToolbarProps>(), {\n  role: 'toolbar',\n  ariaLabel: 'Group',\n  justify: false,\n})\n\nconst justifyBoolean = useBooleanish(toRef(props, 'justify'))\n\nconst computedClasses = computed(() => ({\n  'justify-content-between': justifyBoolean.value,\n}))\n</script>\n","<template>\n  <img :class=\"computedClasses\" v-bind=\"computedAttrs\" @load=\"emit('load', $event)\" />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BImgProps} from '../types/components'\nimport type {Booleanish} from '../types'\nimport {useBooleanish} from '../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BImgProps {\n  alt?: string\n  blank?: Booleanish\n  blankColor?: string\n  block?: Booleanish\n  center?: Booleanish\n  fluid?: Booleanish\n  lazy?: Booleanish\n  fluidGrow?: Booleanish\n  height?: number | string\n  left?: Booleanish\n  start?: Booleanish\n  right?: Booleanish\n  end?: Booleanish\n  rounded?: boolean | string\n  sizes?: string | Array<string>\n  src?: string\n  srcset?: string | Array<string>\n  thumbnail?: Booleanish\n  width?: number | string\n}\n\nconst props = withDefaults(defineProps<BImgProps>(), {\n  blank: false,\n  lazy: false,\n  blankColor: 'transparent',\n  block: false,\n  center: false,\n  fluid: false,\n  fluidGrow: false,\n  left: false,\n  right: false,\n  end: false,\n  start: false,\n  rounded: false,\n  thumbnail: false,\n})\n\ninterface Emits {\n  (e: 'load', value: Event): void\n}\n\nconst emit = defineEmits<Emits>()\n\nconst BLANK_TEMPLATE =\n  '<svg width=\"%{w}\" height=\"%{h}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 %{w} %{h}\" preserveAspectRatio=\"none\">' +\n  '<rect width=\"100%\" height=\"100%\" style=\"fill:%{f};\"></rect>' +\n  '</svg>'\n\nconst lazyBoolean = useBooleanish(toRef(props, 'lazy'))\nconst blankBoolean = useBooleanish(toRef(props, 'blank'))\nconst blockBoolean = useBooleanish(toRef(props, 'block'))\nconst centerBoolean = useBooleanish(toRef(props, 'center'))\nconst fluidBoolean = useBooleanish(toRef(props, 'fluid'))\nconst fluidGrowBoolean = useBooleanish(toRef(props, 'fluidGrow'))\nconst leftBoolean = useBooleanish(toRef(props, 'left'))\nconst startBoolean = useBooleanish(toRef(props, 'start'))\nconst rightBoolean = useBooleanish(toRef(props, 'right'))\nconst endBoolean = useBooleanish(toRef(props, 'end'))\nconst thumbnailBoolean = useBooleanish(toRef(props, 'thumbnail'))\n\nconst computedSrcset = computed<string | undefined>(() =>\n  typeof props.srcset === 'string'\n    ? props.srcset\n        .split(',')\n        .filter((x) => x)\n        .join(',')\n    : Array.isArray(props.srcset)\n    ? props.srcset.filter((x) => x).join(',')\n    : undefined\n)\n\nconst computedSizes = computed<string | undefined>(() =>\n  typeof props.sizes === 'string'\n    ? props.sizes\n        .split(',')\n        .filter((x) => x)\n        .join(',')\n    : Array.isArray(props.sizes)\n    ? props.sizes.filter((x) => x).join(',')\n    : undefined\n)\n\nconst computedDimentions = computed<{height: number | undefined; width: number | undefined}>(() => {\n  const parser = (str: string | number | undefined): number | undefined =>\n    str === undefined\n      ? undefined\n      : typeof str === 'number'\n      ? str\n      : Number.parseInt(str, 10) || undefined\n  const width = parser(props.width)\n  const height = parser(props.height)\n  if (blankBoolean.value) {\n    if (width !== undefined && height === undefined) {\n      return {height: width, width}\n    }\n    if (width === undefined && height !== undefined) {\n      return {height, width: height}\n    }\n    if (width === undefined && height === undefined) {\n      return {height: 1, width: 1}\n    }\n  }\n  return {\n    width,\n    height,\n  }\n})\n\nconst computedBlankImgSrc = computed(() =>\n  makeBlankImgSrc(computedDimentions.value.width, computedDimentions.value.height, props.blankColor)\n)\n\nconst computedAttrs = computed(() => ({\n  src: !blankBoolean.value ? props.src : computedBlankImgSrc.value,\n  alt: props.alt,\n  width: computedDimentions.value.width || undefined,\n  height: computedDimentions.value.height || undefined,\n  srcset: !blankBoolean.value ? computedSrcset.value : undefined,\n  sizes: !blankBoolean.value ? computedSizes.value : undefined,\n  loading: lazyBoolean.value ? 'lazy' : 'eager',\n}))\n\nconst alignment = computed<'float-start' | 'float-end' | 'mx-auto' | undefined>(() =>\n  leftBoolean.value || startBoolean.value\n    ? 'float-start'\n    : rightBoolean.value || endBoolean.value\n    ? 'float-end'\n    : centerBoolean.value\n    ? 'mx-auto'\n    : undefined\n)\n\nconst computedClasses = computed(() => ({\n  'img-thumbnail': thumbnailBoolean.value,\n  'img-fluid': fluidBoolean.value || fluidGrowBoolean.value,\n  'w-100': fluidGrowBoolean.value,\n  'rounded': props.rounded === '' || props.rounded === true,\n  [`rounded-${props.rounded}`]: typeof props.rounded === 'string' && props.rounded !== '',\n  [`${alignment.value}`]: alignment.value !== undefined,\n  'd-block': blockBoolean.value || centerBoolean.value,\n}))\n\nconst makeBlankImgSrc = (\n  width: number | undefined,\n  height: number | undefined,\n  color: string\n): string => {\n  const src = encodeURIComponent(\n    BLANK_TEMPLATE.replace('%{w}', String(width))\n      .replace('%{h}', String(height))\n      .replace('%{f}', color)\n  )\n  return `data:image/svg+xml;charset=UTF-8,${src}`\n}\n</script>\n","<template>\n  <b-img :class=\"baseClass\" v-bind=\"computedAttrs\" @load=\"emit('load', $event)\" />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCardImgProps} from '../../types/components'\nimport BImg from '../BImg.vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BCardImgProps {\n  alt?: string\n  blank?: Booleanish\n  blankColor?: string\n  bottom?: Booleanish\n  lazy?: Booleanish\n  height?: number | string\n  left?: Booleanish\n  start?: Booleanish\n  right?: Booleanish\n  end?: Booleanish\n  sizes?: string | Array<string>\n  src?: string\n  srcset?: string | Array<string>\n  top?: Booleanish\n  width?: number | string\n}\n\nconst props = withDefaults(defineProps<BCardImgProps>(), {\n  bottom: false,\n  end: false,\n  left: false,\n  right: false,\n  lazy: false,\n  start: false,\n  top: false,\n  blank: false,\n})\n\ninterface Emits {\n  (e: 'load', value: Event): void\n}\n\nconst emit = defineEmits<Emits>()\n\nconst bottomBoolean = useBooleanish(toRef(props, 'bottom'))\nconst endBoolean = useBooleanish(toRef(props, 'end'))\nconst leftBoolean = useBooleanish(toRef(props, 'left'))\nconst rightBoolean = useBooleanish(toRef(props, 'right'))\nconst startBoolean = useBooleanish(toRef(props, 'start'))\nconst topBoolean = useBooleanish(toRef(props, 'top'))\n\nconst baseClass = computed(() =>\n  topBoolean.value\n    ? 'card-img-top'\n    : rightBoolean.value || endBoolean.value\n    ? 'card-img-right'\n    : bottomBoolean.value\n    ? 'card-img-bottom'\n    : leftBoolean.value || startBoolean.value\n    ? 'card-img-left'\n    : 'card-img'\n)\n\n/**\n * Does not include the above baseClass used props so it does not cause potential issues\n */\nconst computedAttrs = computed(() => ({\n  alt: props.alt,\n  height: props.height,\n  src: props.src,\n  lazy: props.lazy,\n  width: props.width,\n  blank: props.blank,\n  blankColor: props.blankColor,\n  sizes: props.sizes,\n  srcset: props.srcset,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <!-- eslint-disable-next-line vue/no-v-html -->\n    <div v-if=\"!!html\" v-html=\"html\" />\n    <slot v-else>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// Internal component that decomposes the internals of BCardHeader & BCardFooter\n// (they do the same thing, with the only difference of one static class)\n\n// import type {BCardHeaderProps} from '../../types/components'\nimport {computed} from 'vue'\nimport type {ColorVariant, TextColorVariant} from '../../types'\n\ninterface BCardHeaderProps {\n  text?: string\n  bgVariant?: ColorVariant\n  borderVariant?: ColorVariant\n  html?: string\n  tag?: string\n  textVariant?: TextColorVariant\n}\n\nconst props = withDefaults(defineProps<BCardHeaderProps>(), {\n  tag: 'div',\n})\n\nconst computedClasses = computed(() => ({\n  [`text-${props.textVariant}`]: props.textVariant !== undefined,\n  [`bg-${props.bgVariant}`]: props.bgVariant !== undefined,\n  [`border-${props.borderVariant}`]: props.borderVariant !== undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card-subtitle mb-2\" :class=\"coomputedClasses\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCardSubtitleProps} from '../../types/components'\nimport type {TextColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BCardSubtitleProps {\n  text?: string\n  tag?: string\n  textVariant?: TextColorVariant\n}\n\nconst props = withDefaults(defineProps<BCardSubtitleProps>(), {\n  tag: 'h6',\n  textVariant: 'muted',\n})\n\nconst coomputedClasses = computed(() => [`text-${props.textVariant}`])\n</script>\n","<template>\n  <component :is=\"bodyTag\" class=\"card-body\" :class=\"computedClasses\">\n    <b-card-title v-if=\"!!title || hasTitleSlot\" :tag=\"titleTag\">\n      <slot name=\"title\">\n        {{ title }}\n      </slot>\n    </b-card-title>\n\n    <b-card-subtitle\n      v-if=\"!!subtitle || hasSubtitleSlot\"\n      :tag=\"subtitleTag\"\n      :text-variant=\"subtitleTextVariant\"\n    >\n      <slot name=\"subtitle\">\n        {{ subtitle }}\n      </slot>\n    </b-card-subtitle>\n\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCardBodyProps} from '../../types/components'\nimport {computed, toRef, useSlots} from 'vue'\nimport BCardTitle from './BCardTitle.vue'\nimport BCardSubtitle from './BCardSubtitle.vue'\nimport type {Booleanish, ColorVariant, TextColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {isEmptySlot} from '../../utils'\n\ninterface BCardBodyProps {\n  bodyBgVariant?: ColorVariant\n  bodyTag?: string\n  bodyTextVariant?: TextColorVariant\n  overlay?: Booleanish\n  subtitle?: string\n  subtitleTag?: string\n  subtitleTextVariant?: TextColorVariant\n  title?: string\n  titleTag?: string\n  text?: string\n}\n\nconst props = withDefaults(defineProps<BCardBodyProps>(), {\n  bodyTag: 'div',\n  overlay: false,\n  titleTag: 'h4',\n  subtitleTag: 'h4',\n})\n\nconst slots = useSlots()\n\nconst overlayBoolean = useBooleanish(toRef(props, 'overlay'))\n\nconst hasTitleSlot = computed<boolean>(() => !isEmptySlot(slots.title))\nconst hasSubtitleSlot = computed<boolean>(() => !isEmptySlot(slots.subtitle))\n\nconst computedClasses = computed(() => ({\n  'card-img-overlay': overlayBoolean.value,\n  [`text-${props.bodyTextVariant}`]: props.bodyTextVariant !== undefined,\n  [`bg-${props.bodyBgVariant}`]: props.bodyBgVariant !== undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card\" :class=\"computedClasses\">\n    <slot v-if=\"!imgBottomBoolean\" name=\"img\">\n      <b-card-img v-if=\"imgSrc\" v-bind=\"imgAttr\" />\n    </slot>\n    <b-card-header\n      v-if=\"header || hasHeaderSlot || headerHtml\"\n      v-bind=\"headerAttrs\"\n      :class=\"headerClass\"\n    >\n      <slot name=\"header\">\n        {{ header }}\n      </slot>\n    </b-card-header>\n    <b-card-body v-if=\"!noBodyBoolean\" v-bind=\"bodyAttrs\" :class=\"bodyClass\">\n      <slot>\n        {{ bodyText }}\n      </slot>\n    </b-card-body>\n    <slot v-else>\n      {{ bodyText }}\n    </slot>\n    <b-card-footer\n      v-if=\"footer || hasFooterSlot || footerHtml\"\n      v-bind=\"footerAttrs\"\n      :class=\"footerClass\"\n    >\n      <slot name=\"footer\">\n        {{ footer }}\n      </slot>\n    </b-card-footer>\n    <slot v-if=\"imgBottomBoolean\" name=\"img\">\n      <b-card-img v-if=\"imgSrc\" v-bind=\"imgAttr\" />\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCardProps} from '../../types/components'\nimport type {Alignment, Booleanish, ClassValue, ColorVariant, TextColorVariant} from '../../types'\nimport {computed, toRef, useSlots} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport BCardImg from './BCardImg.vue'\nimport BCardHeader from './BCardHeader.vue'\nimport BCardBody from './BCardBody.vue'\nimport BCardFooter from './BCardFooter.vue'\nimport {isEmptySlot} from '../../utils'\n\ninterface BCardProps {\n  align?: Alignment.TextHorizontal\n  bgVariant?: ColorVariant\n  bodyBgVariant?: ColorVariant\n  bodyClass?: ClassValue\n  bodyTag?: string\n  bodyTextVariant?: TextColorVariant\n  borderVariant?: ColorVariant\n  footer?: string\n  footerBgVariant?: ColorVariant\n  footerBorderVariant?: ColorVariant\n  footerClass?: ClassValue\n  footerHtml?: string\n  footerTag?: string\n  footerTextVariant?: TextColorVariant\n  header?: string\n  headerBgVariant?: ColorVariant\n  headerBorderVariant?: ColorVariant\n  headerClass?: ClassValue\n  headerHtml?: string\n  headerTag?: string\n  headerTextVariant?: TextColorVariant\n  imgAlt?: string\n  imgBottom?: Booleanish\n  imgEnd?: Booleanish\n  imgHeight?: string | number\n  imgLeft?: Booleanish\n  imgRight?: Booleanish\n  imgSrc?: string\n  imgStart?: Booleanish\n  imgTop?: Booleanish\n  imgWidth?: string | number\n  noBody?: Booleanish\n  overlay?: Booleanish\n  subtitle?: string\n  subtitleTag?: string\n  subtitleTextVariant?: TextColorVariant\n  tag?: string\n  textVariant?: TextColorVariant\n  title?: string\n  titleTag?: string\n  bodyText?: string\n}\n\nconst props = withDefaults(defineProps<BCardProps>(), {\n  bodyTag: 'div',\n  footerHtml: '',\n  footerTag: 'div',\n  headerHtml: '',\n  headerTag: 'div',\n  imgBottom: false,\n  imgEnd: false,\n  imgLeft: false,\n  imgRight: false,\n  imgStart: false,\n  bodyText: '',\n  imgTop: false,\n  noBody: false,\n  overlay: false,\n  subtitleTag: 'h6',\n  subtitleTextVariant: 'muted',\n  tag: 'div',\n  titleTag: 'h4',\n})\n\nconst slots = useSlots()\n\nconst imgBottomBoolean = useBooleanish(toRef(props, 'imgBottom'))\nconst imgEndBoolean = useBooleanish(toRef(props, 'imgEnd'))\nconst imgLeftBoolean = useBooleanish(toRef(props, 'imgLeft'))\nconst imgRightBoolean = useBooleanish(toRef(props, 'imgRight'))\nconst imgStartBoolean = useBooleanish(toRef(props, 'imgStart'))\nconst noBodyBoolean = useBooleanish(toRef(props, 'noBody'))\n\nconst hasHeaderSlot = computed<boolean>(() => !isEmptySlot(slots.header))\nconst hasFooterSlot = computed<boolean>(() => !isEmptySlot(slots.footer))\n\nconst computedClasses = computed(() => ({\n  [`text-${props.align}`]: props.align !== undefined,\n  [`text-${props.textVariant}`]: props.textVariant !== undefined,\n  [`bg-${props.bgVariant}`]: props.bgVariant !== undefined,\n  [`border-${props.borderVariant}`]: props.borderVariant !== undefined,\n  'flex-row': imgLeftBoolean.value || imgStartBoolean.value,\n  'flex-row-reverse': imgEndBoolean.value || imgRightBoolean.value,\n}))\n\nconst headerAttrs = computed(() => ({\n  bgVariant: props.headerBgVariant,\n  borderVariant: props.headerBorderVariant,\n  html: props.headerHtml,\n  tag: props.headerTag,\n  textVariant: props.headerTextVariant,\n}))\n\nconst bodyAttrs = computed(() => ({\n  overlay: props.overlay,\n  bodyBgVariant: props.bodyBgVariant,\n  bodyTag: props.bodyTag,\n  bodyTextVariant: props.bodyTextVariant,\n  subtitle: props.subtitle,\n  subtitleTag: props.subtitleTag,\n  subtitleTextVariant: props.subtitleTextVariant,\n  title: props.title,\n  titleTag: props.titleTag,\n}))\n\nconst footerAttrs = computed(() => ({\n  bgVariant: props.footerBgVariant,\n  borderVariant: props.footerBorderVariant,\n  html: props.footerHtml,\n  tag: props.footerTag,\n  textVariant: props.footerTextVariant,\n}))\n\nconst imgAttr = computed(() => ({\n  src: props.imgSrc,\n  alt: props.imgAlt,\n  height: props.imgHeight,\n  width: props.imgWidth,\n  bottom: props.imgBottom,\n  end: props.imgEnd,\n  left: props.imgLeft,\n  right: props.imgRight,\n  start: props.imgStart,\n  top: props.imgTop,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCardGroupProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BCardGroupProps {\n  columns?: Booleanish\n  deck?: Booleanish\n  tag?: string\n}\n\nconst props = withDefaults(defineProps<BCardGroupProps>(), {\n  columns: false,\n  deck: false,\n  tag: 'div',\n})\n\nconst columnsBoolean = useBooleanish(toRef(props, 'columns'))\nconst deckBoolean = useBooleanish(toRef(props, 'deck'))\n\nconst cardTypeClass = computed(() =>\n  deckBoolean.value ? 'card-deck' : columnsBoolean.value ? 'card-columns' : 'card-group'\n)\n\nconst computedClasses = computed(() => [cardTypeClass.value])\n</script>\n","<template>\n  <div :id=\"computedId\" ref=\"element\" class=\"carousel slide\" data-bs-ride=\"carousel\">\n    <template v-if=\"indicatorsBoolean\">\n      <div class=\"carousel-indicators\">\n        <button\n          v-for=\"(_, i) of slides\"\n          :key=\"i\"\n          type=\"button\"\n          :data-bs-target=\"`#${computedId}`\"\n          :data-bs-slide-to=\"i\"\n          :class=\"i === startingSlide ? 'active' : ''\"\n          aria-current=\"true\"\n          :aria-label=\"`${indicatorsButtonLabel} ${i}`\"\n        />\n      </div>\n    </template>\n\n    <div class=\"carousel-inner\">\n      <slot />\n    </div>\n\n    <template v-if=\"controlsBoolean\">\n      <button\n        class=\"carousel-control-prev\"\n        type=\"button\"\n        :data-bs-target=\"`#${computedId}`\"\n        data-bs-slide=\"prev\"\n      >\n        <span class=\"carousel-control-prev-icon\" aria-hidden=\"true\" />\n        <span class=\"visually-hidden\">{{ controlsPrevText }}</span>\n      </button>\n      <button\n        class=\"carousel-control-next\"\n        type=\"button\"\n        :data-bs-target=\"`#${computedId}`\"\n        data-bs-slide=\"next\"\n      >\n        <span class=\"carousel-control-next-icon\" aria-hidden=\"true\" />\n        <span class=\"visually-hidden\">{{ controlsNextText }}</span>\n      </button>\n    </template>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCarouselProps, BCarouselEmits} from '../types/components'\nimport type {BCarouselParentData} from '../../types/components'\nimport {type InjectionKey, onMounted, provide, ref, toRef, useSlots, type VNode} from 'vue'\nimport {Carousel} from 'bootstrap'\nimport {useBooleanish, useEventListener, useId} from '../../composables'\nimport type {Booleanish} from '../../types'\n\ninterface BCarouselProps {\n  startingSlide?: number\n  id?: string\n  imgHeight?: string\n  imgWidth?: string\n  background?: string\n  modelValue?: number\n  controls?: Booleanish\n  indicators?: Booleanish\n  interval?: number\n  noTouch?: Booleanish\n  noWrap?: Booleanish\n  controlsPrevText?: string\n  controlsNextText?: string\n  indicatorsButtonLabel?: string\n}\n\nconst props = withDefaults(defineProps<BCarouselProps>(), {\n  startingSlide: 0,\n  modelValue: 0,\n  controls: false,\n  indicators: false,\n  interval: 5000,\n  noTouch: false,\n  noWrap: false,\n  controlsNextText: 'Next',\n  controlsPrevText: 'Previous',\n  indicatorsButtonLabel: 'Slide',\n})\n\ninterface BCarouselEmits {\n  (e: 'sliding-start', value: Event): void\n  (e: 'sliding-end', value: Event): void\n}\n\nconst emit = defineEmits<BCarouselEmits>()\n\nconst slots = useSlots()\n\nconst computedId = useId(toRef(props, 'id'), 'carousel')\n\nconst controlsBoolean = useBooleanish(toRef(props, 'controls'))\nconst indicatorsBoolean = useBooleanish(toRef(props, 'indicators'))\nconst noTouchBoolean = useBooleanish(toRef(props, 'noTouch'))\n// TODO no wrap is never used\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst noWrapBoolean = useBooleanish(toRef(props, 'noWrap'))\n\nconst element = ref<HTMLElement>()\nconst instance = ref<Carousel>()\nconst slides = ref<VNode[]>([])\n\nuseEventListener(element, 'slide.bs.carousel', (payload) => emit('sliding-start', payload))\nuseEventListener(element, 'slid.bs.carousel', (payload) => emit('sliding-end', payload))\n\nonMounted(() => {\n  instance.value = new Carousel(element.value as HTMLElement, {\n    wrap: !noTouchBoolean.value,\n    interval: props.interval,\n    touch: !noTouchBoolean.value,\n  })\n\n  if (slots.default) {\n    slides.value = slots.default().filter((child: any) => child.type?.__name === 'BCarouselSlide')\n  }\n})\n\nprovide(injectionKey, {\n  background: props.background,\n  width: props.imgWidth,\n  height: props.imgHeight,\n})\n</script>\n\n<script lang=\"ts\">\nexport const injectionKey: InjectionKey<BCarouselParentData> = Symbol()\n</script>\n","<template>\n  <div\n    class=\"carousel-item\"\n    :class=\"{active: activeBoolean}\"\n    :data-bs-interval=\"interval\"\n    :style=\"computedAttr\"\n  >\n    <slot name=\"img\">\n      <b-img\n        class=\"d-block w-100\"\n        :alt=\"imgAlt\"\n        :src=\"imgSrc\"\n        :width=\"imgWidth || parentWidth\"\n        :height=\"imgHeight || parentHeight\"\n        :blank=\"imgBlank\"\n        :blank-color=\"imgBlankColor\"\n      />\n    </slot>\n    <component\n      :is=\"contentTag\"\n      v-if=\"caption || captionHtml || text || textHtml || hasDefaultSlot\"\n      class=\"carousel-caption\"\n      :class=\"computedContentClasses\"\n    >\n      <component :is=\"captionTag\" v-if=\"caption || captionHtml\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"captionHtml\" v-html=\"captionHtml\" />\n        <span v-else>{{ caption }}</span>\n      </component>\n      <component :is=\"textTag\" v-if=\"text || textHtml\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"textHtml\" v-html=\"textHtml\" />\n        <span v-else>{{ text }}</span>\n      </component>\n      <slot />\n    </component>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCarouselSlideProps} from '../../types/components'\nimport {useBooleanish} from '../../composables'\nimport {computed, inject, toRef, useSlots} from 'vue'\nimport type {Booleanish} from '../../types'\nimport type {BCarouselParentData} from '../../types/components'\nimport {injectionKey} from './BCarousel.vue'\nimport BImg from '../BImg.vue'\nimport {isEmptySlot} from '../../utils'\n\ninterface BCarouselSlideProps {\n  imgSrc?: string\n  imgHeight?: string | number\n  imgWidth?: string | number\n  interval?: string | number\n  active?: Booleanish\n  background?: string\n  caption?: string\n  captionHtml?: string\n  captionTag?: string\n  contentTag?: string\n  contentVisibleUp?: string\n  id?: string\n  imgAlt?: string\n  imgBlank?: Booleanish\n  imgBlankColor?: string\n  text?: string\n  textHtml?: string\n  textTag?: string\n}\n\nconst props = withDefaults(defineProps<BCarouselSlideProps>(), {\n  active: false,\n  captionTag: 'h3',\n  contentTag: 'div',\n  imgBlank: false,\n  imgBlankColor: 'transparent',\n  textTag: 'p',\n})\n\nconst slots = useSlots()\n\nconst parentData = inject<BCarouselParentData>(injectionKey, {})\n\n// instead of using this property, it would be nice to use `startingSlide`\n// of the parent Carousel in order to set the proper active slide\nconst activeBoolean = useBooleanish(toRef(props, 'active'))\n\nconst hasDefaultSlot = computed<boolean>(() => !isEmptySlot(slots.default))\n\nconst computedAttr = computed(() => ({\n  background: `${\n    props.background || parentData.background || 'rgb(171, 171, 171)'\n  } none repeat scroll 0% 0%`,\n}))\n\nconst computedContentClasses = computed(() => ({\n  'd-none': props.contentVisibleUp !== undefined,\n  [`d-${props.contentVisibleUp}-block`]: props.contentVisibleUp !== undefined,\n}))\n\nconst parentWidth = computed<string | undefined>(() => parentData.width)\nconst parentHeight = computed<string | undefined>(() => parentData.height)\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, toRef} from 'vue'\nimport type {Alignment, Booleanish} from '../types'\nimport {getBreakpointProps, getClasses} from '../utils'\nimport {useBooleanish} from '../composables'\n\nconst breakpointCol = getBreakpointProps('', [], {type: [Boolean, String, Number], default: false})\nconst breakpointOffset = getBreakpointProps('offset', [''], {type: [String, Number], default: null})\nconst breakpointOrder = getBreakpointProps('order', [''], {type: [String, Number], default: null})\n\nexport default defineComponent({\n  name: 'BCol',\n  props: {\n    col: {type: [Boolean, String] as PropType<Booleanish>, default: false}, // Generic flexbox .col (xs)\n    cols: {type: [String, Number], default: null}, // .col-[1-12]|auto (xs)\n    ...breakpointCol,\n    offset: {type: [String, Number], default: null},\n    ...breakpointOffset,\n    order: {type: [String, Number], default: null},\n    ...breakpointOrder,\n    alignSelf: {type: String as PropType<Alignment.Vertical | 'auto'>, default: null},\n    tag: {type: String, default: 'div'},\n  },\n  setup(props) {\n    const properties = [\n      {content: breakpointCol, propPrefix: 'cols', classPrefix: 'col'},\n      {content: breakpointOffset, propPrefix: 'offset'},\n      {content: breakpointOrder, propPrefix: 'order'},\n    ]\n\n    const colBoolean = useBooleanish(toRef(props, 'col'))\n\n    const classList = computed(() =>\n      properties.flatMap((el) => getClasses(props, el.content, el.propPrefix, el.classPrefix))\n    )\n\n    const computedClasses = computed(() => [\n      classList.value,\n      {\n        col: colBoolean.value || (!classList.value.some((e) => /^col-/.test(e)) && !props.cols),\n        [`col-${props.cols}`]: !!props.cols,\n        [`offset-${props.offset}`]: !!props.offset,\n        [`order-${props.order}`]: !!props.order,\n        [`align-self-${props.alignSelf}`]: !!props.alignSelf,\n      },\n    ])\n\n    return {\n      computedClasses,\n    }\n  },\n})\n</script>\n","import type {BootstrapVueOptions, ColorVariant, ContainerPosition} from '../../types'\nimport {getId} from '../../utils'\nimport {\n  type App,\n  type ComponentPublicInstance,\n  computed,\n  type ComputedRef,\n  inject,\n  isReactive,\n  type Plugin,\n  reactive,\n  type Ref,\n  type VNode,\n} from 'vue'\n\nexport interface ToastContent {\n  title?: string\n  body?: string | VNode\n}\n\nexport interface ToastOptions {\n  autoHide?: boolean\n  delay?: number\n  id?: string\n  noCloseButton?: boolean\n  pos?: ContainerPosition\n  value?: boolean // show or hide\n  variant?: ColorVariant\n}\n\nexport interface Toast {\n  options: ToastOptions\n  content: ToastContent\n}\n\n/**\n * @external\n */\nexport type BodyProp = ToastContent['body']\n\n// Toast ViewModel, Each toast instance controls one view model\nexport interface ToastVM {\n  container: VMContainer | undefined\n  toasts: Array<Toast>\n  root: boolean\n  id: symbol\n}\n\ntype VMContainer = Ref<ComponentPublicInstance | null>\n\ninterface ToastContainers {\n  [key: symbol]: ToastVM\n}\n\nconst defaultToastOptions: ToastOptions = {\n  autoHide: true,\n  delay: 5000,\n  noCloseButton: false,\n  pos: 'top-right',\n  value: true,\n}\n\nexport class ToastInstance {\n  vm: ToastVM\n  containerPositions: ComputedRef<Set<ContainerPosition>>\n\n  constructor(vm: ToastVM) {\n    if (isReactive(vm)) {\n      this.vm = vm\n    } else {\n      this.vm = reactive(vm) as ToastVM\n    }\n\n    this.containerPositions = computed<Set<ContainerPosition>>(() => {\n      const s = new Set<ContainerPosition>([])\n      this.vm.toasts.map((toast) => {\n        if (toast.options.pos) {\n          s.add(toast.options.pos)\n        }\n      })\n      return s\n    })\n  }\n\n  toasts(position?: ContainerPosition): ComputedRef<Array<Toast>> {\n    if (position) {\n      return computed<Array<Toast>>(() =>\n        this.vm.toasts.filter((toast) => {\n          if (toast.options.pos === position && toast.options.value) {\n            return toast\n          }\n        })\n      )\n    }\n\n    return computed(() => this.vm.toasts)\n  }\n\n  remove(...forDeletion: [string]): void {\n    this.vm.toasts = this.vm.toasts.filter((item) => {\n      if (item.options.id && !forDeletion.includes(item.options.id)) {\n        return item\n      }\n    })\n  }\n\n  isRoot(): boolean {\n    return this.vm.root ?? false\n  }\n\n  show(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    const topts: ToastOptions = {id: getId(), ...defaultToastOptions, ...options}\n\n    const toast: Toast = {\n      options: reactive(topts),\n      content,\n    }\n    this.vm.toasts.push(toast)\n    return toast\n  }\n\n  info(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'info', ...options})\n  }\n\n  danger(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'danger', ...options})\n  }\n\n  warning(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'warning', ...options})\n  }\n\n  success(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'success', ...options})\n  }\n\n  hide(): void {\n    //empty...\n  }\n}\n\nexport class ToastController {\n  vms: ToastContainers\n  rootInstance?: symbol\n\n  constructor() {\n    this.vms = {}\n  }\n\n  // Assume Root Vm if no parameters are passed\n  public getOrCreateViewModel(): ToastVM\n  public getOrCreateViewModel(vm?: ToastVM): ToastVM\n  public getOrCreateViewModel(vm?: any): ToastVM {\n    if (!vm) {\n      if (this.rootInstance) {\n        return this.vms[this.rootInstance]\n      }\n      const vm: ToastVM = {root: true, toasts: [], container: undefined, id: Symbol('toast')}\n      this.rootInstance = vm.id\n      this.vms[vm.id] = vm\n      return vm\n    }\n    if (vm.root) {\n      // lets see if we have a root instance\n      if (this.rootInstance) {\n        return this.vms[this.rootInstance]\n      }\n\n      this.rootInstance = vm.id\n    }\n    this.vms[vm.id] = vm\n    return vm\n  }\n\n  public getVM(): ToastVM | undefined\n  public getVM(id?: symbol): ToastVM | undefined\n  public getVM(id?: any): ToastVM | undefined {\n    if (!id && this.rootInstance) {\n      return this.vms[this.rootInstance]\n    } else if (id) {\n      return this.vms[id]\n    }\n\n    return undefined\n  }\n\n  useToast = useToast\n}\n\n// default global inject key to fetch the controller\nconst injectkey = Symbol()\nconst fetchKey = Symbol()\n\nconst rootkey = 'root' // TODO: I guess this variable is not used in any place...\n\nconst defaults = {\n  container: undefined,\n  toasts: [],\n  root: false,\n}\n\nexport function getKey(): any {\n  return inject(fetchKey)\n}\n\n/**\n * @external\n */\nexport function useToast(): ToastInstance | undefined\nexport function useToast(vm: {id: symbol}, key?: symbol): ToastInstance | undefined\nexport function useToast(\n  vm: {container: Ref<ComponentPublicInstance>; root: boolean},\n  key?: symbol\n): ToastInstance | undefined\n\nexport function useToast(vm?: any, key: symbol = injectkey): ToastInstance | undefined {\n  //let's get our controller to fetch the toast instance\n  const controller = inject(getKey()) as ToastController\n\n  // not parameters passed, use root if defined\n  if (!vm) {\n    return new ToastInstance(controller.getOrCreateViewModel())\n  }\n\n  // use toast generically\n  const vm_id = {id: Symbol('toastInstance')}\n  const local_vm: ToastVM = {...defaults, ...vm_id, ...vm}\n  const vm_instance = controller.getOrCreateViewModel(local_vm)\n  return new ToastInstance(vm_instance)\n}\n\n/**\n * @external\n */\nconst BToastPlugin: Plugin = {\n  install: (app: App, options: BootstrapVueOptions = {}) => {\n    app.provide(fetchKey, options?.BToast?.injectkey ?? injectkey)\n    app.provide(options?.BToast?.injectkey ?? injectkey, new ToastController())\n  },\n}\n\nexport {BToastPlugin}\nexport default BToastPlugin\n","<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  h,\n  nextTick,\n  onMounted,\n  onUnmounted,\n  type PropType,\n  ref,\n  toRef,\n  type VNode,\n  watch,\n} from 'vue'\nimport {isLink, normalizeSlot, requestAF, toInteger} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\nimport {BodyProp} from './plugin'\n\nexport const SLOT_NAME_TOAST_TITLE = 'toast-title'\nconst MIN_DURATION = 1000\n\nexport default defineComponent({\n  components: {BLink},\n  props: {\n    ...BLINK_PROPS,\n    delay: {type: Number, default: 5000},\n    bodyClass: {type: String},\n    body: {type: [Object, String] as PropType<BodyProp>},\n    headerClass: {type: String},\n    headerTag: {type: String, default: 'div'},\n    animation: {type: [Boolean, String] as PropType<Booleanish>, default: true},\n    id: {type: String},\n    // Switches role to 'status' and aria-live to 'polite'\n    isStatus: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    autoHide: {type: [Boolean, String] as PropType<Booleanish>, default: true},\n    noCloseButton: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    noFade: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    noHoverPause: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    solid: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    // Render the toast in place, rather than in a portal-target\n    static: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    title: {type: String},\n    modelValue: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    toastClass: {type: Array as PropType<Array<string>>},\n    variant: {type: String as PropType<ColorVariant>},\n  },\n  emits: ['destroyed', 'update:modelValue'],\n  setup(props, {emit, slots}) {\n    // TODO animation is never used\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const animationBoolean = useBooleanish(toRef(props, 'animation'))\n    const isStatusBoolean = useBooleanish(toRef(props, 'isStatus'))\n    const autoHideBoolean = useBooleanish(toRef(props, 'autoHide'))\n    const noCloseButtonBoolean = useBooleanish(toRef(props, 'noCloseButton'))\n    const noFadeBoolean = useBooleanish(toRef(props, 'noFade'))\n    const noHoverPauseBoolean = useBooleanish(toRef(props, 'noHoverPause'))\n    // TODO solid is never used\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const solidBoolean = useBooleanish(toRef(props, 'solid'))\n    // TODO static is never used\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const staticBoolean = useBooleanish(toRef(props, 'static'))\n    const modelValueBoolean = useBooleanish(toRef(props, 'modelValue'))\n\n    const isTransitioning = ref(false)\n    const isHiding = ref(false)\n    const localShow = ref(false)\n    const classes = computed(() => ({\n      [`b-toast-${props.variant}`]: props.variant !== undefined,\n      show: localShow.value || isTransitioning.value,\n    }))\n\n    let dismissTimer: ReturnType<typeof setTimeout> | undefined\n    let dismissStarted: number\n    let resumeDismiss: number\n\n    const clearDismissTimer = () => {\n      if (typeof dismissTimer === 'undefined') return\n      clearTimeout(dismissTimer)\n      dismissTimer = undefined\n    }\n\n    const computedDuration = computed(() =>\n      // Minimum supported duration is 1 second\n      Math.max(toInteger(props.delay, 0), MIN_DURATION)\n    )\n\n    const hide = () => {\n      if (modelValueBoolean.value) {\n        dismissStarted = resumeDismiss = 0\n        clearDismissTimer()\n        isHiding.value = true\n        requestAF(() => {\n          localShow.value = false\n        })\n      }\n    }\n\n    const show = () => {\n      clearDismissTimer()\n      emit('update:modelValue', true)\n      dismissStarted = resumeDismiss = 0\n      isHiding.value = false\n\n      nextTick(() => {\n        // We show the toast after we have rendered the portal and b-toast wrapper\n        // so that screen readers will properly announce the toast\n        requestAF(() => {\n          localShow.value = true\n        })\n      })\n    }\n\n    const onPause = () => {\n      if (!autoHideBoolean.value || noHoverPauseBoolean.value || !dismissTimer || resumeDismiss) {\n        return\n      }\n\n      const passed = Date.now() - dismissStarted\n\n      if (passed > 0) {\n        clearDismissTimer()\n        resumeDismiss = Math.max(computedDuration.value - passed, MIN_DURATION)\n      }\n    }\n\n    const onUnPause = () => {\n      if (!autoHideBoolean.value || noHoverPauseBoolean.value || !resumeDismiss) {\n        resumeDismiss = dismissStarted = 0\n      }\n\n      startDismissTimer()\n    }\n\n    watch(\n      () => modelValueBoolean.value,\n      (newValue) => {\n        newValue ? show() : hide()\n      }\n    )\n\n    const startDismissTimer = () => {\n      clearDismissTimer()\n      if (autoHideBoolean.value) {\n        dismissTimer = setTimeout(hide, resumeDismiss || computedDuration.value)\n        dismissStarted = Date.now()\n        resumeDismiss = 0\n      }\n    }\n\n    const OnBeforeEnter = () => {\n      isTransitioning.value = true\n      emit('update:modelValue', true)\n    }\n\n    const OnAfterEnter = () => {\n      isTransitioning.value = false\n      startDismissTimer()\n    }\n\n    const OnBeforeLeave = () => {\n      isTransitioning.value = true\n    }\n\n    const OnAfterLeave = () => {\n      isTransitioning.value = false\n      resumeDismiss = dismissStarted = 0\n      emit('update:modelValue', false)\n    }\n\n    onUnmounted(() => {\n      //if there is time left on autoHide or no autoHide then keep toast alive\n      clearDismissTimer()\n      if (!autoHideBoolean.value) {\n        return\n      }\n\n      emit('destroyed', props.id)\n    })\n\n    onMounted(() => {\n      nextTick(() => {\n        if (modelValueBoolean.value) {\n          requestAF(() => {\n            show()\n          })\n        }\n      })\n    })\n\n    const onLinkClick = () => {\n      nextTick(() => {\n        requestAF(() => {\n          hide()\n        })\n      })\n    }\n\n    return () => {\n      const makeToast = () => {\n        const $headerContent: Array<VNode> = []\n\n        const $title = normalizeSlot(SLOT_NAME_TOAST_TITLE, {hide}, slots)\n\n        if ($title) {\n          $headerContent.push(h($title))\n        } else if (props.title) {\n          $headerContent.push(h('strong', {class: 'me-auto'}, props.title))\n        }\n\n        if (!noCloseButtonBoolean.value && $headerContent.length !== 0) {\n          $headerContent.push(\n            h(BCloseButton, {\n              class: ['btn-close'],\n              onClick: () => {\n                hide()\n              },\n            })\n          )\n        }\n        const $innertoast = []\n\n        if ($headerContent.length > 0) {\n          $innertoast.push(\n            h(\n              props.headerTag,\n              {\n                class: 'toast-header',\n              },\n              {default: () => $headerContent}\n            )\n          )\n        }\n        if (normalizeSlot('default', {hide}, slots) || props.body) {\n          const $body = h(\n            isLink(props) ? 'b-link' : 'div',\n            {\n              class: ['toast-body', props.bodyClass],\n              onClick: isLink(props) ? {click: onLinkClick} : {},\n            },\n            normalizeSlot('default', {hide}, slots) || props.body\n          )\n          $innertoast.push($body)\n        }\n        return h(\n          'div',\n          {\n            class: ['toast', props.toastClass, classes.value],\n            tabindex: '0',\n          },\n          $innertoast\n        )\n      }\n      //toast\n      return h(\n        'div',\n        {\n          'class': ['b-toast'],\n          'id': props.id,\n          'role': isHiding.value ? null : isStatusBoolean.value ? 'status' : 'alert',\n          'aria-live': isHiding.value ? null : isStatusBoolean.value ? 'polite' : 'assertive',\n          'aria-atomic': isHiding.value ? null : 'true',\n          'onmouseenter': onPause,\n          'onmouseleave': onUnPause,\n        },\n        [\n          h(\n            BTransition,\n            {\n              noFade: noFadeBoolean.value,\n              onAfterEnter: OnAfterEnter,\n              onBeforeEnter: OnBeforeEnter,\n              onAfterLeave: OnAfterLeave,\n              onBeforeLeave: OnBeforeLeave,\n            },\n            () => [localShow.value ? makeToast() : '']\n          ),\n        ]\n      )\n    }\n  },\n})\n</script>\n","<template>\n  <div :class=\"[positionClass]\" class=\"b-toaster position-fixed p-3\" style=\"z-index: 11\">\n    <b-toast\n      v-for=\"toast in instance?.toasts(position).value\"\n      :id=\"toast.options.id\"\n      :key=\"toast.options.id\"\n      v-model=\"toast.options.value\"\n      :auto-hide=\"toast.options.autoHide\"\n      :delay=\"toast.options.delay\"\n      :no-close-button=\"toast.options.noCloseButton\"\n      :title=\"toast.content.title\"\n      :body=\"toast.content.body\"\n      :component=\"toast.content.body\"\n      :variant=\"toast.options.variant\"\n      @destroyed=\"handleDestroy\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BToasterProps} from '../../types/components'\nimport {computed} from 'vue'\nimport type {ContainerPosition} from '../../types'\nimport type {ToastInstance} from '../BToast/plugin'\nimport BToast from './BToast.vue'\n\ninterface BToasterProps {\n  position?: ContainerPosition\n  instance?: ToastInstance\n  // appendToast?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BToasterProps>(), {\n  position: 'top-right',\n})\n\nconst toastPositions = {\n  'top-left': 'top-0 start-0',\n  'top-center': 'top-0 start-50 translate-middle-x',\n  'top-right': 'top-0 end-0',\n  'middle-left': 'top-50 start-0 translate-middle-y',\n  'middle-center': 'top-50 start-50 translate-middle',\n  'middle-right': 'top-50 end-0 translate-middle-y',\n  'bottom-left': 'bottom-0 start-0',\n  'bottom-center': 'bottom-0 start-50 translate-middle-x',\n  'bottom-right': 'bottom-0 end-0',\n}\n\nconst positionClass = computed(() => toastPositions[props.position])\n\nconst handleDestroy = (id: string) => {\n  //we made want to disable reactivity for deletes. Future Note\n  props.instance?.remove(id)\n}\n</script>\n","<script lang=\"ts\">\nimport type {Breakpoint, Position} from '../types'\nimport {computed, defineComponent, h, onMounted, type PropType, ref, type VNode} from 'vue'\nimport {ToastInstance, useToast} from './BToast/plugin'\nimport BToaster from './BToast/BToaster.vue'\nexport default defineComponent({\n  props: {\n    gutterX: {type: String, default: null},\n    gutterY: {type: String, default: null},\n    fluid: {type: [Boolean, String] as PropType<boolean | Breakpoint>, default: false},\n    toast: {type: Object},\n    position: {type: String as PropType<Position>, required: false},\n  },\n  setup(props, {slots, expose}) {\n    const container = ref()\n    let toastInstance: ToastInstance | undefined\n\n    const classes = computed(() => ({\n      container: !props.fluid,\n      [`container-fluid`]: typeof props.fluid === 'boolean' && props.fluid,\n      [`container-${props.fluid}`]: typeof props.fluid === 'string',\n      [`gx-${props.gutterX}`]: props.gutterX !== null,\n      [`gy-${props.gutterY}`]: props.gutterY !== null,\n    }))\n\n    onMounted(() => {\n      if (props.toast) {\n        // toastInstance.setVmContainer(container)\n      }\n    })\n\n    // let this be the container for the toast\n    if (props.toast) {\n      toastInstance = useToast({container, root: props.toast.root})\n      expose({\n        // ...toastInstance?.useMethods,\n      })\n    }\n\n    return () => {\n      const subContainers: Array<VNode> = []\n\n      toastInstance?.containerPositions.value.forEach((position) => {\n        subContainers.push(h(BToaster, {key: position, instance: toastInstance, position}))\n      })\n\n      return h('div', {class: [classes.value, props.position], ref: container}, [\n        ...subContainers,\n        slots.default?.(),\n      ])\n    }\n  },\n  methods: {},\n})\n\n/* Reverted back for compat\n\n<template>\n  <component :is=\"tag\" ref=\"container\" :class=\"computedClasses\">\n    <!-- <b-toaster\n      v-for=\"(pos, index) in toasts\"\n      :key=\"index\"\n      :instance=\"toastInstance\"\n      :position=\"pos\"\n    /> -->\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref} from 'vue'\n// import type {Position} from '../types'\n// import BToaster from './BToast/BToaster.vue'\n// import {ToastInstance} from './BToast/plugin'\n\ninterface Props {\n  gutterX?: string\n  gutterY?: string\n  fluid?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl' // boolean | Breakpoint\n  // toast?: Record<string, unknown> // Make this strongly typed\n  // position?: Position\n  tag?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  fluid: false,\n  tag: 'div',\n})\n\nconst container = ref()\n\nconst computedClasses = computed(() => ({\n  container: props.fluid === false,\n  [`container-fluid`]: props.fluid === true,\n  [`container-${props.fluid}`]: typeof props.fluid === 'string',\n  [`gx-${props.gutterX}`]: props.gutterX !== undefined,\n  [`gy-${props.gutterY}`]: props.gutterY !== undefined,\n}))\n\nconst toasts = computed(() => toastInstance?.containerPositions.value)\n    let toastInstance: ToastInstance | undefined\n\n    onMounted(() => {\n      if (props.toast) {\n        // toastInstance.setVmContainer(container)\n      }\n    })\n\n    // let this be the container for the toast\n    if (props.toast) {\n      toastInstance = useToast({container, root: props.toast.root})\n      expose({\n        // ...toastInstance?.useMethods,\n      })\n    }\n\n    return () => {\n      const subContainers: Array<VNode> = []\n\n      toastInstance?.containerPositions.value.forEach((position) => {\n        subContainers.push(h(BToaster, {key: position, instance: toastInstance, position}))\n      })\n\n      return h(props.tag, {class: [classes.value, props.position], ref: container}, [\n        ...subContainers,\n        slots.default?.(),\n      ])\n    }\n}\n\n*/\n</script>\n","<template>\n  <div ref=\"parent\" :class=\"computedClasses\" class=\"btn-group\">\n    <b-button\n      :id=\"computedId\"\n      :variant=\"splitVariant || variant\"\n      :size=\"size\"\n      :class=\"buttonClasses\"\n      :disabled=\"disabled\"\n      :type=\"splitButtonType\"\n      v-bind=\"buttonAttr\"\n      @click=\"onSplitClick\"\n    >\n      <slot name=\"button-content\">\n        {{ text }}\n      </slot>\n    </b-button>\n    <b-button\n      v-if=\"splitBoolean\"\n      :variant=\"variant\"\n      :size=\"size\"\n      :disabled=\"disabled\"\n      v-bind=\"splitAttr\"\n      :class=\"toggleClass\"\n      class=\"dropdown-toggle-split dropdown-toggle\"\n      data-bs-toggle=\"dropdown\"\n      aria-expanded=\"false\"\n      @click=\"emit('toggle')\"\n    >\n      <span class=\"visually-hidden\">\n        <slot name=\"toggle-text\">\n          {{ toggleText }}\n        </slot>\n      </span>\n    </b-button>\n    <ul\n      class=\"dropdown-menu\"\n      :class=\"dropdownMenuClasses\"\n      :aria-labelledby=\"computedId\"\n      :role=\"role\"\n    >\n      <slot />\n    </ul>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BDropdownEmits, BDropdownProps} from '../types/components'\nimport type Popper from '@popperjs/core'\nimport {Dropdown} from 'bootstrap'\nimport {type ComponentPublicInstance, computed, onMounted, ref, toRef} from 'vue'\nimport BButton from '../BButton/BButton.vue'\nimport type {Booleanish, ButtonType, ButtonVariant, ClassValue, Size} from '../../types'\nimport {mergeDeep} from '../../utils'\nimport {useBooleanish, useEventListener, useId} from '../../composables'\n\ninterface BDropdownProps {\n  id?: string\n  menuClass?: ClassValue\n  size?: Size\n  splitClass?: ClassValue\n  splitVariant?: ButtonVariant\n  text?: string\n  toggleClass?: ClassValue\n  autoClose?: boolean | 'inside' | 'outside'\n  block?: Booleanish\n  boundary?: Popper.Boundary\n  dark?: Booleanish\n  disabled?: Booleanish\n  isNav?: Booleanish\n  dropup?: Booleanish\n  dropright?: Booleanish\n  dropleft?: Booleanish\n  noFlip?: Booleanish\n  offset?: number | string\n  popperOpts?: Partial<Popper.Options>\n  right?: Booleanish\n  role?: string\n  split?: Booleanish\n  splitButtonType?: ButtonType\n  splitHref?: string\n  noCaret?: Booleanish\n  toggleText?: string\n  variant?: ButtonVariant\n}\n\nconst props = withDefaults(defineProps<BDropdownProps>(), {\n  autoClose: true,\n  block: false,\n  boundary: 'clippingParents',\n  // TODO\n  /**\n   * @deprecated props.dark is deprecated\n   * review https://getbootstrap.com/docs/5.3/migration/#color-modes\n   */\n  dark: false,\n  disabled: false,\n  dropup: false,\n  isNav: false,\n  dropright: false,\n  dropleft: false,\n  noFlip: false,\n  splitHref: undefined,\n  offset: 0,\n  popperOpts: () => ({}),\n  right: false,\n  role: 'menu',\n  split: false,\n  splitButtonType: 'button',\n  noCaret: false,\n  toggleText: 'Toggle dropdown',\n  variant: 'secondary',\n})\n\ninterface BDropdownEmits {\n  (e: 'show'): void\n  (e: 'shown'): void\n  (e: 'hide'): void\n  (e: 'hidden'): void\n  (e: 'click', event: MouseEvent): void\n  (e: 'toggle'): void\n}\n\nconst emit = defineEmits<BDropdownEmits>()\n\nconst computedId = useId(toRef(props, 'id'), 'dropdown')\n\nconst blockBoolean = useBooleanish(toRef(props, 'block'))\nconst darkBoolean = useBooleanish(toRef(props, 'dark'))\nconst dropupBoolean = useBooleanish(toRef(props, 'dropup'))\nconst droprightBoolean = useBooleanish(toRef(props, 'dropright'))\nconst isNavBoolean = useBooleanish(toRef(props, 'isNav'))\nconst dropleftBoolean = useBooleanish(toRef(props, 'dropleft'))\nconst rightBoolean = useBooleanish(toRef(props, 'right'))\nconst splitBoolean = useBooleanish(toRef(props, 'split'))\nconst noCaretBoolean = useBooleanish(toRef(props, 'noCaret'))\n\nconst parent = ref<HTMLElement>()\nconst dropdown = ref<ComponentPublicInstance<HTMLElement>>()\nconst instance = ref<Dropdown>()\n\nconst computedClasses = computed(() => ({\n  'd-grid': blockBoolean.value,\n  'd-flex': blockBoolean.value && splitBoolean.value,\n}))\n\nconst buttonClasses = computed(() => [\n  splitBoolean.value ? props.splitClass : props.toggleClass,\n  {\n    'nav-link': isNavBoolean.value,\n    'dropdown-toggle': !splitBoolean.value,\n    'dropdown-toggle-no-caret': noCaretBoolean.value && !splitBoolean.value,\n    'w-100': splitBoolean.value && blockBoolean.value,\n  },\n])\n\nconst dropdownMenuClasses = computed(() => [\n  props.menuClass,\n  {\n    'dropdown-menu-dark': darkBoolean.value,\n    'dropdown-menu-end': rightBoolean.value,\n  },\n])\n\nconst buttonAttr = computed(() => ({\n  'data-bs-toggle': splitBoolean.value ? undefined : 'dropdown',\n  'aria-expanded': splitBoolean.value ? undefined : false,\n  'ref': splitBoolean.value ? undefined : dropdown,\n  'href': splitBoolean.value ? props.splitHref : undefined,\n}))\n\nconst splitAttr = computed(() => ({\n  ref: splitBoolean.value ? dropdown : undefined,\n}))\n\nconst hide = (): void => {\n  instance.value?.hide()\n}\n\nconst onSplitClick = (event: MouseEvent) => {\n  if (splitBoolean.value) {\n    emit('click', event)\n  }\n}\n\nuseEventListener(parent, 'show.bs.dropdown', () => emit('show'))\nuseEventListener(parent, 'shown.bs.dropdown', () => emit('shown'))\nuseEventListener(parent, 'hide.bs.dropdown', () => emit('hide'))\nuseEventListener(parent, 'hidden.bs.dropdown', () => emit('hidden'))\n\nonMounted((): void => {\n  instance.value = new Dropdown(dropdown.value?.$el, {\n    autoClose: props.autoClose,\n    boundary: props.boundary,\n    offset: props.offset ? props.offset.toString() : '',\n    reference: props.offset || splitBoolean.value ? 'parent' : 'toggle',\n    popperConfig: (defaultConfig?: Partial<Popper.Options>) => {\n      const dropDownConfig = {\n        placement: 'bottom-start',\n        modifiers: !props.noFlip\n          ? []\n          : [\n              {\n                name: 'flip',\n                options: {\n                  fallbackPlacements: [],\n                },\n              },\n            ],\n      }\n\n      if (dropupBoolean.value) {\n        dropDownConfig.placement = rightBoolean.value ? 'top-end' : 'top-start'\n      } else if (droprightBoolean.value) {\n        dropDownConfig.placement = 'right-start'\n      } else if (dropleftBoolean.value) {\n        dropDownConfig.placement = 'left-start'\n      } else if (rightBoolean.value) {\n        dropDownConfig.placement = 'bottom-end'\n      }\n      return mergeDeep(defaultConfig, mergeDeep(dropDownConfig, props.popperOpts))\n    },\n  })\n})\n\ndefineExpose({\n  hide,\n})\n</script>\n","<template>\n  <li role=\"presentation\">\n    <form class=\"px-4 py-3\">\n      <slot />\n    </form>\n  </li>\n</template>\n","<template>\n  <li role=\"presentation\">\n    <component\n      :is=\"headerTag\"\n      :id=\"headerId\"\n      class=\"dropdown-header\"\n      :class=\"computedClasses\"\n      :role=\"headerRole\"\n    >\n      <slot name=\"header\">\n        {{ header }}\n      </slot>\n    </component>\n    <ul\n      :id=\"id\"\n      role=\"group\"\n      class=\"list-unstyled\"\n      v-bind=\"$attrs\"\n      :aria-describedby=\"ariaDescribedby || headerId\"\n    >\n      <slot />\n    </ul>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BDropdownGroupProps} from '../../types/components'\nimport type {ClassValue, ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BDropdownGroupProps {\n  id?: string\n  ariaDescribedby?: string\n  header?: string\n  headerClass?: ClassValue\n  headerTag?: string\n  headerVariant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BDropdownGroupProps>(), {\n  headerTag: 'header',\n})\n\nconst headerId = computed<string | undefined>(() =>\n  props.id ? `${props.id}_group_dd_header` : undefined\n)\n\nconst headerRole = computed<'heading' | undefined>(() =>\n  props.headerTag === 'header' ? undefined : 'heading'\n)\n\nconst computedClasses = computed(() => [\n  props.headerClass,\n  {\n    [`text-${props.headerVariant}`]: props.headerVariant !== undefined,\n  },\n])\n</script>\n\n<script lang=\"ts\">\nexport default {\n  inheritAttrs: false,\n}\n</script>\n","<template>\n  <li>\n    <h6 class=\"dropdown-header\">\n      <slot />\n    </h6>\n  </li>\n</template>\n","<template>\n  <li role=\"presentation\" :class=\"$attrs.class\">\n    <component\n      :is=\"tag\"\n      class=\"dropdown-item\"\n      :class=\"computedClasses\"\n      v-bind=\"componentAttrs\"\n      @click=\"clicked\"\n    >\n      <slot />\n    </component>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BDropdownItemButtonEmits, BDropdownItemProps} from '../../types/components'\nimport BLink from '../BLink/BLink.vue'\nimport {computed, toRef, useAttrs} from 'vue'\nimport type {Booleanish, ClassValue, ColorVariant, LinkTarget} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BDropdownItemProps {\n  href?: string\n  linkClass?: ClassValue\n  active?: Booleanish\n  disabled?: Booleanish\n  rel?: string\n  target?: LinkTarget\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BDropdownItemProps>(), {\n  active: false,\n  disabled: false,\n  rel: undefined,\n  target: '_self',\n})\n\nconst activeBoolean = useBooleanish(toRef(props, 'active'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\ninterface BDropdownItemEmits {\n  (e: 'click', value: MouseEvent): void\n}\n\nconst emit = defineEmits<BDropdownItemEmits>()\n\nconst attrs = useAttrs()\n\nconst computedClasses = computed(() => [\n  props.linkClass,\n  {\n    active: activeBoolean.value,\n    disabled: disabledBoolean.value,\n    [`text-${props.variant}`]: props.variant !== undefined,\n  },\n])\n\nconst tag = computed<'button' | 'a' | typeof BLink>(() =>\n  props.href ? 'a' : attrs.to ? BLink : 'button'\n)\n\nconst componentAttrs = computed(() => ({\n  'disabled': disabledBoolean.value,\n  'aria-current': activeBoolean.value ? 'true' : null,\n  'href': tag.value === 'a' ? props.href : null,\n  'rel': props.rel,\n  'type': tag.value === 'button' ? 'button' : null,\n  'target': props.target,\n  ...(attrs.to ? {activeClass: 'active', ...attrs} : {}),\n}))\n\n// Pretty sure this emits if tag is not button and is disabled\nconst clicked = (e: MouseEvent): void => emit('click', e)\n</script>\n\n<script lang=\"ts\">\nexport default {\n  inheritAttrs: false,\n}\n</script>\n","<template>\n  <li role=\"presentation\" :class=\"$attrs.class\">\n    <!-- Should click be click.prevent ? -->\n    <button\n      role=\"menu\"\n      type=\"button\"\n      class=\"dropdown-item\"\n      :class=\"computedClasses\"\n      :disabled=\"disabledBoolean\"\n      @click=\"clicked\"\n    >\n      <slot />\n    </button>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BDropdownItemButtonEmits, BDropdownItemButtonProps} from '../../types/components'\nimport type {Booleanish, ClassValue, ColorVariant} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ninterface BDropdownItemButtonProps {\n  buttonClass?: ClassValue\n  active?: Booleanish\n  activeClass?: string\n  disabled?: Booleanish\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BDropdownItemButtonProps>(), {\n  active: false,\n  activeClass: 'active',\n  disabled: false,\n})\n\nconst activeBoolean = useBooleanish(toRef(props, 'active'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\ninterface BDropdownItemButtonEmits {\n  (e: 'click', value: MouseEvent): void\n}\n\nconst emit = defineEmits<BDropdownItemButtonEmits>()\n\nconst computedClasses = computed(() => [\n  props.buttonClass,\n  {\n    [props.activeClass]: activeBoolean.value,\n    disabled: disabledBoolean.value,\n    [`text-${props.variant}`]: props.variant !== undefined,\n  },\n])\n\nconst clicked = (e: MouseEvent): void => emit('click', e)\n</script>\n\n<script lang=\"ts\">\nexport default {\n  inheritAttrs: false,\n}\n</script>\n","<template>\n  <form\n    :id=\"id\"\n    :novalidate=\"novalidateBoolean\"\n    :class=\"computedClasses\"\n    @submit.prevent=\"submitted\"\n  >\n    <slot />\n  </form>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormEmits, BFormProps} from '../../types/components'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BFormProps {\n  id?: string\n  floating?: Booleanish\n  novalidate?: Booleanish\n  validated?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BFormProps>(), {\n  floating: false,\n  novalidate: false,\n  validated: false,\n})\n\nconst floatingBoolean = useBooleanish(toRef(props, 'floating'))\nconst novalidateBoolean = useBooleanish(toRef(props, 'novalidate'))\nconst validatedBoolean = useBooleanish(toRef(props, 'validated'))\n\ninterface BFormEmits {\n  (e: 'submit', value: Event): void\n}\n\nconst emit = defineEmits<BFormEmits>()\n\nconst computedClasses = computed(() => ({\n  'form-floating': floatingBoolean.value,\n  'was-validated': validatedBoolean.value,\n}))\n\nconst submitted = (e: Event): void => emit('submit', e)\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\" v-bind=\"computedAttrs\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormInvalidFeedbackProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BFormInvalidFeedbackProps {\n  ariaLive?: string\n  forceShow?: Booleanish\n  id?: string\n  text?: string\n  role?: string\n  state?: Booleanish\n  tag?: string\n  tooltip?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BFormInvalidFeedbackProps>(), {\n  forceShow: false,\n  tag: 'div',\n  state: undefined,\n  tooltip: false,\n})\n\nconst forceShowBoolean = useBooleanish(toRef(props, 'forceShow'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\nconst tooltipBoolean = useBooleanish(toRef(props, 'tooltip'))\n\nconst computedShow = computed<boolean>(\n  () => forceShowBoolean.value === true || stateBoolean.value === false\n)\n\nconst computedClasses = computed(() => ({\n  'd-block': computedShow.value,\n  'invalid-feedback': !tooltipBoolean.value,\n  'invalid-tooltip': tooltipBoolean.value,\n}))\n\nconst computedAttrs = computed(() => ({\n  'id': props.id,\n  'role': props.role,\n  'aria-live': props.ariaLive,\n  'aria-atomic': props.ariaLive ? 'true' : undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" :class=\"computedClasses\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormTextProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, TextColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BFormTextProps {\n  id?: string\n  inline?: Booleanish\n  tag?: string\n  text?: string\n  textVariant?: TextColorVariant\n}\n\nconst props = withDefaults(defineProps<BFormTextProps>(), {\n  inline: false,\n  tag: 'small',\n  textVariant: 'muted',\n})\n\nconst inlineBoolean = useBooleanish(toRef(props, 'inline'))\n\nconst computedClasses = computed(() => [\n  [`text-${props.textVariant}`],\n  {\n    'form-text': !inlineBoolean.value,\n  },\n])\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"id\"\n    :role=\"role\"\n    :aria-live=\"ariaLive\"\n    :aria-atomic=\"computedAriaAtomic\"\n    :class=\"computedClasses\"\n  >\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormValidFeedbackProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BFormValidFeedbackProps {\n  ariaLive?: string\n  forceShow?: Booleanish\n  id?: string\n  role?: string\n  text?: string\n  state?: Booleanish\n  tag?: string\n  tooltip?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BFormValidFeedbackProps>(), {\n  forceShow: false,\n  tag: 'div',\n  tooltip: false,\n  state: undefined,\n})\n\nconst forceShowBoolean = useBooleanish(toRef(props, 'forceShow'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\nconst tooltipBoolean = useBooleanish(toRef(props, 'tooltip'))\n\nconst computedShow = computed<boolean>(\n  () => forceShowBoolean.value === true || stateBoolean.value === true\n)\n\nconst computedClasses = computed(() => ({\n  'd-block': computedShow.value,\n  'valid-feedback': !tooltipBoolean.value,\n  'valid-tooltip': tooltipBoolean.value,\n}))\n\nconst computedAriaAtomic = computed(() => (props.ariaLive ? 'true' : undefined))\n</script>\n","<template>\n  <div :class=\"computedClasses\">\n    <input\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"input\"\n      v-model=\"localValue\"\n      :class=\"inputClasses\"\n      type=\"checkbox\"\n      :disabled=\"disabledBoolean\"\n      :required=\"!!name && !!requiredBoolean\"\n      :name=\"name\"\n      :form=\"form\"\n      :aria-label=\"ariaLabel\"\n      :aria-labelledby=\"ariaLabelledBy\"\n      :aria-required=\"name && requiredBoolean ? 'true' : undefined\"\n      :value=\"value\"\n      :indeterminate=\"indeterminateBoolean\"\n      @focus=\"isFocused = true\"\n      @blur=\"isFocused = false\"\n    />\n    <label\n      v-if=\"hasDefaultSlot || !plainBoolean\"\n      :for=\"computedId\"\n      :class=\"[labelClasses, {active: isChecked, focus: isFocused}]\"\n    >\n      <slot />\n    </label>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormCheckboxEmits, BFormCheckboxProps} from '../../types/components'\nimport {isEmptySlot} from '../../utils'\nimport {computed, onMounted, reactive, ref, toRef, useSlots} from 'vue'\nimport {getClasses, getInputClasses, getLabelClasses, useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ButtonVariant, InputSize} from '../../types'\n\ninterface BFormCheckboxProps {\n  ariaLabel?: string\n  ariaLabelledBy?: string\n  form?: string\n  indeterminate?: Booleanish\n  name?: string\n  id?: string\n  autofocus?: Booleanish\n  plain?: Booleanish\n  button?: Booleanish\n  switch?: Booleanish\n  disabled?: Booleanish\n  buttonVariant?: ButtonVariant\n  inline?: Booleanish\n  required?: Booleanish\n  size?: InputSize\n  state?: Booleanish\n  uncheckedValue?:\n    | Array<unknown>\n    | Set<unknown>\n    | boolean\n    | string\n    | Record<string, unknown>\n    | number\n  value?: Array<unknown> | Set<unknown> | boolean | string | Record<string, unknown> | number\n  modelValue?: Array<unknown> | Set<unknown> | boolean | string | Record<string, unknown> | number\n}\n\nconst props = withDefaults(defineProps<BFormCheckboxProps>(), {\n  autofocus: false,\n  plain: false,\n  button: false,\n  id: undefined,\n  required: undefined,\n  state: undefined,\n  modelValue: undefined,\n  switch: false,\n  disabled: false,\n  buttonVariant: 'secondary',\n  inline: false,\n  size: 'md',\n  uncheckedValue: false,\n  value: true,\n})\n\ninterface BFormCheckboxEmits {\n  (e: 'update:modelValue', value: unknown): void\n  (e: 'input', value: unknown): void\n  (e: 'change', value: unknown): void\n}\n\nconst emit = defineEmits<BFormCheckboxEmits>()\n\nconst slots = useSlots()\n\nconst computedId = useId(toRef(props, 'id'), 'form-check')\n\nconst indeterminateBoolean = useBooleanish(toRef(props, 'indeterminate'))\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst plainBoolean = useBooleanish(toRef(props, 'plain'))\nconst buttonBoolean = useBooleanish(toRef(props, 'button'))\nconst switchBoolean = useBooleanish(toRef(props, 'switch'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst inlineBoolean = useBooleanish(toRef(props, 'inline'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\n\nconst input = ref<HTMLElement>(null as unknown as HTMLElement)\nconst isFocused = ref<boolean>(false)\n\nconst hasDefaultSlot = computed<boolean>(() => !isEmptySlot(slots.default))\n\nconst localValue = computed({\n  get: (): unknown[] | Set<unknown> | boolean | undefined => {\n    if (props.uncheckedValue) {\n      if (!Array.isArray(props.modelValue)) {\n        return props.modelValue === props.value\n      }\n      return props.modelValue.indexOf(props.value) > -1\n    }\n    return props.modelValue as unknown[] | Set<unknown> | boolean | undefined\n  },\n  set: (newValue: any) => {\n    let emitValue = newValue\n    if (!Array.isArray(props.modelValue)) {\n      emitValue = newValue ? props.value : props.uncheckedValue\n    } else {\n      if (props.uncheckedValue) {\n        emitValue = props.modelValue\n        if (newValue) {\n          if (emitValue.indexOf(props.uncheckedValue) > -1)\n            emitValue.splice(emitValue.indexOf(props.uncheckedValue), 1)\n          emitValue.push(props.value)\n        } else {\n          if (emitValue.indexOf(props.value) > -1)\n            emitValue.splice(emitValue.indexOf(props.value), 1)\n          emitValue.push(props.uncheckedValue)\n        }\n      }\n    }\n    emit('input', emitValue)\n    emit('update:modelValue', emitValue)\n    emit('change', emitValue)\n  },\n})\n\nconst isChecked = computed<boolean>(() => {\n  if (Array.isArray(props.modelValue)) {\n    return props.modelValue.indexOf(props.value) > -1\n  }\n  return JSON.stringify(props.modelValue) === JSON.stringify(props.value)\n})\n\nconst classesObject = reactive({\n  plain: toRef(plainBoolean, 'value'),\n  button: toRef(buttonBoolean, 'value'),\n  inline: toRef(inlineBoolean, 'value'),\n  switch: toRef(switchBoolean, 'value'),\n  size: toRef(props, 'size'),\n  state: toRef(stateBoolean, 'value'),\n  buttonVariant: toRef(props, 'buttonVariant'),\n})\nconst computedClasses = getClasses(classesObject)\nconst inputClasses = getInputClasses(classesObject)\nconst labelClasses = getLabelClasses(classesObject)\n\n// TODO: make tests compatible with the v-focus directive\nonMounted((): void => {\n  if (autofocusBoolean.value) {\n    input.value.focus()\n  }\n})\n</script>\n\n<script lang=\"ts\">\nexport default {\n  inheritAttrs: false,\n}\n</script>\n","<template>\n  <div\n    v-bind=\"computedAttrs\"\n    :id=\"computedId\"\n    role=\"group\"\n    :class=\"computedClasses\"\n    class=\"bv-no-focus-ring\"\n    tabindex=\"-1\"\n  >\n    <b-form-checkbox\n      v-for=\"(item, key) in checkboxList\"\n      :key=\"key\"\n      v-model=\"localValue\"\n      v-bind=\"item.props\"\n    >\n      <!-- eslint-disable-next-line vue/no-v-html -->\n      <span v-if=\"item.html\" v-html=\"item.html\" />\n      <span v-else v-text=\"item.text\" />\n    </b-form-checkbox>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormCheckboxGroupEmits, BFormCheckboxGroupProps} from '../../types/components'\nimport {computed, reactive, toRef, useSlots} from 'vue'\nimport BFormCheckbox from './BFormCheckbox.vue'\nimport type {AriaInvalid, Booleanish, ButtonVariant, Size} from '../../types'\nimport {\n  bindGroupProps,\n  getGroupAttr,\n  getGroupClasses,\n  optionToElement,\n  slotsToElements,\n  useBooleanish,\n  useId,\n} from '../../composables'\n\ninterface BFormCheckboxGroupProps {\n  id?: string\n  form?: string\n  modelValue?: Array<string | number | Record<string, unknown>>\n  ariaInvalid?: AriaInvalid\n  autofocus?: Booleanish\n  buttonVariant?: ButtonVariant\n  buttons?: Booleanish\n  disabled?: Booleanish\n  disabledField?: string\n  htmlField?: string\n  name?: string\n  options?: Array<string | Record<string, unknown>> // I don't believe it possible to make a strongly typed object if object fields come from a prop\n  plain?: Booleanish\n  required?: Booleanish\n  size?: Size\n  stacked?: Booleanish\n  state?: Booleanish\n  switches?: Booleanish\n  textField?: string\n  validated?: Booleanish\n  valueField?: string\n}\n\nconst props = withDefaults(defineProps<BFormCheckboxGroupProps>(), {\n  modelValue: () => [],\n  autofocus: false,\n  buttonVariant: 'secondary',\n  buttons: false,\n  ariaInvalid: undefined,\n  state: undefined,\n  disabled: false,\n  disabledField: 'disabled',\n  htmlField: 'html',\n  options: () => [],\n  plain: false,\n  required: false,\n  stacked: false,\n  switches: false,\n  textField: 'text',\n  validated: false,\n  valueField: 'value',\n})\n\ninterface BFormCheckboxGroupEmits {\n  (e: 'input', value: Exclude<BFormCheckboxGroupProps['modelValue'], undefined>): void\n  (e: 'update:modelValue', value: Exclude<BFormCheckboxGroupProps['modelValue'], undefined>): void\n  (e: 'change', value: Exclude<BFormCheckboxGroupProps['modelValue'], undefined>): void\n}\n\nconst emit = defineEmits<BFormCheckboxGroupEmits>()\n\nconst slots = useSlots()\n\nconst slotsName = 'BFormCheckbox'\n\nconst computedId = useId(toRef(props, 'id'), 'checkbox')\nconst computedName = useId(toRef(props, 'name'), 'checkbox')\n\n// TODO autofocus is not used\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst buttonsBoolean = useBooleanish(toRef(props, 'buttons'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n// TODO plain is not used\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst plainBoolean = useBooleanish(toRef(props, 'plain'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stackedBoolean = useBooleanish(toRef(props, 'stacked'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\nconst switchesBoolean = useBooleanish(toRef(props, 'switches'))\nconst validatedBoolean = useBooleanish(toRef(props, 'validated'))\n\nconst localValue = computed({\n  get: () => props.modelValue,\n  set: (newValue) => {\n    if (JSON.stringify(newValue) === JSON.stringify(props.modelValue)) return\n\n    /**\n     * Sorts the value and makes it the same order as options\n     * Ie: props.options = ['a', 'b', 'c'], no matter what order the options are selected,\n     * User clicks 'c', then clicks 'b' => ['b', 'c'], not ['c', 'b']\n     */\n    const sortByOptions: Array<string | number | Record<string, unknown>> = props.options\n      .filter((el) =>\n        newValue\n          .map((it) => JSON.stringify(it))\n          .includes(JSON.stringify(typeof el === 'string' ? el : el[props.valueField]))\n      )\n      .map((el) => (typeof el === 'string' ? el : el[props.valueField])) as Array<\n      string | number | Record<string, unknown>\n    >\n\n    emit('input', sortByOptions)\n    emit('update:modelValue', sortByOptions)\n    emit('change', sortByOptions)\n  },\n})\n\nconst checkboxList = computed(() =>\n  (slots.first ? slotsToElements(slots.first(), slotsName, disabledBoolean.value) : [])\n    .concat(props.options.map((e) => optionToElement(e, props)))\n    .concat(slots.default ? slotsToElements(slots.default(), slotsName, disabledBoolean.value) : [])\n    .map((e, idx) => bindGroupProps(e, idx, props, computedName, computedId))\n    .map((e) => ({\n      ...e,\n      props: {\n        switch: switchesBoolean.value,\n        ...e.props,\n      },\n    }))\n)\n\nconst classesObject = reactive({\n  required: toRef(requiredBoolean, 'value'),\n  ariaInvalid: toRef(props, 'ariaInvalid'),\n  state: toRef(stateBoolean, 'value'),\n  validated: toRef(validatedBoolean, 'value'),\n  buttons: toRef(buttonsBoolean, 'value'),\n  stacked: toRef(stackedBoolean, 'value'),\n  size: toRef(props, 'size'),\n})\nconst computedAttrs = getGroupAttr(classesObject)\nconst computedClasses = getGroupClasses(classesObject)\n\n// TODO: make tests compatible with the v-focus directive\n</script>\n","<script lang=\"ts\">\nimport {useBooleanish, useId} from '../../composables'\nimport {RX_SPACE_SPLIT} from '../../constants/regex'\nimport {\n  attemptFocus,\n  cssEscape,\n  getAttr,\n  getId,\n  IS_BROWSER,\n  isVisible,\n  normalizeSlot,\n  removeAttr,\n  resolveAriaInvalid,\n  select,\n  selectAll,\n  setAttr,\n  stringToInteger,\n  suffixPropName,\n} from '../../utils'\nimport {\n  computed,\n  defineComponent,\n  h,\n  nextTick,\n  onMounted,\n  type PropType,\n  ref,\n  toRef,\n  watch,\n} from 'vue'\nimport BCol from '../BCol.vue'\nimport BFormInvalidFeedback from '../BForm/BFormInvalidFeedback.vue'\nimport BFormRow from '../BForm/BFormRow.vue'\nimport BFormText from '../BForm/BFormText.vue'\nimport BFormValidFeedback from '../BForm/BFormValidFeedback.vue'\nimport type {AriaInvalid, Booleanish} from '../../types'\n\nconst INPUTS = ['input', 'select', 'textarea']\n// Selector for finding first input in the form group\nconst INPUT_SELECTOR = INPUTS.map((v) => `${v}:not([disabled])`).join()\n\n// A list of interactive elements (tag names) inside `<b-form-group>`'s legend\nconst LEGEND_INTERACTIVE_ELEMENTS = [...INPUTS, 'a', 'button', 'label']\n\nexport const SLOT_NAME_LABEL = 'label'\nexport const SLOT_NAME_INVALID_FEEDBACK = 'invalid-feedback'\nexport const SLOT_NAME_VALID_FEEDBACK = 'valid-feedback'\nexport const SLOT_NAME_DESCRIPTION = 'description'\nexport const SLOT_NAME_DEFAULT = 'default'\n\nexport default defineComponent({\n  components: {BCol, BFormInvalidFeedback, BFormRow, BFormText, BFormValidFeedback},\n  props: {\n    contentCols: {type: [Boolean, String, Number], required: false},\n    contentColsLg: {type: [Boolean, String, Number], required: false},\n    contentColsMd: {type: [Boolean, String, Number], required: false},\n    contentColsSm: {type: [Boolean, String, Number], required: false},\n    contentColsXl: {type: [Boolean, String, Number], required: false},\n    description: {type: [String], required: false},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    feedbackAriaLive: {type: String, default: 'assertive'},\n    id: {type: String, required: false},\n    invalidFeedback: {type: String, required: false},\n    label: {type: String, required: false},\n    labelAlign: {type: [Boolean, String, Number], required: false},\n    labelAlignLg: {type: [Boolean, String, Number], required: false},\n    labelAlignMd: {type: [Boolean, String, Number], required: false},\n    labelAlignSm: {type: [Boolean, String, Number], required: false},\n    labelAlignXl: {type: [Boolean, String, Number], required: false},\n    labelClass: {type: [Array, Object, String], required: false},\n    labelCols: {type: [Boolean, String, Number], required: false},\n    labelColsLg: {type: [Boolean, String, Number], required: false},\n    labelColsMd: {type: [Boolean, String, Number], required: false},\n    labelColsSm: {type: [Boolean, String, Number], required: false},\n    labelColsXl: {type: [Boolean, String, Number], required: false},\n    labelFor: {type: String, required: false},\n    labelSize: {type: String, required: false},\n    labelSrOnly: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    state: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n    tooltip: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    validFeedback: {type: String, required: false},\n    validated: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    floating: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  },\n  setup(props, {attrs}) {\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n    const labelSrOnlyBoolean = useBooleanish(toRef(props, 'labelSrOnly'))\n    const stateBoolean = useBooleanish(toRef(props, 'state'))\n    const tooltipBoolean = useBooleanish(toRef(props, 'tooltip'))\n    const validatedBoolean = useBooleanish(toRef(props, 'validated'))\n    const floatingBoolean = useBooleanish(toRef(props, 'floating'))\n\n    const ariaDescribedby: string | null = null as string | null\n    const breakPoints = ['xs', 'sm', 'md', 'lg', 'xl']\n\n    const getAlignClasses = (props: any, prefix: string) =>\n      breakPoints.reduce((result: string[], breakpoint) => {\n        const suffix = suffixPropName(breakpoint === 'xs' ? '' : breakpoint, `${prefix}Align`)\n        const propValue: string = props[suffix] || null\n        if (propValue) {\n          breakpoint === 'xs'\n            ? result.push(`text-${propValue}`)\n            : result.push(`text-${breakpoint}-${propValue}`)\n        }\n\n        return result\n      }, [])\n\n    const getColProps = (props: any, prefix: string) =>\n      breakPoints.reduce((result: any, breakpoint: string) => {\n        const suffix = suffixPropName(breakpoint === 'xs' ? '' : breakpoint, `${prefix}Cols`)\n        let propValue = props[suffix]\n        // Handle case where the prop's value is an empty string,\n        // which represents `true`\n        propValue = propValue === '' ? true : propValue || false\n\n        if (!(typeof propValue === 'boolean') && propValue !== 'auto') {\n          // Convert to column size to number\n          propValue = stringToInteger(propValue, 0)\n          // Ensure column size is greater than `0`\n          propValue = propValue > 0 ? propValue : false\n        }\n\n        // Add the prop to the list of props to give to `<b-col>`\n        // If breakpoint is '' (`${prefix}Cols` is `true`), then we use\n        // the 'col' prop to make equal width at 'xs'\n        if (propValue) {\n          // Extra care is required for xs since it does not have a BCol breakpoint prop\n          // Xs breakpoint is simply 'cols'\n          if (breakpoint === 'xs') {\n            result.cols = propValue\n          } else {\n            result[breakpoint || (typeof propValue === 'boolean' ? 'col' : 'cols')] = propValue\n          }\n        }\n        return result\n      }, {})\n\n    const content = ref()\n\n    // Sets the `aria-describedby` attribute on the input if `labelFor` is set\n    // Optionally accepts a string of Ids to remove as the second parameter\n    // Preserves any `aria-describedby` value(s) user may have on input\n    const updateAriaDescribedby = (newValue: string | null, oldValue: string | null = null) => {\n      if (IS_BROWSER && props.labelFor) {\n        // We need to escape `labelFor` since it can be user-provided\n        const $input = select(`#${cssEscape(props.labelFor)}`, content)\n        if ($input) {\n          const attr = 'aria-describedby'\n          const newIds = (newValue || '').split(RX_SPACE_SPLIT)\n          const oldIds = (oldValue || '').split(RX_SPACE_SPLIT)\n\n          // Update Id list, preserving any original Ids\n          // and ensuring the Id's are unique\n          const ids = (getAttr($input, attr) || '')\n            .split(RX_SPACE_SPLIT)\n            .filter((id) => !oldIds.includes(id))\n            .concat(newIds)\n            .filter((id, index, ids) => ids.indexOf(id) === index)\n            .filter((x) => x)\n            .join(' ')\n            .trim()\n\n          if (ids) {\n            setAttr($input, attr, ids)\n          } else {\n            removeAttr($input, attr)\n          }\n        }\n      }\n    }\n\n    const contentColProps = computed(() => getColProps(props, 'content'))\n    const labelAlignClasses = computed(() => getAlignClasses(props, 'label'))\n    const labelColProps = computed(() => getColProps(props, 'label'))\n    const isHorizontal = computed(\n      () =>\n        // Determine if the form group will be rendered horizontal\n        // based on the existence of 'content-col' or 'label-col' props\n        Object.keys(contentColProps.value).length > 0 || Object.keys(labelColProps.value).length > 0\n    )\n    const computedState = computed(() =>\n      // If not a boolean, ensure that value is null\n      typeof stateBoolean.value === 'boolean' ? stateBoolean.value : null\n    )\n    const stateClass = computed(() => {\n      const state = computedState.value\n      return state === true ? 'is-valid' : state === false ? 'is-invalid' : null\n    })\n    const computedAriaInvalid = computed(() =>\n      resolveAriaInvalid(attrs.ariaInvalid as unknown as AriaInvalid, stateBoolean.value)\n    )\n\n    watch(\n      () => ariaDescribedby,\n      (newValue: string | null, oldValue: string | null) => {\n        if (newValue !== oldValue) {\n          updateAriaDescribedby(newValue, oldValue)\n        }\n      }\n    )\n\n    onMounted(() => {\n      nextTick(() => {\n        // Set `aria-describedby` on the input specified by `labelFor`\n        // We do this in a `$nextTick()` to ensure the children have finished rendering\n        updateAriaDescribedby(ariaDescribedby)\n      })\n    })\n\n    const onLegendClick = (event: MouseEvent) => {\n      // Don't do anything if `labelFor` is set\n      if (props.labelFor) {\n        return\n      }\n\n      const {target} = event\n      const tagName = target ? (target as HTMLElement).tagName : ''\n\n      // If clicked an interactive element inside legend,\n      // we just let the default happen\n      if (LEGEND_INTERACTIVE_ELEMENTS.indexOf(tagName) !== -1) {\n        return\n      }\n\n      // If only a single input, focus it, emulating label behaviour\n      const inputs = selectAll(INPUT_SELECTOR, content).filter(isVisible)\n      if (inputs.length === 1) {\n        attemptFocus(inputs[0])\n      }\n    }\n\n    return {\n      disabledBoolean,\n      labelSrOnlyBoolean,\n      stateBoolean,\n      tooltipBoolean,\n      validatedBoolean,\n      floatingBoolean,\n      ariaDescribedby,\n      computedAriaInvalid,\n      contentColProps,\n      isHorizontal,\n      labelAlignClasses,\n      labelColProps,\n      onLegendClick,\n      stateClass,\n    }\n  },\n  render() {\n    const props = this.$props\n    const slots = this.$slots\n\n    const id = useId()\n    const isFieldset = !props.labelFor\n\n    let $label: any = null\n    const labelContent = normalizeSlot(SLOT_NAME_LABEL, {}, slots) || props.label\n    const labelId = labelContent ? getId('_BV_label_') : null\n\n    if (labelContent || this.isHorizontal) {\n      const labelTag: 'legend' | 'label' = isFieldset ? 'legend' : 'label'\n      if (this.labelSrOnlyBoolean) {\n        if (labelContent) {\n          $label = h(\n            labelTag,\n            {\n              class: 'visually-hidden',\n              id: labelId,\n              for: props.labelFor || null,\n            },\n            labelContent\n          )\n        }\n        if (this.isHorizontal) {\n          $label = h(BCol, this.labelColProps, {default: () => $label})\n        } else {\n          $label = h('div', {}, [$label])\n        }\n      } else {\n        const renderProps = {\n          onClick: isFieldset ? this.onLegendClick : null,\n          ...(this.isHorizontal ? this.labelColProps : {}),\n          tag: this.isHorizontal ? labelTag : null,\n          id: labelId,\n          for: props.labelFor || null,\n          tabIndex: isFieldset ? '-1' : null,\n          class: [\n            this.isHorizontal ? 'col-form-label' : 'form-label',\n            {\n              'bv-no-focus-ring': isFieldset,\n              'col-form-label': this.isHorizontal || isFieldset,\n              'pt-0': !this.isHorizontal && isFieldset,\n              'd-block': !this.isHorizontal && !isFieldset,\n              [`col-form-label-${props.labelSize}`]: !!props.labelSize,\n            },\n            this.labelAlignClasses,\n            props.labelClass,\n          ],\n        }\n        if (this.isHorizontal) {\n          $label = h(BCol, renderProps, {default: () => labelContent})\n        } else {\n          $label = h(labelTag, renderProps, labelContent)\n        }\n      }\n    }\n\n    let $invalidFeedback = null\n    const invalidFeedbackContent =\n      normalizeSlot(SLOT_NAME_INVALID_FEEDBACK, {}, slots) || this.invalidFeedback\n    const invalidFeedbackId = invalidFeedbackContent ? getId('_BV_feedback_invalid_') : undefined\n\n    if (invalidFeedbackContent) {\n      $invalidFeedback = h(\n        BFormInvalidFeedback,\n        {\n          ariaLive: props.feedbackAriaLive,\n          id: invalidFeedbackId,\n          state: this.stateBoolean,\n          tooltip: this.tooltipBoolean,\n        },\n        {default: () => invalidFeedbackContent}\n      )\n    }\n\n    let $validFeedback = null\n    const validFeedbackContent =\n      normalizeSlot(SLOT_NAME_VALID_FEEDBACK, {}, slots) || this.validFeedback\n    const validFeedbackId = validFeedbackContent ? getId('_BV_feedback_valid_') : undefined\n\n    if (validFeedbackContent) {\n      $validFeedback = h(\n        BFormValidFeedback,\n        {\n          ariaLive: props.feedbackAriaLive,\n          id: validFeedbackId,\n          state: this.stateBoolean,\n          tooltip: this.tooltipBoolean,\n        },\n        {default: () => validFeedbackContent}\n        // validFeedbackContent\n      )\n    }\n\n    let $description = null\n    const descriptionContent = normalizeSlot(SLOT_NAME_DESCRIPTION, {}, slots) || this.description\n    const descriptionId = descriptionContent ? getId('_BV_description_') : undefined\n    if (descriptionContent) {\n      $description = h(\n        BFormText,\n        {\n          id: descriptionId,\n        },\n        {default: () => descriptionContent}\n      )\n    }\n\n    // Update `ariaDescribedby`\n    // Screen readers will read out any content linked to by `aria-describedby`\n    // even if the content is hidden with `display: none;`, hence we only include\n    // feedback Ids if the form group's state is explicitly valid or invalid\n    const ariaDescribedby = (this.ariaDescribedby =\n      [\n        descriptionId,\n        this.stateBoolean === false ? invalidFeedbackId : null,\n        this.stateBoolean === true ? validFeedbackId : null,\n      ]\n        .filter((x) => x)\n        .join(' ') || null)\n\n    const contentBlocks = [\n      normalizeSlot(SLOT_NAME_DEFAULT, {ariaDescribedby, descriptionId, id, labelId}, slots) || '',\n      $invalidFeedback,\n      $validFeedback,\n      $description,\n    ]\n    if (!this.isHorizontal && this.floatingBoolean) contentBlocks.push($label)\n\n    let $content = h(\n      'div',\n      {\n        ref: 'content',\n        class: [\n          {\n            'form-floating': !this.isHorizontal && this.floatingBoolean,\n          },\n        ],\n      },\n      contentBlocks\n    )\n    if (this.isHorizontal) {\n      $content = h(BCol, {ref: 'content', ...this.contentColProps}, {default: () => contentBlocks})\n    }\n\n    // Return it wrapped in a form group\n    // Note: Fieldsets do not support adding `row` or `form-row` directly\n    // to them due to browser specific render issues, so we move the `form-row`\n    // to an inner wrapper div when horizontal and using a fieldset\n    const rowProps = {\n      'class': [\n        // TODO consider removing this static class when refactored to <template> syntax\n        'mb-3',\n        this.stateClass,\n        {\n          'was-validated': this.validatedBoolean,\n        },\n      ],\n      'id': useId(toRef(props, 'id')).value,\n      'disabled': isFieldset ? this.disabledBoolean : null,\n      'role': isFieldset ? null : 'group',\n      'aria-invalid': this.computedAriaInvalid,\n      // Only apply `aria-labelledby` if we are a horizontal fieldset\n      // as the legend is no longer a direct child of fieldset\n      'aria-labelledby': isFieldset && this.isHorizontal ? labelId : null,\n    }\n\n    if (this.isHorizontal && !isFieldset) {\n      return h(BFormRow, rowProps, {default: () => [$label, $content]})\n    }\n\n    return h(\n      isFieldset ? 'fieldset' : 'div',\n      rowProps,\n      this.isHorizontal && isFieldset\n        ? [h(BFormRow, null, {default: () => [$label, $content]})]\n        : this.isHorizontal || !this.floatingBoolean\n        ? [$label, $content]\n        : [$content]\n    )\n  },\n})\n</script>\n","<template>\n  <input\n    :id=\"computedId\"\n    ref=\"input\"\n    :class=\"computedClasses\"\n    :name=\"name || undefined\"\n    :form=\"form || undefined\"\n    :type=\"localType\"\n    :disabled=\"disabled\"\n    :placeholder=\"placeholder\"\n    :required=\"required\"\n    :autocomplete=\"autocomplete || undefined\"\n    :readonly=\"readonly || plaintext\"\n    :min=\"min\"\n    :max=\"max\"\n    :step=\"step\"\n    :list=\"type !== 'password' ? list : undefined\"\n    :aria-required=\"required ? 'true' : undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    v-bind=\"$attrs\"\n    @input=\"onInput($event)\"\n    @change=\"onChange($event)\"\n    @blur=\"onBlur($event)\"\n  />\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, ref} from 'vue'\nimport {COMMON_INPUT_PROPS, useFormInput} from '../../composables'\nimport type {InputType} from '../../types'\n\nconst allowedTypes = [\n  'text',\n  'number',\n  'email',\n  'password',\n  'search',\n  'url',\n  'tel',\n  'date',\n  'time',\n  'range',\n  'color',\n]\n\nexport default defineComponent({\n  props: {\n    ...COMMON_INPUT_PROPS,\n    // debounce: {type: [String, Number], default: 0}, TODO: not implemented yet\n    max: {type: [String, Number], required: false},\n    min: {type: [String, Number], required: false},\n    // noWheel: {type: [Boolean, String] as PropType<Booleanish>, default: false}, TODO: not implemented yet\n    step: {type: [String, Number], required: false},\n    type: {\n      type: String as PropType<InputType>,\n      default: 'text',\n      validator: (value: string) => allowedTypes.includes(value),\n    },\n  },\n  emits: ['update:modelValue', 'change', 'blur', 'input'],\n  setup(props, {emit}) {\n    const {input, computedId, computedAriaInvalid, onInput, onChange, onBlur, focus, blur} =\n      useFormInput(props, emit)\n\n    const isHighlighted = ref(false)\n\n    const computedClasses = computed(() => {\n      const isRange = props.type === 'range'\n      const isColor = props.type === 'color'\n      return {\n        'form-control-highlighted': isHighlighted.value,\n        'form-range': isRange,\n        'form-control': isColor || (!props.plaintext && !isRange),\n        'form-control-color': isColor,\n        'form-control-plaintext': props.plaintext && !isRange && !isColor,\n        [`form-control-${props.size}`]: !!props.size,\n        'is-valid': props.state === true,\n        'is-invalid': props.state === false,\n      }\n    })\n\n    const localType = computed<InputType>(() =>\n      allowedTypes.includes(props.type) ? props.type : 'text'\n    )\n\n    const highlight = () => {\n      if (isHighlighted.value === true) return\n      isHighlighted.value = true\n      setTimeout(() => {\n        isHighlighted.value = false\n      }, 2000)\n    }\n\n    return {\n      computedClasses,\n      localType,\n      input,\n      computedId,\n      computedAriaInvalid,\n      onInput,\n      onChange,\n      onBlur,\n      focus,\n      blur,\n      highlight,\n    }\n  },\n})\n</script>\n","<template>\n  <div :class=\"computedClasses\">\n    <input\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"input\"\n      v-model=\"localValue\"\n      :class=\"inputClasses\"\n      type=\"radio\"\n      :disabled=\"disabledBoolean\"\n      :required=\"!!name && requiredBoolean\"\n      :name=\"name\"\n      :form=\"form\"\n      :aria-label=\"ariaLabel\"\n      :aria-labelledby=\"ariaLabelledby\"\n      :value=\"value\"\n      :aria-required=\"!!name && requiredBoolean ? true : undefined\"\n      @focus=\"isFocused = true\"\n      @blur=\"isFocused = false\"\n    />\n    <label\n      v-if=\"hasDefaultSlot || plainBoolean === false\"\n      :for=\"computedId\"\n      :class=\"[labelClasses, {active: isChecked, focus: isFocused}]\"\n    >\n      <slot />\n    </label>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormRadioEmits, BFormRadioProps} from '../../types/components'\nimport type {Booleanish, ButtonVariant, InputSize} from '../../types'\nimport {getClasses, getInputClasses, getLabelClasses, useBooleanish, useId} from '../../composables'\nimport {computed, onMounted, reactive, ref, toRef, useSlots} from 'vue'\nimport {isEmptySlot} from '../../utils'\n\ninterface BFormRadioProps {\n  ariaLabel?: string\n  ariaLabelledby?: string\n  form?: string\n  id?: string\n  name?: string\n  size?: InputSize\n  autofocus?: Booleanish\n  modelValue?: boolean | string | Array<unknown> | Record<string, unknown> | number\n  plain?: Booleanish\n  button?: Booleanish\n  switch?: Booleanish\n  disabled?: Booleanish\n  buttonVariant?: ButtonVariant\n  inline?: Booleanish\n  required?: Booleanish\n  state?: Booleanish\n  value?: string | boolean | Record<string, unknown> | number\n}\n\nconst props = withDefaults(defineProps<BFormRadioProps>(), {\n  autofocus: false,\n  plain: false,\n  button: false,\n  switch: false,\n  disabled: false,\n  modelValue: undefined,\n  state: undefined,\n  buttonVariant: 'secondary',\n  inline: false,\n  required: false,\n  value: true,\n})\n\ninterface BFormRadioEmits {\n  (e: 'input', value: boolean | string | Array<unknown> | Record<string, unknown> | number): void\n  (e: 'change', value: boolean | string | Array<unknown> | Record<string, unknown> | number): void\n  (\n    e: 'update:modelValue',\n    value: boolean | string | Array<unknown> | Record<string, unknown> | number\n  ): void\n}\n\nconst emit = defineEmits<BFormRadioEmits>()\n\nconst slots = useSlots()\n\nconst computedId = useId(toRef(props, 'id'), 'form-check')\n\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst plainBoolean = useBooleanish(toRef(props, 'plain'))\nconst buttonBoolean = useBooleanish(toRef(props, 'button'))\nconst switchBoolean = useBooleanish(toRef(props, 'switch'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst inlineBoolean = useBooleanish(toRef(props, 'inline'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\n\nconst input = ref<HTMLElement | null>(null)\nconst isFocused = ref<boolean>(false)\n\nconst localValue = computed<unknown>({\n  get: () => (Array.isArray(props.modelValue) ? props.modelValue[0] : props.modelValue),\n  set: (newValue) => {\n    const value = newValue ? props.value : false\n    const emitValue = Array.isArray(props.modelValue) ? [value] : value\n    emit('input', emitValue)\n    emit('change', emitValue)\n    emit('update:modelValue', emitValue)\n  },\n})\n\nconst isChecked = computed<unknown>(() => {\n  if (Array.isArray(props.modelValue)) {\n    return (props.modelValue || []).find((e) => e === props.value)\n  }\n  return JSON.stringify(props.modelValue) === JSON.stringify(props.value)\n})\n\nconst hasDefaultSlot = computed<boolean>(() => !isEmptySlot(slots.default))\n\nconst classesObject = reactive({\n  plain: toRef(plainBoolean, 'value'),\n  button: toRef(buttonBoolean, 'value'),\n  inline: toRef(inlineBoolean, 'value'),\n  switch: toRef(switchBoolean, 'value'),\n  size: toRef(props, 'size'),\n  state: toRef(stateBoolean, 'value'),\n  buttonVariant: toRef(props, 'buttonVariant'),\n})\nconst computedClasses = getClasses(classesObject)\nconst inputClasses = getInputClasses(classesObject)\nconst labelClasses = getLabelClasses(classesObject)\n\n// TODO: make tests compatible with the v-focus directive\nonMounted(() => {\n  if (autofocusBoolean.value && input.value !== null) {\n    input.value.focus()\n  }\n})\n</script>\n","<template>\n  <div\n    v-bind=\"computedAttrs\"\n    :id=\"computedId\"\n    role=\"radiogroup\"\n    :class=\"computedClasses\"\n    class=\"bv-no-focus-ring\"\n    tabindex=\"-1\"\n  >\n    <b-form-radio\n      v-for=\"(item, key) in checkboxList\"\n      :key=\"key\"\n      v-model=\"localValue\"\n      v-bind=\"item.props\"\n    >\n      <!-- eslint-disable-next-line vue/no-v-html -->\n      <span v-if=\"item.html\" v-html=\"item.html\" />\n      <span v-else v-text=\"item.text\" />\n    </b-form-radio>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormRadioGroupEmits, BFormRadioGroupProps} from '../../types/components'\nimport type {AriaInvalid, Booleanish, ButtonVariant, Size} from '../../types'\nimport {computed, reactive, toRef, useSlots} from 'vue'\nimport BFormRadio from './BFormRadio.vue'\nimport {\n  bindGroupProps,\n  getGroupAttr,\n  getGroupClasses,\n  optionToElement,\n  slotsToElements,\n  useBooleanish,\n  useId,\n} from '../../composables'\n\ninterface BFormRadioGroupProps {\n  size?: Size\n  form?: string\n  id?: string\n  name?: string\n  modelValue?: string | boolean | Array<unknown> | Record<string, unknown> | number\n  ariaInvalid?: AriaInvalid\n  autofocus?: Booleanish\n  buttonVariant?: ButtonVariant\n  buttons?: Booleanish\n  disabled?: Booleanish\n  disabledField?: string\n  htmlField?: string\n  options?: Array<unknown> // Objects are not supported yet\n  plain?: Booleanish\n  required?: Booleanish\n  stacked?: Booleanish\n  state?: Booleanish\n  textField?: string\n  validated?: Booleanish\n  valueField?: string\n}\n\nconst props = withDefaults(defineProps<BFormRadioGroupProps>(), {\n  modelValue: '',\n  autofocus: false,\n  buttonVariant: 'secondary',\n  buttons: false,\n  ariaInvalid: undefined,\n  state: undefined,\n  disabled: false,\n  disabledField: 'disabled',\n  htmlField: 'html',\n  options: () => [],\n  plain: false,\n  required: false,\n  stacked: false,\n  textField: 'text',\n  validated: false,\n  valueField: 'value',\n})\n\ninterface BFormRadioGroupEmits {\n  (e: 'input', value: BFormRadioGroupProps['modelValue']): void\n  (e: 'update:modelValue', value: BFormRadioGroupProps['modelValue']): void\n  (e: 'change', value: BFormRadioGroupProps['modelValue']): void\n}\n\nconst emit = defineEmits<BFormRadioGroupEmits>()\n\n/**\n * The available slots are default and first\n */\nconst slots = useSlots()\n\nconst slotsName = 'BFormRadio'\n\nconst computedId = useId(toRef(props, 'id'), 'radio')\nconst computedName = useId(toRef(props, 'name'), 'checkbox')\n\n// TODO autofocus is unused\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst buttonsBoolean = useBooleanish(toRef(props, 'buttons'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n// TODO plain is unused\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst plainBoolean = useBooleanish(toRef(props, 'plain'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stackedBoolean = useBooleanish(toRef(props, 'stacked'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\nconst validatedBoolean = useBooleanish(toRef(props, 'validated'))\n\n// TODO this needs to be tested\nconst localValue = computed({\n  get: () => props.modelValue,\n  set: (newValue) => {\n    emit('input', newValue)\n    emit('update:modelValue', newValue)\n    emit('change', newValue)\n  },\n})\n\n// TODO this needs to be tested\nconst checkboxList = computed(() =>\n  (slots.first ? slotsToElements(slots.first(), slotsName, disabledBoolean.value) : []) // Add slot.first to array\n    .concat(props.options.map((e) => optionToElement(e, props))) // Convert props.options to usable value, then concat to array\n    .concat(slots.default ? slotsToElements(slots.default(), slotsName, disabledBoolean.value) : []) // Concat slot.default to array\n    .map((e, idx) => bindGroupProps(e, idx, props, computedName, computedId)) // Map it to preferred structure\n    .map((e) => ({\n      ...e,\n    }))\n)\n\nconst classesObject = reactive({\n  required: toRef(requiredBoolean, 'value'),\n  ariaInvalid: toRef(props, 'ariaInvalid'),\n  state: toRef(stateBoolean, 'value'),\n  validated: toRef(validatedBoolean, 'value'),\n  buttons: toRef(buttonsBoolean, 'value'),\n  stacked: toRef(stackedBoolean, 'value'),\n  size: toRef(props, 'size'),\n})\nconst computedAttrs = getGroupAttr(classesObject)\nconst computedClasses = getGroupClasses(classesObject)\n\n// TODO: make tests compatible with the v-focus directive\n</script>\n","<template>\n  <option :value=\"value\" :disabled=\"disabledBoolean\">\n    <slot />\n  </option>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormSelectOptionProps} from '../../types/components'\nimport {toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish} from '../../types'\n\ninterface BFormSelectOptionProps {\n  value?: unknown\n  disabled?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BFormSelectOptionProps>(), {\n  disabled: false,\n})\n\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n</script>\n","<template>\n  <optgroup :label=\"label\">\n    <slot name=\"first\" />\n    <!-- eslint-disable vue/no-v-text-v-html-on-component -->\n    <!-- eslint-disable vue/no-v-html -->\n    <!-- TODO these options don't seem right for the component -->\n    <b-form-select-option\n      v-for=\"(option, index) in formOptions\"\n      :key=\"index\"\n      :value=\"option.value\"\n      :disabled=\"option.disabled\"\n      v-bind=\"$attrs\"\n      v-html=\"option.html || option.text\"\n    />\n    <!--eslint-enable-->\n    <slot />\n  </optgroup>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormSelectOptionGroupProps} from '../../types/components'\nimport {computed} from 'vue'\nimport BFormSelectOption from './BFormSelectOption.vue'\nimport {normalizeOptions} from '../../composables'\n\ninterface BFormSelectOptionGroupProps {\n  label?: string\n  disabledField?: string\n  htmlField?: string\n  options?: Array<unknown> | Record<string, unknown>\n  textField?: string\n  valueField?: string\n}\n\nconst props = withDefaults(defineProps<BFormSelectOptionGroupProps>(), {\n  disabledField: 'disabled',\n  htmlField: 'html',\n  options: () => [],\n  textField: 'text',\n  valueField: 'value',\n})\n\nconst formOptions = computed(() =>\n  normalizeOptions(props.options as Array<any>, 'BFormSelectOptionGroup', props)\n)\n</script>\n","<template>\n  <select\n    :id=\"computedId\"\n    ref=\"input\"\n    v-bind=\"$attrs\"\n    v-model=\"localValue\"\n    :class=\"computedClasses\"\n    :name=\"name\"\n    :form=\"form || undefined\"\n    :multiple=\"multipleBoolean || undefined\"\n    :size=\"computedSelectSize\"\n    :disabled=\"disabledBoolean\"\n    :required=\"requiredBoolean\"\n    :aria-required=\"requiredBoolean ? true : undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n  >\n    <slot name=\"first\" />\n    <template v-for=\"(option, index) in formOptions\" :key=\"index\">\n      <b-form-select-option-group\n        v-if=\"Array.isArray(option.options)\"\n        :label=\"option.label\"\n        :options=\"option.options\"\n      />\n      <!-- eslint-disable vue/no-v-text-v-html-on-component -->\n      <!-- eslint-disable vue/no-v-html -->\n      <b-form-select-option\n        v-else\n        :value=\"option.value\"\n        :disabled=\"option.disabled\"\n        v-html=\"option.html || option.text\"\n      />\n      <!--eslint-enable-->\n    </template>\n    <slot />\n  </select>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormSelectEmits, BFormSelectProps} from '../types/components'\nimport {resolveAriaInvalid} from '../../utils'\nimport type {AriaInvalid, Booleanish, Size} from '../../types'\nimport {computed, nextTick, onActivated, onMounted, ref, toRef} from 'vue'\nimport BFormSelectOption from './BFormSelectOption.vue'\nimport BFormSelectOptionGroup from './BFormSelectOptionGroup.vue'\nimport {normalizeOptions, useBooleanish, useId} from '../../composables'\n\ninterface BFormSelectProps {\n  ariaInvalid?: AriaInvalid\n  autofocus?: Booleanish\n  disabled?: Booleanish\n  disabledField?: string\n  form?: string\n  htmlField?: string\n  id?: string\n  labelField?: string\n  multiple?: Booleanish\n  name?: string\n  options?: Array<unknown> | Record<string, unknown>\n  optionsField?: string\n  plain?: Booleanish\n  required?: Booleanish\n  selectSize?: number\n  size?: Size\n  state?: Booleanish\n  textField?: string\n  valueField?: string\n  modelValue?: string | Array<unknown> | Record<string, unknown> | number\n}\n\nconst props = withDefaults(defineProps<BFormSelectProps>(), {\n  ariaInvalid: undefined,\n  autofocus: false,\n  disabled: false,\n  disabledField: 'disabled',\n  htmlField: 'html',\n  state: undefined,\n  labelField: 'label',\n  multiple: false,\n  options: () => [],\n  optionsField: 'options',\n  plain: false,\n  required: false,\n  selectSize: 0,\n  textField: 'text',\n  valueField: 'value',\n  modelValue: '',\n})\n\ninterface BFormSelectEmits {\n  (e: 'input', value: unknown): void\n  (e: 'update:modelValue', value: unknown): void\n  (e: 'change', value: unknown): void\n}\n\nconst emit = defineEmits<BFormSelectEmits>()\n\nconst computedId = useId(toRef(props, 'id'), 'input')\n\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst multipleBoolean = useBooleanish(toRef(props, 'multiple'))\nconst plainBoolean = useBooleanish(toRef(props, 'plain'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\n\nconst input = ref<HTMLElement>()\n\nconst computedClasses = computed(() => ({\n  'form-control': plainBoolean.value,\n  [`form-control-${props.size}`]: props.size && plainBoolean.value,\n  'form-select': !plainBoolean.value,\n  [`form-select-${props.size}`]: props.size && !plainBoolean.value,\n  'is-valid': stateBoolean.value === true,\n  'is-invalid': stateBoolean.value === false,\n}))\n\nconst computedSelectSize = computed<number | undefined>(() => {\n  if (props.selectSize || plainBoolean.value) {\n    return props.selectSize\n  }\n  return undefined\n})\n\nconst computedAriaInvalid = computed(() =>\n  resolveAriaInvalid(props.ariaInvalid, stateBoolean.value)\n)\n\nconst formOptions = computed(() =>\n  normalizeOptions(props.options as Array<any>, 'BFormSelect', props)\n)\nconst localValue = computed({\n  get() {\n    return props.modelValue\n  },\n  set(newValue: any) {\n    emit('change', newValue)\n    emit('update:modelValue', newValue)\n    emit('input', newValue)\n  },\n})\n\nconst focus = () => {\n  if (!disabledBoolean.value) input.value?.focus()\n}\n\nconst blur = () => {\n  if (!disabledBoolean.value) {\n    input.value?.blur()\n  }\n}\n\nconst handleAutofocus = () => {\n  nextTick(() => {\n    if (autofocusBoolean.value) input.value?.focus()\n  })\n}\n\nonMounted(handleAutofocus)\nonActivated(handleAutofocus)\n\ndefineExpose({\n  blur,\n  focus,\n})\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"computedId\"\n    :title=\"tagText\"\n    class=\"badge b-form-tag d-inline-flex align-items-center mw-100\"\n    :class=\"computedClasses\"\n    :aria-labelledby=\"taglabelId\"\n  >\n    <span :id=\"taglabelId\" class=\"b-form-tag-content flex-grow-1 text-truncate\">\n      <slot>{{ tagText }}</slot>\n    </span>\n    <b-close-button\n      v-if=\"!disabledBoolean && !noRemoveBoolean\"\n      aria-keyshortcuts=\"Delete\"\n      :aria-label=\"removeLabel\"\n      class=\"b-form-tag-remove\"\n      :white=\"!['warning', 'info', 'light'].includes(variant)\"\n      :aria-describedby=\"taglabelId\"\n      :aria-controls=\"id\"\n      @click=\"emit('remove', tagText)\"\n    />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormTagEmits, BFormTagProps} from '../../types/components'\nimport {computed, toRef, useSlots, VNodeNormalizedChildren} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport BCloseButton from '../BButton/BCloseButton.vue'\n\ninterface BFormTagProps {\n  id?: string\n  title?: string\n  disabled?: Booleanish\n  noRemove?: Booleanish\n  pill?: Booleanish\n  removeLabel?: string\n  tag?: string\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BFormTagProps>(), {\n  disabled: false,\n  noRemove: false,\n  pill: false,\n  removeLabel: 'Remove tag',\n  tag: 'span',\n  variant: 'secondary',\n})\n\ninterface BFormTagEmits {\n  (e: 'remove', value?: VNodeNormalizedChildren): void\n}\n\nconst emit = defineEmits<BFormTagEmits>()\n\nconst slots = useSlots()\n\nconst computedId = useId(toRef(props, 'id'))\n\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst noRemoveBoolean = useBooleanish(toRef(props, 'noRemove'))\nconst pillBoolean = useBooleanish(toRef(props, 'pill'))\n\nconst tagText = computed<string>(\n  () => ((slots.default?.()[0].children ?? '').toString() || props.title) ?? ''\n)\n\nconst taglabelId = computed<string>(() => `${computedId.value}taglabel__`)\n\nconst computedClasses = computed(() => [\n  `bg-${props.variant}`,\n  {\n    'text-dark': ['warning', 'info', 'light'].includes(props.variant),\n    'rounded-pill': pillBoolean.value,\n    'disabled': disabledBoolean.value,\n  },\n])\n</script>\n","<template>\n  <div\n    :id=\"computedId\"\n    class=\"b-form-tags form-control h-auto\"\n    :class=\"computedClasses\"\n    role=\"group\"\n    tabindex=\"-1\"\n    @focusin=\"onFocusin\"\n    @focusout=\"emit('focusout', $event)\"\n  >\n    <output\n      :id=\"`${computedId}selected_tags__`\"\n      class=\"visually-hidden\"\n      role=\"status\"\n      :for=\"_inputId\"\n      :aria-live=\"focus ? 'polite' : 'off'\"\n      aria-atomic=\"true\"\n      aria-relevant=\"additions text\"\n      >{{ tags.join(', ') }}</output\n    >\n    <div\n      :id=\"`${computedId}removed_tags__`\"\n      role=\"status\"\n      :aria-live=\"focus ? 'assertive' : 'off'\"\n      aria-atomic=\"true\"\n      class=\"visually-hidden\"\n    >\n      ({{ tagRemovedLabel }}) {{ lastRemovedTag }}\n    </div>\n\n    <slot v-bind=\"slotAttrs\">\n      <ul\n        :id=\"`${computedId}tag_list__`\"\n        class=\"b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center\"\n      >\n        <template v-for=\"(tag, index) in tags\" :key=\"index\">\n          <slot\n            name=\"tag\"\n            v-bind=\"{tag, tagClass, tagVariant, tagPills: tagPillsBoolean, removeTag}\"\n          >\n            <b-form-tag\n              :class=\"tagClass\"\n              tag=\"li\"\n              :variant=\"tagVariant\"\n              :pill=\"tagPills\"\n              @remove=\"removeTag\"\n              >{{ tag }}</b-form-tag\n            >\n          </slot>\n        </template>\n        <li\n          role=\"none\"\n          aria-live=\"off\"\n          class=\"b-from-tags-field flex-grow-1\"\n          :aria-controls=\"`${computedId}tag_list__`\"\n        >\n          <div role=\"group\" class=\"d-flex\">\n            <input\n              :id=\"_inputId\"\n              ref=\"input\"\n              :disabled=\"disabledBoolean\"\n              :value=\"inputValue\"\n              :type=\"inputType\"\n              :placeholder=\"placeholder\"\n              class=\"b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0\"\n              style=\"outline: currentcolor none 0px; min-width: 5rem\"\n              v-bind=\"inputAttrs\"\n              :form=\"form\"\n              :required=\"requiredBoolean\"\n              @input=\"onInput\"\n              @change=\"onChange\"\n              @keydown=\"onKeydown\"\n              @focus=\"onFocus\"\n              @blur=\"onBlur\"\n            />\n            <button\n              v-if=\"disableAddButton\"\n              type=\"button\"\n              class=\"btn b-form-tags-button py-0\"\n              :class=\"[\n                `btn-${addButtonVariant}`,\n                {\n                  'disabled invisible': inputValue.length === 0,\n                },\n                inputClass,\n              ]\"\n              style=\"font-size: 90%\"\n              :disabled=\"disabledBoolean || inputValue.length === 0 || isLimitReached\"\n              @click=\"addTag(inputValue)\"\n            >\n              <slot name=\"add-button-text\">{{ addButtonText }}</slot>\n            </button>\n          </div>\n        </li>\n      </ul>\n      <div aria-live=\"polite\" aria-atomic=\"true\">\n        <div v-if=\"isInvalid\" class=\"d-block invalid-feedback\">\n          {{ invalidTagText }}: {{ inputValue }}\n        </div>\n        <small v-if=\"isDuplicate\" class=\"form-text text-muted\"\n          >{{ duplicateTagText }}: {{ inputValue }}</small\n        >\n        <small v-if=\"tags.length === limit\" class=\"form-text text-muted\">Tag limit reached</small>\n      </div>\n    </slot>\n    <template v-if=\"name\">\n      <input v-for=\"(tag, index) in tags\" :key=\"index\" type=\"hidden\" :name=\"name\" :value=\"tag\" />\n    </template>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormTagsEmits, BFormTagsProps} from '../types/components'\nimport {computed, onActivated, onMounted, ref, toRef, VNodeNormalizedChildren, watch} from 'vue'\nimport BFormTag from './BFormTag.vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {\n  Booleanish,\n  ButtonVariant,\n  ClassValue,\n  ColorVariant,\n  InputSize,\n  InputType,\n} from '../../types'\n\ninterface BFormTagsProps {\n  addButtonText?: string\n  addButtonVariant?: ButtonVariant\n  addOnChange?: Booleanish\n  autofocus?: Booleanish\n  disabled?: Booleanish\n  duplicateTagText?: string\n  inputAttrs?: Record<string, unknown>\n  inputClass?: ClassValue\n  inputId?: string\n  inputType?: InputType\n  invalidTagText?: string\n  form?: string\n  limit?: number\n  limitTagsText?: string\n  modelValue?: Array<string>\n  name?: string\n  noAddOnEnter?: Booleanish\n  noOuterFocus?: Booleanish\n  noTagRemove?: Booleanish\n  placeholder?: string\n  removeOnDelete?: Booleanish\n  required?: Booleanish\n  separator?: string | Array<unknown>\n  state?: Booleanish\n  size?: InputSize\n  tagClass?: ClassValue\n  tagPills?: Booleanish\n  tagRemoveLabel?: string\n  tagRemovedLabel?: string\n  tagValidator?: (t: string) => boolean\n  tagVariant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BFormTagsProps>(), {\n  addButtonText: 'Add',\n  addButtonVariant: 'outline-secondary',\n  addOnChange: false,\n  autofocus: false,\n  disabled: false,\n  duplicateTagText: 'Duplicate tag(s)',\n  inputType: 'text',\n  invalidTagText: 'Invalid tag(s)',\n  limitTagsText: 'Tag limit reached',\n  modelValue: () => [],\n  noAddOnEnter: false,\n  noOuterFocus: false,\n  noTagRemove: false,\n  placeholder: 'Add tag...',\n  removeOnDelete: false,\n  required: false,\n  state: undefined,\n  tagPills: false,\n  tagRemovedLabel: 'Tag removed',\n  tagValidator: () => true,\n  tagVariant: 'secondary',\n})\n\ninterface BFormTagsEmits {\n  (e: 'update:modelValue', value: Array<string>): void\n  (e: 'input', value: Array<string>): void\n  (e: 'tag-state', ...args: Array<Array<string>>): void\n  (e: 'focus', value: FocusEvent): void\n  (e: 'focusin', value: FocusEvent): void\n  (e: 'focusout', value: FocusEvent): void\n  (e: 'blur', value: FocusEvent): void\n}\n\nconst emit = defineEmits<BFormTagsEmits>()\n\nconst computedId = useId()\n\nconst addOnChangeBoolean = useBooleanish(toRef(props, 'addOnChange'))\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst noAddOnEnterBoolean = useBooleanish(toRef(props, 'noAddOnEnter'))\nconst noOuterFocusBoolean = useBooleanish(toRef(props, 'noOuterFocus'))\nconst noTagRemoveBoolean = useBooleanish(toRef(props, 'noTagRemove'))\nconst removeOnDeleteBoolean = useBooleanish(toRef(props, 'removeOnDelete'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\nconst tagPillsBoolean = useBooleanish(toRef(props, 'tagPills'))\n\nconst input = ref<HTMLInputElement | null>(null)\nconst _inputId = computed<string>(() => props.inputId || `${computedId.value}input__`)\nconst tags = ref<Array<string>>(props.modelValue)\nconst inputValue = ref<string>('')\nconst shouldRemoveOnDelete = ref<boolean>(false)\nconst focus = ref<boolean>(false)\nconst lastRemovedTag = ref<string>('')\nconst validTags = ref<Array<string>>([])\nconst invalidTags = ref<Array<string>>([])\nconst duplicateTags = ref<Array<string>>([])\n\nconst computedClasses = computed(() => ({\n  [`form-control-${props.size}`]: props.size !== undefined,\n  'disabled': disabledBoolean.value,\n  'focus': focus.value,\n  'is-invalid': stateBoolean.value === false,\n  'is-valid': stateBoolean.value === true,\n}))\n\nconst isDuplicate = computed<boolean>(() => tags.value.includes(inputValue.value))\n\nconst isInvalid = computed<boolean>(() =>\n  inputValue.value === '' ? false : !props.tagValidator(inputValue.value)\n)\nconst isLimitReached = computed<boolean>(() => tags.value.length === props.limit)\n\nconst disableAddButton = computed<boolean>(() => !isInvalid.value && !isDuplicate.value)\n\nconst slotAttrs = computed(() => ({\n  addButtonText: props.addButtonText,\n  addButtonVariant: props.addButtonVariant,\n  addTag,\n  disableAddButton: disableAddButton.value,\n  disabled: disabledBoolean.value,\n  duplicateTagText: props.duplicateTagText,\n  duplicateTags: duplicateTags.value,\n  form: props.form,\n  inputAttrs: {\n    ...props.inputAttrs,\n    disabled: disabledBoolean.value,\n    form: props.form,\n    id: _inputId,\n    value: inputValue,\n  },\n  inputHandlers: {\n    input: onInput,\n    keydown: onKeydown,\n    change: onChange,\n  },\n  inputId: _inputId,\n  inputType: props.inputType,\n  invalidTagText: props.invalidTagText,\n  invalidTags: invalidTags.value,\n  isDuplicate: isDuplicate.value,\n  isInvalid: isInvalid.value,\n  isLimitReached: isLimitReached.value,\n  limitTagsText: props.limitTagsText,\n  limit: props.limit,\n  noTagRemove: noTagRemoveBoolean.value,\n  placeholder: props.placeholder,\n  removeTag,\n  required: requiredBoolean.value,\n  separator: props.separator,\n  size: props.size,\n  state: stateBoolean.value,\n  tagClass: props.tagClass,\n  tagPills: tagPillsBoolean.value,\n  tagRemoveLabel: props.tagRemoveLabel,\n  tagVariant: props.tagVariant,\n  tags: tags.value,\n}))\n\nwatch(\n  () => props.modelValue,\n  (newVal) => {\n    tags.value = newVal\n  }\n)\n\nconst checkAutofocus = () => {\n  if (autofocusBoolean.value) {\n    input.value?.focus()\n  }\n}\n\nconst onFocusin = (e: FocusEvent): void => {\n  if (disabledBoolean.value) {\n    const target = e.target as HTMLDivElement\n    target.blur()\n    return\n  }\n\n  emit('focusin', e)\n}\n\nconst onFocus = (e: FocusEvent): void => {\n  if (disabledBoolean.value || noOuterFocusBoolean.value) {\n    return\n  }\n\n  focus.value = true\n  emit('focus', e)\n}\n\nconst onBlur = (e: FocusEvent): void => {\n  focus.value = false\n  emit('blur', e)\n}\n\nconst onInput = (e: Event | string): void => {\n  const value = typeof e === 'string' ? e : (e.target as HTMLInputElement).value\n\n  shouldRemoveOnDelete.value = false\n\n  if (props.separator?.includes(value.charAt(0)) && value.length > 0) {\n    if (input.value) {\n      input.value.value = ''\n    }\n    return\n  }\n\n  inputValue.value = value\n\n  if (props.separator?.includes(value.charAt(value.length - 1))) {\n    addTag(value.slice(0, value.length - 1))\n    return\n  }\n\n  validTags.value = props.tagValidator(value) && !isDuplicate.value ? [value] : []\n  invalidTags.value = props.tagValidator(value) ? [] : [value]\n  duplicateTags.value = isDuplicate.value ? [value] : []\n\n  emit('tag-state', validTags.value, invalidTags.value, duplicateTags.value)\n}\n\nconst onChange = (e: Event): void => {\n  if (addOnChangeBoolean.value) {\n    onInput(e)\n\n    if (!isDuplicate.value) {\n      addTag(inputValue.value)\n    }\n  }\n}\n\nconst onKeydown = (e: KeyboardEvent): void => {\n  if (e.key === 'Enter' && !noAddOnEnterBoolean.value) {\n    addTag(inputValue.value)\n    return\n  }\n\n  if (\n    (e.key === 'Backspace' || e.key === 'Delete') &&\n    removeOnDeleteBoolean.value &&\n    inputValue.value === '' &&\n    shouldRemoveOnDelete.value &&\n    tags.value.length > 0\n  ) {\n    removeTag(tags.value[tags.value.length - 1])\n  } else {\n    shouldRemoveOnDelete.value = true\n  }\n}\n\nconst addTag = (tag?: string): void => {\n  tag = (tag || inputValue.value).trim()\n\n  if (\n    tag === '' ||\n    isDuplicate.value ||\n    !props.tagValidator(tag) ||\n    (props.limit && isLimitReached.value)\n  ) {\n    return\n  }\n\n  const newValue = [...props.modelValue, tag]\n  inputValue.value = ''\n  shouldRemoveOnDelete.value = true\n  emit('update:modelValue', newValue)\n  emit('input', newValue)\n  input.value?.focus()\n}\n\nconst removeTag = (tag?: VNodeNormalizedChildren): void => {\n  const tagIndex = tags.value.indexOf(tag?.toString() ?? '')\n  lastRemovedTag.value = tags.value.splice(tagIndex, 1).toString()\n\n  emit('update:modelValue', tags.value)\n}\n\nonMounted(() => {\n  checkAutofocus()\n\n  if (props.modelValue.length > 0) {\n    shouldRemoveOnDelete.value = true\n  }\n})\n\nonActivated(() => checkAutofocus())\n</script>\n","<template>\n  <textarea\n    :id=\"computedId\"\n    ref=\"input\"\n    :class=\"computedClasses\"\n    :name=\"name || undefined\"\n    :form=\"form || undefined\"\n    :disabled=\"disabled\"\n    :placeholder=\"placeholder\"\n    :required=\"required\"\n    :autocomplete=\"autocomplete || undefined\"\n    :readonly=\"readonly || plaintext\"\n    :aria-required=\"required ? 'true' : undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    :rows=\"rows\"\n    :style=\"computedStyles\"\n    :wrap=\"wrap || undefined\"\n    v-bind=\"$attrs\"\n    @input=\"onInput($event)\"\n    @change=\"onChange($event)\"\n    @blur=\"onBlur($event)\"\n  />\n</template>\n\n<script lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {computed, defineComponent, type PropType, type StyleValue, toRef} from 'vue'\nimport {COMMON_INPUT_PROPS, useBooleanish, useFormInput} from '../../composables'\n\nexport default defineComponent({\n  props: {\n    ...COMMON_INPUT_PROPS,\n    noResize: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    rows: {type: [String, Number], required: false, default: 2},\n    wrap: {type: String, default: 'soft'},\n  },\n  emits: ['update:modelValue', 'change', 'blur', 'input'],\n  setup(props, {emit}) {\n    const {input, computedId, computedAriaInvalid, onInput, onChange, onBlur, focus, blur} =\n      useFormInput(props, emit)\n\n    const noResizeBoolean = useBooleanish(toRef(props, 'noResize'))\n\n    const computedClasses = computed(() => ({\n      'form-control': !props.plaintext,\n      'form-control-plaintext': props.plaintext,\n      [`form-control-${props.size}`]: !!props.size,\n      'is-valid': props.state === true,\n      'is-invalid': props.state === false,\n    }))\n\n    const computedStyles = computed<StyleValue | undefined>(() =>\n      noResizeBoolean.value ? {resize: 'none'} : undefined\n    )\n\n    return {\n      input,\n      computedId,\n      computedAriaInvalid,\n      onInput,\n      onChange,\n      onBlur,\n      focus,\n      blur,\n      computedClasses,\n      computedStyles,\n    }\n  },\n})\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" class=\"input-group\" :class=\"computedClasses\" role=\"group\">\n    <slot name=\"prepend\">\n      <span v-if=\"hasPrepend\" class=\"input-group-text\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"!!prependHtml\" v-html=\"prependHtml\" />\n        <span v-else>{{ prepend }}</span>\n      </span>\n    </slot>\n    <slot />\n    <slot name=\"append\">\n      <span v-if=\"hasAppend\" class=\"input-group-text\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"!!appendHtml\" v-html=\"appendHtml\" />\n        <span v-else>{{ append }}</span>\n      </span>\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {InputSize} from '../../types'\nimport {computed} from 'vue'\n\ninterface BInputGroupProps {\n  append?: string\n  appendHtml?: string\n  id?: string\n  prepend?: string\n  prependHtml?: string\n  size?: 'sm' | 'lg' // Exclude<InputSize, 'md'>\n  tag?: string\n}\n\nconst props = withDefaults(defineProps<BInputGroupProps>(), {\n  tag: 'div',\n})\n\nconst computedClasses = computed(() => ({\n  'input-group-sm': props.size === 'sm',\n  'input-group-lg': props.size === 'lg',\n}))\n\nconst hasAppend = computed<boolean>(() => !!props.append || !!props.appendHtml)\nconst hasPrepend = computed<boolean>(() => !!props.prepend || !!props.prependHtml)\n</script>\n","<template>\n  <b-input-group-text v-if=\"isTextBoolean\">\n    <slot />\n  </b-input-group-text>\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BInputGroupAddonProps} from '../../types/components'\nimport {toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish} from '../../types'\nimport BInputGroupText from './BInputGroupText.vue'\n\ninterface BInputGroupAddonProps {\n  isText?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BInputGroupAddonProps>(), {\n  isText: false,\n})\n\nconst isTextBoolean = useBooleanish(toRef(props, 'isText'))\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"list-group\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BListGroupProps} from '../../types/components'\nimport {computed, InjectionKey, provide, toRef} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n// import type {Breakpoint} from '../../types'\n\ninterface BListGroupProps {\n  flush?: Booleanish\n  horizontal?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'\n  numbered?: Booleanish\n  tag?: string\n}\n\nconst props = withDefaults(defineProps<BListGroupProps>(), {\n  flush: false,\n  horizontal: false,\n  numbered: false,\n  tag: 'div',\n})\n\nconst flushBoolean = useBooleanish(toRef(props, 'flush'))\nconst numberedBoolean = useBooleanish(toRef(props, 'numbered'))\n\nconst computedClasses = computed(() => {\n  const horizontal = flushBoolean.value ? false : props.horizontal\n  return {\n    'list-group-flush': flushBoolean.value,\n    'list-group-horizontal': horizontal === true,\n    [`list-group-horizontal-${horizontal}`]: typeof horizontal === 'string',\n    'list-group-numbered': numberedBoolean.value,\n  }\n})\n\nconst computedTag = computed<string>(() => (numberedBoolean.value === true ? 'ol' : props.tag))\n\nprovide(injectionKey, {\n  numbered: numberedBoolean.value,\n})\n</script>\n\n<script lang=\"ts\">\nimport type {BListGroupParentData} from '../../types/components'\nexport const injectionKey: InjectionKey<BListGroupParentData> = Symbol()\n</script>\n","<template>\n  <component\n    :is=\"tagComputed\"\n    class=\"list-group-item\"\n    :class=\"computedClasses\"\n    :aria-current=\"activeBoolean ? true : undefined\"\n    :aria-disabled=\"disabledBoolean ? true : undefined\"\n    :target=\"link ? target : undefined\"\n    :href=\"!buttonBoolean ? href : undefined\"\n    :to=\"!buttonBoolean ? to : undefined\"\n    v-bind=\"computedAttrs\"\n  >\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BListGroupItemProps} from '../../types/components'\nimport {computed, inject, toRef, useAttrs} from 'vue'\nimport type {RouteLocationRaw} from 'vue-router'\nimport type {Booleanish, ColorVariant, LinkTarget} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BLink from '../BLink/BLink.vue'\nimport {injectionKey} from './BListGroup.vue'\n\ninterface BListGroupItemProps {\n  action?: Booleanish\n  active?: Booleanish\n  // activeClass?: string\n  // append?: Booleanish\n  button?: Booleanish\n  disabled?: Booleanish\n  // exact?: Booleanish\n  // exactActiveClass?: string\n  href?: string\n  // noPrefetch?: Booleanish\n  // prefetch?: Booleanish\n  // rel?: String\n  // replace?: Booleanish\n  // routerComponentName?: String\n  tag?: string\n  target?: LinkTarget\n  to?: RouteLocationRaw\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BListGroupItemProps>(), {\n  action: false,\n  active: false,\n  button: false,\n  disabled: false,\n  tag: 'div',\n  target: '_self',\n})\n\nconst attrs = useAttrs()\n\nconst parentData = inject(injectionKey, null)\n\nconst actionBoolean = useBooleanish(toRef(props, 'action'))\nconst activeBoolean = useBooleanish(toRef(props, 'active'))\nconst buttonBoolean = useBooleanish(toRef(props, 'button'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\nconst link = computed<boolean>(() => !buttonBoolean.value && (!!props.href || !!props.to))\n\nconst tagComputed = computed<string | typeof BLink>(() =>\n  parentData?.numbered ? 'li' : buttonBoolean.value ? 'button' : !link.value ? props.tag : BLink\n)\n\nconst isAction = computed(\n  () =>\n    actionBoolean.value ||\n    link.value ||\n    buttonBoolean.value ||\n    ['a', 'router-link', 'button', 'b-link'].includes(props.tag)\n)\n\nconst computedClasses = computed(() => ({\n  [`list-group-item-${props.variant}`]: props.variant !== undefined,\n  'list-group-item-action': isAction.value,\n  'active': activeBoolean.value,\n  'disabled': disabledBoolean.value,\n}))\n\nconst computedAttrs = computed(() => {\n  const localAttrs = {} as {type?: string; disabled?: boolean}\n  if (buttonBoolean.value) {\n    if (!attrs || !attrs.type) {\n      // Add a type for button is one not provided in passed attributes\n      localAttrs.type = 'button'\n    }\n    if (disabledBoolean.value) {\n      // Set disabled attribute if button and disabled\n      localAttrs.disabled = true\n    }\n  }\n  return localAttrs\n})\n</script>\n","<template>\n  <teleport to=\"body\" :disabled=\"staticBoolean\">\n    <b-transition\n      :no-fade=\"true\"\n      :trans-props=\"{enterToClass: 'show'}\"\n      @before-enter=\"onBeforeEnter\"\n      @after-enter=\"onAfterEnter\"\n      @leave=\"onLeave\"\n      @after-leave=\"onAfterLeave\"\n    >\n      <div\n        v-show=\"modelValueBoolean\"\n        :id=\"computedId\"\n        ref=\"element\"\n        class=\"modal\"\n        :class=\"modalClasses\"\n        role=\"dialog\"\n        :aria-labelledby=\"`${computedId}-label`\"\n        :aria-describedby=\"`${computedId}-body`\"\n        tabindex=\"-1\"\n        v-bind=\"$attrs\"\n        @keyup.esc=\"hide('esc')\"\n      >\n        <div class=\"modal-dialog\" :class=\"modalDialogClasses\">\n          <div\n            v-if=\"\n              !lazyBoolean ||\n              (lazyBoolean && lazyLoadCompleted) ||\n              (lazyBoolean && modelValueBoolean === true)\n            \"\n            class=\"modal-content\"\n            :class=\"contentClass\"\n          >\n            <div v-if=\"!hideHeaderBoolean\" class=\"modal-header\" :class=\"headerClasses\">\n              <slot name=\"header\">\n                <component\n                  :is=\"titleTag\"\n                  :id=\"`${computedId}-label`\"\n                  class=\"modal-title\"\n                  :class=\"titleClasses\"\n                >\n                  <slot name=\"title\">\n                    {{ title }}\n                  </slot>\n                </component>\n                <template v-if=\"!hideHeaderCloseBoolean\">\n                  <button v-if=\"hasHeaderCloseSlot\" type=\"button\" @click=\"hide('close')\">\n                    <slot name=\"header-close\" />\n                  </button>\n                  <b-close-button\n                    v-else\n                    :aria-label=\"headerCloseLabel\"\n                    :white=\"headerCloseWhite\"\n                    @click=\"hide('close')\"\n                  />\n                </template>\n              </slot>\n            </div>\n            <div :id=\"`${computedId}-body`\" class=\"modal-body\" :class=\"bodyClasses\">\n              <slot />\n            </div>\n            <div v-if=\"!hideFooterBoolean\" class=\"modal-footer\" :class=\"footerClasses\">\n              <slot name=\"footer\">\n                <slot name=\"cancel\">\n                  <b-button\n                    v-if=\"!okOnlyBoolean\"\n                    type=\"button\"\n                    class=\"btn\"\n                    :disabled=\"disableCancel\"\n                    :size=\"buttonSize\"\n                    :variant=\"cancelVariant\"\n                    @click=\"hide('cancel')\"\n                  >\n                    {{ cancelTitle }}\n                  </b-button>\n                </slot>\n                <slot name=\"ok\">\n                  <b-button\n                    type=\"button\"\n                    class=\"btn\"\n                    :disabled=\"disableOk\"\n                    :size=\"buttonSize\"\n                    :variant=\"okVariant\"\n                    @click=\"hide('ok')\"\n                  >\n                    {{ okTitle }}\n                  </b-button>\n                </slot>\n              </slot>\n            </div>\n          </div>\n        </div>\n        <slot v-if=\"!hideBackdropBoolean\" name=\"backdrop\">\n          <div class=\"modal-backdrop fade show\" @click=\"hide('backdrop')\" />\n        </slot>\n      </div>\n    </b-transition>\n  </teleport>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BModalEmits, BModalProps} from '../types/components'\nimport {computed, nextTick, ref, toRef, useSlots, watch} from 'vue'\nimport {useBooleanish, useId} from '../composables'\nimport type {Booleanish, ClassValue, ColorVariant, InputSize} from '../types'\nimport {BvModalEvent, isEmptySlot} from '../utils'\nimport BButton from './BButton/BButton.vue'\nimport BCloseButton from './BButton/BCloseButton.vue'\nimport BTransition from './BTransition/BTransition.vue'\n\n// aria\n// autofocus\n// close on escape when autofocus\n\n// Note, attempt to return focus to item that openned the modal after close\n// Implement auto focus props like autoFocusButton\n\ninterface BModalProps {\n  bodyBgVariant?: ColorVariant\n  bodyClass?: ClassValue\n  bodyTextVariant?: ColorVariant\n  busy?: Booleanish\n  lazy?: Booleanish\n  buttonSize?: InputSize\n  cancelDisabled?: Booleanish\n  cancelTitle?: string\n  cancelVariant?: ColorVariant\n  centered?: Booleanish\n  contentClass?: ClassValue\n  dialogClass?: ClassValue\n  footerBgVariant?: ColorVariant\n  footerBorderVariant?: ColorVariant\n  footerClass?: ClassValue\n  footerTextVariant?: ColorVariant\n  fullscreen?: boolean | string\n  headerBgVariant?: ColorVariant\n  headerBorderVariant?: ColorVariant\n  headerClass?: ClassValue\n  headerCloseLabel?: string\n  headerCloseWhite?: Booleanish\n  headerTextVariant?: ColorVariant\n  hideBackdrop?: Booleanish\n  hideFooter?: Booleanish\n  hideHeader?: Booleanish\n  hideHeaderClose?: Booleanish\n  id?: string\n  modalClass?: ClassValue\n  modelValue?: Booleanish\n  noCloseOnBackdrop?: Booleanish\n  noCloseOnEsc?: Booleanish\n  noFade?: Booleanish\n  noFocus?: Booleanish\n  okDisabled?: Booleanish\n  okOnly?: Booleanish\n  okTitle?: string\n  okVariant?: ColorVariant\n  scrollable?: Booleanish\n  show?: Booleanish\n  size?: 'sm' | 'lg' | 'xl'\n  title?: string\n  titleClass?: string\n  titleSrOnly?: Booleanish\n  titleTag?: string\n  static?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BModalProps>(), {\n  busy: false,\n  lazy: false,\n  buttonSize: 'md',\n  cancelDisabled: false,\n  cancelTitle: 'Cancel',\n  cancelVariant: 'secondary',\n  centered: false,\n  fullscreen: false,\n  headerCloseLabel: 'Close',\n  headerCloseWhite: false,\n  hideBackdrop: false,\n  hideFooter: false,\n  hideHeader: false,\n  hideHeaderClose: false,\n  modelValue: false,\n  noCloseOnBackdrop: false,\n  noCloseOnEsc: false,\n  noFade: false,\n  noFocus: false,\n  okDisabled: false,\n  okOnly: false,\n  okTitle: 'Ok',\n  static: false,\n  okVariant: 'primary',\n  scrollable: false,\n  show: false,\n  titleSrOnly: false,\n  titleTag: 'h5',\n})\n\ninterface BModalEmits {\n  (e: 'update:modelValue', value: boolean): void\n  (e: 'show', value: BvModalEvent): void\n  (e: 'shown', value: BvModalEvent): void\n  (e: 'hide', value: BvModalEvent): void\n  (e: 'hidden', value: BvModalEvent): void\n  (e: 'hide-prevented'): void\n  (e: 'show-prevented'): void\n  (e: 'ok', value: BvModalEvent): void\n  (e: 'cancel', value: BvModalEvent): void\n  (e: 'close', value: BvModalEvent): void\n}\n\nconst emit = defineEmits<BModalEmits>()\n\nconst slots = useSlots()\n\nconst computedId = useId(toRef(props, 'id'), 'modal')\n\nconst busyBoolean = useBooleanish(toRef(props, 'busy'))\nconst lazyBoolean = useBooleanish(toRef(props, 'lazy'))\nconst cancelDisabledBoolean = useBooleanish(toRef(props, 'cancelDisabled'))\nconst centeredBoolean = useBooleanish(toRef(props, 'centered'))\nconst hideBackdropBoolean = useBooleanish(toRef(props, 'hideBackdrop'))\nconst hideFooterBoolean = useBooleanish(toRef(props, 'hideFooter'))\nconst hideHeaderBoolean = useBooleanish(toRef(props, 'hideHeader'))\nconst hideHeaderCloseBoolean = useBooleanish(toRef(props, 'hideHeaderClose'))\nconst modelValueBoolean = useBooleanish(toRef(props, 'modelValue'))\nconst noCloseOnBackdropBoolean = useBooleanish(toRef(props, 'noCloseOnBackdrop'))\nconst noCloseOnEscBoolean = useBooleanish(toRef(props, 'noCloseOnEsc'))\nconst noFadeBoolean = useBooleanish(toRef(props, 'noFade'))\nconst noFocusBoolean = useBooleanish(toRef(props, 'noFocus'))\nconst okDisabledBoolean = useBooleanish(toRef(props, 'okDisabled'))\nconst okOnlyBoolean = useBooleanish(toRef(props, 'okOnly'))\nconst scrollableBoolean = useBooleanish(toRef(props, 'scrollable'))\nconst titleSrOnlyBoolean = useBooleanish(toRef(props, 'titleSrOnly'))\nconst staticBoolean = useBooleanish(toRef(props, 'static'))\n\nconst isActive = ref(false)\nconst element = ref<HTMLElement | null>(null)\nconst lazyLoadCompleted = ref(false)\n\nconst modalClasses = computed(() => [\n  props.modalClass,\n  {\n    fade: !noFadeBoolean.value,\n    show: isActive.value,\n  },\n])\n\nconst hasHeaderCloseSlot = computed(() => !isEmptySlot(slots['header-close']))\n\nconst modalDialogClasses = computed(() => [\n  props.dialogClass,\n  {\n    'modal-fullscreen': props.fullscreen === true,\n    [`modal-fullscreen-${props.fullscreen}-down`]: typeof props.fullscreen === 'string',\n    [`modal-${props.size}`]: props.size !== undefined,\n    'modal-dialog-centered': centeredBoolean.value,\n    'modal-dialog-scrollable': scrollableBoolean.value,\n  },\n])\n\nconst bodyClasses = computed(() => [\n  props.bodyClass,\n  {\n    [`bg-${props.bodyBgVariant}`]: props.bodyBgVariant !== undefined,\n    [`text-${props.bodyTextVariant}`]: props.bodyTextVariant !== undefined,\n  },\n])\n\nconst headerClasses = computed(() => [\n  props.headerClass,\n  {\n    [`bg-${props.headerBgVariant}`]: props.headerBgVariant !== undefined,\n    [`border-${props.headerBorderVariant}`]: props.headerBorderVariant !== undefined,\n    [`text-${props.headerTextVariant}`]: props.headerTextVariant !== undefined,\n  },\n])\n\nconst footerClasses = computed(() => [\n  props.footerClass,\n  {\n    [`bg-${props.footerBgVariant}`]: props.footerBgVariant !== undefined,\n    [`border-${props.footerBorderVariant}`]: props.footerBorderVariant !== undefined,\n    [`text-${props.footerTextVariant}`]: props.footerTextVariant !== undefined,\n  },\n])\n\nconst titleClasses = computed(() => [\n  props.titleClass,\n  {\n    ['visually-hidden']: titleSrOnlyBoolean.value,\n  },\n])\nconst disableCancel = computed<boolean>(() => cancelDisabledBoolean.value || busyBoolean.value)\nconst disableOk = computed<boolean>(() => okDisabledBoolean.value || busyBoolean.value)\n\nconst buildModalEvent = (type: string, opts: Partial<BvModalEvent> = {}): BvModalEvent =>\n  new BvModalEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nconst hide = (trigger = '') => {\n  const event = buildModalEvent('hide', {cancelable: trigger !== '', trigger})\n\n  if (trigger === 'ok') {\n    emit(trigger, event)\n  }\n  if (trigger === 'cancel') {\n    emit(trigger, event)\n  }\n  if (trigger === 'close') {\n    emit(trigger, event)\n  }\n  emit('hide', event)\n\n  if (\n    event.defaultPrevented ||\n    (trigger === 'backdrop' && noCloseOnBackdropBoolean.value) ||\n    (trigger === 'esc' && noCloseOnEscBoolean.value)\n  ) {\n    emit('update:modelValue', true)\n    emit('hide-prevented')\n    return\n  }\n  emit('update:modelValue', false)\n}\n\n// TODO: If a show is prevented, it will briefly show the animation. This is a bug\n// I'm not sure how to wait for the event to be determined. Before showing\nconst show = () => {\n  const event = buildModalEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    emit('update:modelValue', false)\n    emit('show-prevented')\n    return\n  }\n  emit('update:modelValue', true)\n}\n\nconst onBeforeEnter = () => show()\nconst onAfterEnter = () => {\n  isActive.value = true\n  emit('shown', buildModalEvent('shown'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = true\n}\nconst onLeave = () => {\n  isActive.value = false\n}\nconst onAfterLeave = () => {\n  emit('hidden', buildModalEvent('hidden'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = false\n}\n\nwatch(\n  () => modelValueBoolean.value,\n  (newValue) => {\n    if (newValue === true && !noFocusBoolean.value) {\n      nextTick(() => {\n        if (element.value !== null) element.value.focus()\n      })\n    }\n  }\n)\n</script>\n\n<script lang=\"ts\">\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.modal {\n  display: block;\n}\n.modal-dialog {\n  z-index: 1051;\n}\n</style>\n","<template>\n  <component :is=\"tag\" class=\"nav\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BNavProps} from '../types/components'\nimport type {Alignment, Booleanish} from '../../types'\nimport {useAlignment, useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BNavProps {\n  align?: Alignment.JustifyContent\n  cardHeader?: Booleanish\n  fill?: Booleanish\n  justified?: Booleanish\n  pills?: Booleanish\n  small?: Booleanish\n  tabs?: Booleanish\n  tag?: string\n  vertical?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BNavProps>(), {\n  cardHeader: false,\n  fill: false,\n  justified: false,\n  pills: false,\n  small: false,\n  tabs: false,\n  tag: 'ul',\n  vertical: false,\n})\n\nconst cardHeaderBoolean = useBooleanish(toRef(props, 'cardHeader'))\nconst fillBoolean = useBooleanish(toRef(props, 'fill'))\nconst justifiedBoolean = useBooleanish(toRef(props, 'justified'))\nconst pillsBoolean = useBooleanish(toRef(props, 'pills'))\nconst smallBoolean = useBooleanish(toRef(props, 'small'))\nconst tabsBoolean = useBooleanish(toRef(props, 'tabs'))\nconst verticalBoolean = useBooleanish(toRef(props, 'vertical'))\nconst alignment = useAlignment(toRef(props, 'align'))\n\nconst computedClasses = computed(() => ({\n  'nav-tabs': tabsBoolean.value,\n  'nav-pills': pillsBoolean.value && !tabsBoolean.value,\n  'card-header-tabs': !verticalBoolean.value && cardHeaderBoolean.value && tabsBoolean.value,\n  'card-header-pills':\n    !verticalBoolean.value && cardHeaderBoolean.value && pillsBoolean.value && !tabsBoolean.value,\n  'flex-column': verticalBoolean.value,\n  'nav-fill': !verticalBoolean.value && fillBoolean.value,\n  'nav-justified': !verticalBoolean.value && justifiedBoolean.value,\n  [alignment.value]: !verticalBoolean.value && props.align !== undefined,\n  'small': smallBoolean.value,\n}))\n</script>\n","<template>\n  <BForm v-bind=\"computedAttrs\" class=\"d-flex\" @submit.prevent=\"submitted\">\n    <slot />\n  </BForm>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {Booleanish} from '../../types'\nimport BForm from '../BForm/BForm.vue'\n\ninterface Props {\n  role?: string\n  id?: string // Extend BFormProps\n  floating?: Booleanish\n  novalidate?: Booleanish\n  validated?: Booleanish\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  floating: false,\n  novalidate: false,\n  validated: false,\n})\n\ninterface BNavFormEmits {\n  (e: 'submit', value: Event): void\n}\n\nconst emit = defineEmits<BNavFormEmits>()\n\nconst computedAttrs = computed(() => ({\n  floating: props.floating,\n  role: props.role,\n  id: props.id,\n  novalidate: props.novalidate,\n  validated: props.validated,\n}))\n\nconst submitted = (e: Event): void => emit('submit', e)\n</script>\n","<template>\n  <li class=\"nav-item\">\n    <b-link\n      class=\"nav-link\"\n      v-bind=\"$props\"\n      active-class=\"active\"\n      :tabindex=\"disabledBoolean ? -1 : undefined\"\n      :aria-disabled=\"disabledBoolean ? true : undefined\"\n    >\n      <slot />\n    </b-link>\n  </li>\n</template>\n\n<script lang=\"ts\">\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\nimport {omit} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {defineComponent, toRef} from 'vue'\n\nexport default defineComponent({\n  components: {BLink},\n  props: {\n    ...omit(BLINK_PROPS, ['event', 'routerTag'] as const),\n  },\n  setup(props) {\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\n    return {disabledBoolean}\n  },\n})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"navbar\" :class=\"computedClasses\" :role=\"computedRole\">\n    <div v-if=\"container !== false\" :class=\"containerClass\">\n      <slot />\n    </div>\n    <slot v-else />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface Props {\n  fixed?: 'top' | 'bottom'\n  print?: Booleanish\n  sticky?: 'top' | 'bottom'\n  tag?: string\n  toggleable?: boolean | 'sm' | 'md' | 'lg' | 'xl' // Type Omit<Breakpoint, 'xxl'>\n  dark?: Booleanish\n  variant?: ColorVariant\n  container?: 'fluid' | boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  print: false,\n  tag: 'nav',\n  dark: false,\n  toggleable: false,\n  container: 'fluid',\n})\n\nconst printBoolean = useBooleanish(toRef(props, 'print'))\nconst darkBoolean = useBooleanish(toRef(props, 'dark'))\n\nconst computedRole = computed<undefined | 'navigation'>(() =>\n  props.tag === 'nav' ? undefined : 'navigation'\n)\n\nconst computedNavbarExpand = computed<undefined | string>(() =>\n  typeof props.toggleable === 'string'\n    ? `navbar-expand-${props.toggleable}`\n    : props.toggleable === false\n    ? 'navbar-expand'\n    : undefined\n)\n\nconst containerClass = computed<'container' | 'container-fluid'>(() =>\n  props.container === true ? 'container' : `container-fluid`\n)\n\nconst computedClasses = computed(() => ({\n  'd-print': printBoolean.value,\n  [`sticky-${props.sticky}`]: props.sticky !== undefined,\n  'navbar-dark': darkBoolean.value,\n  [`bg-${props.variant}`]: props.variant !== undefined,\n  [`fixed-${props.fixed}`]: props.fixed !== undefined,\n  [`${computedNavbarExpand.value}`]: computedNavbarExpand.value !== undefined,\n}))\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"navbar-brand\" v-bind=\"computedLinkProps\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {isLink, omit, pluckProps} from '../../utils'\nimport {computed, defineComponent} from 'vue'\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\n\nconst linkProps = omit(BLINK_PROPS, ['event', 'routerTag'] as const)\n\nexport default defineComponent({\n  components: {\n    BLink,\n  },\n  props: {\n    tag: {type: String, default: 'div'},\n    ...linkProps,\n  },\n  setup(props) {\n    const computedLink = computed<boolean>(() => isLink(props))\n    const computedTag = computed<string | typeof BLink>(() =>\n      computedLink.value ? BLink : props.tag\n    )\n\n    const computedLinkProps = computed(() =>\n      computedLink.value ? pluckProps(props, linkProps) : {}\n    )\n\n    return {\n      computedLinkProps,\n      computedTag,\n    }\n  },\n})\n</script>\n","<template>\n  <ul class=\"navbar-nav\" :class=\"computedClasses\">\n    <slot />\n  </ul>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Alignment, Booleanish} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useAlignment, useBooleanish} from '../../composables'\n\ninterface Props {\n  align?: Alignment.JustifyContent\n  fill?: Booleanish\n  justified?: Booleanish\n  small?: Booleanish\n  tag?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  fill: false,\n  justified: false,\n  small: false,\n  tag: 'ul',\n})\n\nconst fillBoolean = useBooleanish(toRef(props, 'fill'))\nconst justifiedBoolean = useBooleanish(toRef(props, 'justified'))\nconst smallBoolean = useBooleanish(toRef(props, 'small'))\nconst alignment = useAlignment(toRef(props, 'align'))\n\nconst computedClasses = computed(() => ({\n  'nav-fill': fillBoolean.value,\n  'nav-justified': justifiedBoolean.value,\n  [alignment.value]: props.align !== undefined,\n  'small': smallBoolean.value,\n}))\n</script>\n","<template>\n  <button\n    v-b-toggle=\"!disabledBoolean ? target : undefined\"\n    class=\"navbar-toggler\"\n    type=\"button\"\n    :class=\"computedClasses\"\n    v-bind=\"computedAttrs\"\n    @click=\"onClick\"\n  >\n    <slot>\n      <span class=\"navbar-toggler-icon\" />\n    </slot>\n  </button>\n</template>\n\n<script setup lang=\"ts\">\nimport {BToggle as vBToggle} from '../../directives'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface Props {\n  disabled?: Booleanish\n  label?: string\n  target?: string | Array<string>\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  label: 'Toggle navigation',\n  disabled: false,\n})\n\ninterface Emits {\n  (e: 'click', value: MouseEvent): void\n}\n\nconst emit = defineEmits<Emits>()\n\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\nconst computedAttrs = computed(() => ({\n  'disabled': disabledBoolean.value,\n  'aria-label': props.label,\n}))\n\nconst computedClasses = computed(() => ({\n  disabled: disabledBoolean.value,\n}))\n\nconst onClick = (e: MouseEvent): void => {\n  if (!disabledBoolean.value) {\n    emit('click', e)\n  }\n}\n</script>\n","<template>\n  <div\n    ref=\"element\"\n    class=\"offcanvas\"\n    :class=\"computedClasses\"\n    tabindex=\"-1\"\n    aria-labelledby=\"offcanvasLabel\"\n    :data-bs-backdrop=\"backdropBoolean\"\n    :data-bs-scroll=\"bodyScrollingBoolean\"\n  >\n    <div v-if=\"!noHeaderBoolean\" class=\"offcanvas-header\">\n      <slot name=\"header\" v-bind=\"{visible: modelValueBoolean, placement, hide}\">\n        <h5 id=\"offcanvasLabel\" class=\"offcanvas-title\">\n          <slot name=\"title\">\n            {{ title }}\n          </slot>\n        </h5>\n        <b-close-button\n          v-if=\"!noHeaderCloseBoolean\"\n          class=\"text-reset\"\n          data-bs-dismiss=\"offcanvas\"\n          :aria-label=\"dismissLabel\"\n        />\n      </slot>\n    </div>\n    <div class=\"offcanvas-body\">\n      <slot />\n    </div>\n    <div v-if=\"hasFooterSlot\">\n      <slot name=\"footer\" v-bind=\"{visible: modelValueBoolean, placement, hide}\" />\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BOffcanvasEmits, BOffcanvasProps} from '../types/components'\nimport {computed, onMounted, ref, toRef, useSlots, watch} from 'vue'\nimport {Offcanvas} from 'bootstrap'\nimport {useBooleanish, useEventListener} from '../composables'\nimport type {Booleanish} from '../types'\nimport BCloseButton from './BButton/BCloseButton.vue'\nimport {isEmptySlot} from '../utils'\n\ninterface BOffcanvasProps {\n  dismissLabel?: string\n  modelValue?: Booleanish\n  bodyScrolling?: Booleanish\n  backdrop?: Booleanish\n  placement?: string\n  title?: string\n  noHeaderClose?: Booleanish\n  noHeader?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BOffcanvasProps>(), {\n  dismissLabel: 'Close',\n  modelValue: false,\n  bodyScrolling: false,\n  backdrop: true,\n  placement: 'start',\n  noHeaderClose: false,\n  noHeader: false,\n})\n\nconst modelValueBoolean = useBooleanish(toRef(props, 'modelValue'))\nconst bodyScrollingBoolean = useBooleanish(toRef(props, 'bodyScrolling'))\nconst backdropBoolean = useBooleanish(toRef(props, 'backdrop'))\nconst noHeaderCloseBoolean = useBooleanish(toRef(props, 'noHeaderClose'))\nconst noHeaderBoolean = useBooleanish(toRef(props, 'noHeader'))\n\ninterface BOffcanvasEmits {\n  (e: 'update:modelValue', value: boolean): void\n  (e: 'show'): void\n  (e: 'shown'): void\n  (e: 'hide'): void\n  (e: 'hidden'): void\n}\n\nconst emit = defineEmits<BOffcanvasEmits>()\n\nconst slots = useSlots()\n\nconst element = ref<HTMLElement>()\nconst instance = ref<Offcanvas>()\n\nconst hasFooterSlot = computed<boolean>(() => !isEmptySlot(slots.footer))\nconst computedClasses = computed(() => [`offcanvas-${props.placement}`])\n\nconst show = () => {\n  emit('show')\n  emit('update:modelValue', true)\n}\n\nconst hide = () => {\n  emit('hide')\n  emit('update:modelValue', false)\n}\n\nwatch(\n  () => modelValueBoolean.value,\n  (value) => {\n    if (value) {\n      instance.value?.show(element.value as HTMLElement)\n    } else {\n      instance.value?.hide()\n    }\n  }\n)\n\nuseEventListener(element, 'shown.bs.offcanvas', () => emit('shown'))\nuseEventListener(element, 'hidden.bs.offcanvas', () => emit('hidden'))\n\nuseEventListener(element, 'show.bs.offcanvas', () => {\n  show()\n})\n\nuseEventListener(element, 'hide.bs.offcanvas', () => {\n  hide()\n})\n\nonMounted((): void => {\n  instance.value = new Offcanvas(element.value as HTMLElement)\n\n  if (modelValueBoolean.value) {\n    instance.value?.show(element.value as HTMLElement)\n  }\n})\n</script>\n","<template>\n  <component :is=\"wrapTag\" class=\"b-overlay-wrap position-relative\" :aria-busy=\"computedAriaBusy\">\n    <slot />\n    <b-transition\n      :no-fade=\"noFade\"\n      :trans-props=\"{enterToClass: 'show'}\"\n      name=\"fade\"\n      @on-after-enter=\"emit('shown')\"\n      @on-after-leave=\"emit('hidden')\"\n    >\n      <component\n        :is=\"overlayTag\"\n        v-if=\"showBoolean\"\n        :class=\"overlayClasses\"\n        :style=\"overlayStyles\"\n        @click=\"emit('click', $event)\"\n      >\n        <div class=\"position-absolute\" :class=\"blurClasses\" :style=\"blurStyles\" />\n\n        <div class=\"position-absolute\" :style=\"spinWrapperStyles\">\n          <slot name=\"overlay\" v-bind=\"spinnerAttrs\">\n            <b-spinner v-bind=\"spinnerAttrs\" />\n          </slot>\n        </div>\n      </component>\n    </b-transition>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, ColorVariant, SpinnerType} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BSpinner from '../BSpinner.vue'\n\ninterface Props {\n  bgColor?: string\n  blur?: string\n  fixed?: Booleanish\n  noCenter?: Booleanish\n  noFade?: Booleanish\n  noWrap?: Booleanish\n  opacity?: number | string\n  overlayTag?: string\n  rounded?: boolean | string\n  show?: Booleanish\n  spinnerSmall?: Booleanish\n  spinnerType?: SpinnerType\n  spinnerVariant?: ColorVariant\n  variant?:\n    | 'transparent'\n    | 'white'\n    | 'light'\n    | 'dark'\n    | 'primary'\n    | 'secondary'\n    | 'success'\n    | 'danger'\n    | 'warning'\n    | 'info' // ColorVariant | 'white' | 'transparent'\n  wrapTag?: string\n  zIndex?: number | string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  blur: '2px',\n  fixed: false,\n  noCenter: false,\n  noFade: false,\n  noWrap: false,\n  opacity: 0.85,\n  overlayTag: 'div',\n  rounded: false,\n  show: false,\n  spinnerSmall: false,\n  spinnerType: 'border',\n  variant: 'light',\n  wrapTag: 'div',\n  zIndex: 10,\n})\n\ninterface Emits {\n  (e: 'click', value: MouseEvent): void\n  (e: 'hidden'): void\n  (e: 'shown'): void\n}\n\nconst emit = defineEmits<Emits>()\n\nconst positionStyles = {top: 0, left: 0, bottom: 0, right: 0}\n\nconst fixedBoolean = useBooleanish(toRef(props, 'fixed'))\nconst noCenterBoolean = useBooleanish(toRef(props, 'noCenter'))\nconst noWrapBoolean = useBooleanish(toRef(props, 'noWrap'))\nconst showBoolean = useBooleanish(toRef(props, 'show'))\nconst spinnerSmallBoolean = useBooleanish(toRef(props, 'spinnerSmall'))\n\nconst computedRounded = computed(() =>\n  props.rounded === true || props.rounded === ''\n    ? 'rounded'\n    : props.rounded === false\n    ? ''\n    : `rounded-${props.rounded}`\n)\n\nconst computedVariant = computed(() =>\n  props.variant && !props.bgColor ? `bg-${props.variant}` : ''\n)\n\nconst computedAriaBusy = computed(() => (showBoolean.value ? 'true' : null))\n\nconst spinnerAttrs = computed(() => ({\n  type: props.spinnerType || undefined,\n  variant: props.spinnerVariant || undefined,\n  small: spinnerSmallBoolean.value,\n}))\n\nconst overlayStyles = computed(() => ({\n  ...positionStyles,\n  zIndex: props.zIndex || 10,\n}))\n\nconst overlayClasses = computed(() => [\n  'b-overlay',\n  {\n    'position-absolute': !noWrapBoolean.value || !fixedBoolean.value,\n    'position-fixed': noWrapBoolean.value && fixedBoolean.value,\n  },\n])\n\nconst blurClasses = computed(() => [computedVariant.value, computedRounded.value])\n\nconst blurStyles = computed(() => ({\n  ...positionStyles,\n  opacity: props.opacity,\n  backgroundColor: props.bgColor || undefined,\n  backdropFilter: blur ? `blur(${blur})` : undefined,\n}))\n\nconst spinWrapperStyles = computed(() =>\n  noCenterBoolean.value\n    ? positionStyles\n    : {\n        top: '50%',\n        left: '50%',\n        transform: 'translateX(-50%) translateY(-50%)',\n      }\n)\n</script>\n","<script lang=\"ts\">\nimport {BvEvent, normalizeSlot, toInteger} from '../../utils'\nimport {computed, defineComponent, h, type PropType, reactive, toRef, watch} from 'vue'\nimport type {Alignment, Booleanish, InputSize, Pagination, PaginationPage} from '../../types'\nimport {useAlignment, useBooleanish} from '../../composables'\n// Default # of buttons limit\nconst DEFAULT_LIMIT = 5\n\nconst DEFAULT_PER_PAGE = 20\nconst DEFAULT_TOTAL_ROWS = 0\n\n// Threshold of limit size when we start/stop showing ellipsis\nconst ELLIPSIS_THRESHOLD = 3\n\n// Slot Constants\nconst SLOT_NAME_ELLIPSIS_TEXT = 'ellipsis-text'\nconst SLOT_NAME_FIRST_TEXT = 'first-text'\nconst SLOT_NAME_LAST_TEXT = 'last-text'\nconst SLOT_NAME_NEXT_TEXT = 'next-text'\nconst SLOT_NAME_PAGE = 'page'\nconst SLOT_NAME_PREV_TEXT = 'prev-text'\n\nconst sanitizePerPage = (value: number): number => Math.max(toInteger(value) || DEFAULT_PER_PAGE, 1)\nconst sanitizeTotalRows = (value: number): number =>\n  Math.max(toInteger(value) || DEFAULT_TOTAL_ROWS, 0)\nconst sanitizeCurrentPage = (value: number, numberOfPages: number) => {\n  const page = toInteger(value) || 1\n  return page > numberOfPages ? numberOfPages : page < 1 ? 1 : page\n}\n\nexport default defineComponent({\n  name: 'BPagination',\n  props: {\n    align: {type: String as PropType<Alignment.JustifyContent | 'fill'>, default: 'start'},\n    ariaControls: {type: String, required: false},\n    ariaLabel: {type: String, default: 'Pagination'},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    ellipsisClass: {type: [Array, String], default: () => []},\n    ellipsisText: {type: String, default: '\\u2026'},\n    firstClass: {type: [Array, String], default: () => []},\n    firstNumber: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    firstText: {type: String, default: '\\u00AB'},\n    hideEllipsis: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    hideGotoEndButtons: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    labelFirstPage: {type: String, default: 'Go to first page'},\n    labelLastPage: {type: String, default: 'Go to last page'},\n    labelNextPage: {type: String, default: 'Go to next page'},\n    labelPage: {type: String, default: 'Go to page'},\n    labelPrevPage: {type: String, default: 'Go to previous page'},\n    lastClass: {type: [Array, String], default: () => []},\n    lastNumber: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    lastText: {type: String, default: '\\u00BB'},\n    limit: {type: Number, default: DEFAULT_LIMIT},\n    modelValue: {type: Number, default: 1}, // V-model prop\n    nextClass: {type: [Array, String], default: () => []},\n    nextText: {type: String, default: '\\u203A'},\n    pageClass: {type: [Array, String], default: () => []},\n    perPage: {type: Number, default: DEFAULT_PER_PAGE},\n    pills: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    prevClass: {type: [Array, String], default: () => []},\n    prevText: {type: String, default: '\\u2039'},\n    size: {type: String as PropType<InputSize>, required: false},\n    totalRows: {type: Number, default: DEFAULT_TOTAL_ROWS},\n  },\n  emits: ['update:modelValue', 'page-click'],\n  setup(props, {emit, slots}) {\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n    const firstNumberBoolean = useBooleanish(toRef(props, 'firstNumber'))\n    const hideEllipsisBoolean = useBooleanish(toRef(props, 'hideEllipsis'))\n    const hideGotoEndButtonsBoolean = useBooleanish(toRef(props, 'hideGotoEndButtons'))\n    const lastNumberBoolean = useBooleanish(toRef(props, 'lastNumber'))\n    const pillsBoolean = useBooleanish(toRef(props, 'pills'))\n\n    const justifyAlign = computed<Alignment.JustifyContent>(() =>\n      props.align === 'fill' ? 'start' : props.align\n    )\n    const alignment = useAlignment(toRef(justifyAlign, 'value'))\n\n    // Use Active to on page-item to denote active tab\n    const numberOfPages = computed(() =>\n      Math.ceil(sanitizeTotalRows(props.totalRows) / sanitizePerPage(props.perPage))\n    )\n\n    const startNumber = computed(() => {\n      let lStartNumber: number\n      const pagesLeft: number = numberOfPages.value - props.modelValue\n\n      if (pagesLeft + 2 < props.limit && props.limit > ELLIPSIS_THRESHOLD) {\n        lStartNumber = numberOfPages.value - numberOfLinks.value + 1\n      } else {\n        // Middle and beginning calculation.\n        lStartNumber = props.modelValue - Math.floor(numberOfLinks.value / 2)\n      }\n      // Negative due at times\n      if (lStartNumber < 1) {\n        lStartNumber = 1\n      } else if (lStartNumber > numberOfPages.value - numberOfLinks.value) {\n        lStartNumber = numberOfPages.value - numberOfLinks.value + 1\n      }\n      //why check for this?\n      // if (showFirstDots.value && cfirstNumber && lStartNumber < 4) {\n      //   lStartNumber = 1\n      // }\n\n      // Special handling for lower limits (where ellipsis are never shown)\n      if (props.limit <= ELLIPSIS_THRESHOLD) {\n        if (\n          lastNumberBoolean.value &&\n          numberOfPages.value === lStartNumber + numberOfLinks.value - 1\n        ) {\n          lStartNumber = Math.max(lStartNumber - 1, 1)\n        }\n      }\n      return lStartNumber\n    })\n\n    const showFirstDots = computed(() => {\n      const pagesLeft = numberOfPages.value - props.modelValue\n      let rShowDots = false\n\n      if (pagesLeft + 2 < props.limit && props.limit > ELLIPSIS_THRESHOLD) {\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          rShowDots = true\n        }\n      } else {\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          rShowDots = !!(!hideEllipsisBoolean.value || firstNumberBoolean.value)\n        }\n      }\n      if (startNumber.value <= 1) {\n        rShowDots = false\n      }\n\n      if (rShowDots && firstNumberBoolean.value && startNumber.value < 4) {\n        rShowDots = false\n      }\n\n      return rShowDots\n    })\n\n    //Calculate the number of links considering limit\n    const numberOfLinks = computed(() => {\n      let n: number = props.limit\n\n      if (numberOfPages.value <= props.limit) {\n        n = numberOfPages.value\n      } else if (props.modelValue < props.limit - 1 && props.limit > ELLIPSIS_THRESHOLD) {\n        if (!hideEllipsisBoolean.value || lastNumberBoolean.value) {\n          n = props.limit - (firstNumberBoolean.value ? 0 : 1)\n        }\n        n = Math.min(n, props.limit)\n      } else if (\n        numberOfPages.value - props.modelValue + 2 < props.limit &&\n        props.limit > ELLIPSIS_THRESHOLD\n      ) {\n        if (!hideEllipsisBoolean.value || firstNumberBoolean.value) {\n          n = props.limit - (lastNumberBoolean.value ? 0 : 1)\n        }\n      } else {\n        // We consider ellipsis tabs as their own page links\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          n = props.limit - (hideEllipsisBoolean.value ? 0 : 2)\n        }\n      }\n\n      return n\n    })\n\n    const showLastDots = computed(() => {\n      const paginationWindowEnd = numberOfPages.value - numberOfLinks.value // The start of the last window of page links\n\n      let rShowDots = false\n\n      if (props.modelValue < props.limit - 1 && props.limit > ELLIPSIS_THRESHOLD) {\n        if (!hideEllipsisBoolean.value || lastNumberBoolean.value) {\n          rShowDots = true\n        }\n      } else {\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          rShowDots = !!(!hideEllipsisBoolean.value || lastNumberBoolean.value)\n        }\n      }\n      if (startNumber.value > paginationWindowEnd) {\n        rShowDots = false\n      }\n      const lastPageNumber = startNumber.value + numberOfLinks.value - 1\n\n      if (rShowDots && lastNumberBoolean.value && lastPageNumber > numberOfPages.value - 3) {\n        rShowDots = false\n      }\n\n      return rShowDots\n    })\n\n    const pagination = reactive<Pagination>({\n      pageSize: sanitizePerPage(props.perPage),\n      totalRows: sanitizeTotalRows(props.totalRows),\n      numberOfPages: numberOfPages.value,\n    })\n\n    const pageClick = (event: MouseEvent, pageNumber: number) => {\n      if (pageNumber === props.modelValue) {\n        return\n      }\n\n      const {target} = event\n      // Emit a user-cancelable `page-click` event\n      const clickEvent = new BvEvent('page-click', {\n        cancelable: true,\n        target,\n      })\n      emit('page-click', clickEvent, pageNumber)\n      if (clickEvent.defaultPrevented) {\n        return\n      }\n\n      emit('update:modelValue', pageNumber)\n\n      //    nextTick(() => {\n      //  if (isVisible(target) && un_element.contains(target)) {\n      //  attemptFocus(target)\n      //} else {\n      //this.focusCurrent()\n      //}\n      // })\n    }\n\n    const btnSize = computed(() => (props.size ? `pagination-${props.size}` : ''))\n    const styleClass = computed(() => (pillsBoolean.value ? 'b-pagination-pills' : ''))\n\n    watch(\n      () => props.modelValue,\n      (newValue: number) => {\n        const calculatedValue = sanitizeCurrentPage(newValue, numberOfPages.value)\n        if (calculatedValue !== props.modelValue) emit('update:modelValue', calculatedValue)\n      }\n    )\n\n    watch(pagination, (oldValue, newValue) => {\n      if (!(oldValue === undefined || oldValue === null)) {\n        if (newValue.pageSize !== oldValue.pageSize && newValue.totalRows === oldValue.totalRows) {\n          // If the page size changes, reset to page 1\n          emit('update:modelValue', 1)\n        } else if (\n          newValue.numberOfPages !== oldValue.numberOfPages &&\n          props.modelValue > newValue.numberOfPages\n        ) {\n          // If `numberOfPages` changes and is less than\n          // the `currentPage` number, reset to page 1\n          emit('update:modelValue', 1)\n        }\n      }\n    })\n\n    //Render Helper Functions\n    const pages = computed(() => {\n      const result = []\n      for (let index = 0; index < numberOfLinks.value; index++) {\n        result.push({number: startNumber.value + index, classes: null})\n      }\n      return result\n    })\n\n    return () => {\n      const buttons = []\n      const pageNumbers = pages.value.map((p) => p.number) // array of numbers... Used in first and last number comparisons\n      const isActivePage = (pageNumber: number) => pageNumber === props.modelValue\n      const noCurrentPage: boolean = props.modelValue < 1\n      const fill = props.align === 'fill'\n\n      const makeEndBtn = (\n        linkTo: number,\n        ariaLabel: string,\n        btnSlot: string,\n        btnText: string,\n        btnClass: string | Array<unknown>,\n        pageTest: number\n      ) => {\n        const isDisabled: boolean =\n          disabledBoolean.value ||\n          isActivePage(pageTest) ||\n          noCurrentPage ||\n          linkTo < 1 ||\n          linkTo > numberOfPages.value\n        const pageNumber: number =\n          linkTo < 1 ? 1 : linkTo > numberOfPages.value ? numberOfPages.value : linkTo\n        const scope = {disabled: isDisabled, page: pageNumber, index: pageNumber - 1}\n        const btnContent = normalizeSlot(btnSlot, scope, slots) || btnText || ''\n\n        return h(\n          'li',\n          {\n            class: [\n              'page-item',\n              {\n                'disabled': isDisabled,\n                'flex-fill': fill,\n                'd-flex': fill && !isDisabled,\n              },\n              btnClass,\n            ],\n          },\n          // render inner content\n          h(\n            isDisabled ? 'span' : 'button',\n            {\n              'class': ['page-link', {'flex-grow-1': !isDisabled && fill}],\n              'aria-label': ariaLabel,\n              'aria-controls': props.ariaControls || null,\n              'aria-disabled': isDisabled ? 'true' : null,\n              'role': 'menuitem',\n              'type': isDisabled ? null : 'button',\n              'tabindex': isDisabled ? null : '-1',\n              'onClick': (event: MouseEvent) => {\n                if (isDisabled) {\n                  return\n                }\n                pageClick(event, pageNumber)\n              },\n            },\n            btnContent\n          )\n        )\n      }\n\n      const makeEllipsis = (isLast: boolean) =>\n        h(\n          'li',\n          {\n            class: [\n              'page-item',\n              'disabled',\n              'bv-d-xs-down-none',\n              fill ? 'flex-fill' : '',\n              props.ellipsisClass,\n            ],\n            role: 'separator',\n            key: `ellipsis-${isLast ? 'last' : 'first'}`,\n          },\n          [\n            h(\n              'span',\n              {class: ['page-link']},\n              normalizeSlot(SLOT_NAME_ELLIPSIS_TEXT, {}, slots) || props.ellipsisText || '...'\n            ),\n          ]\n        )\n\n      const makePageButton = (page: PaginationPage, idx: number) => {\n        const active: boolean = isActivePage(page.number) && !noCurrentPage\n        const tabIndex = disabledBoolean.value\n          ? null\n          : active || (noCurrentPage && idx === 0)\n          ? '0'\n          : '-1'\n        const scope = {\n          active,\n          disabled: disabledBoolean.value,\n          page: page.number,\n          index: page.number - 1,\n          content: page.number,\n        }\n        const btnContent = normalizeSlot(SLOT_NAME_PAGE, scope, slots) || page.number\n        const inner = h(\n          disabledBoolean.value ? 'span' : 'button',\n          {\n            'class': ['page-link', {'flex-grow-1': !disabledBoolean.value && fill}],\n            'aria-controls': props.ariaControls || null,\n            'aria-disabled': disabledBoolean.value ? 'true' : null,\n            'aria-label': props.labelPage ? `${props.labelPage} ${page.number}` : null,\n            'role': 'menuitemradio',\n            'type': disabledBoolean.value ? null : 'button',\n            'tabindex': tabIndex,\n            'onClick': (event: MouseEvent) => {\n              if (!disabledBoolean.value) {\n                pageClick(event, page.number)\n              }\n            },\n          },\n          btnContent\n        )\n\n        return h(\n          'li',\n          {\n            class: [\n              'page-item',\n              {\n                'disabled': disabledBoolean.value,\n                active,\n                'flex-fill': fill,\n                'd-flex': fill && !disabledBoolean.value,\n              },\n              props.pageClass,\n            ],\n            role: 'presentation',\n            key: `page-${page.number}`,\n          },\n          inner\n        )\n      }\n\n      // Goto first page button. Don't render button when `hideGotoEndButtons` or `firstNumber` is set\n      if (!hideGotoEndButtonsBoolean.value && !firstNumberBoolean.value) {\n        const gotoFirstPageButton = makeEndBtn(\n          1,\n          props.labelFirstPage,\n          SLOT_NAME_FIRST_TEXT,\n          props.firstText,\n          props.firstClass,\n          1\n        )\n        buttons.push(gotoFirstPageButton)\n      }\n\n      //Previous Button\n      const previousButton = makeEndBtn(\n        props.modelValue - 1,\n        props.labelFirstPage,\n        SLOT_NAME_PREV_TEXT,\n        props.prevText,\n        props.prevClass,\n        1\n      )\n      buttons.push(previousButton)\n\n      // First Page Number Button\n      if (firstNumberBoolean.value && pageNumbers[0] !== 1) {\n        buttons.push(makePageButton({number: 1}, 0))\n      }\n\n      // first Ellipsis\n      if (showFirstDots.value) {\n        buttons.push(makeEllipsis(false))\n      }\n\n      pages.value.forEach((page, idx) => {\n        const offset =\n          showFirstDots.value && firstNumberBoolean.value && pageNumbers[0] !== 1 ? 1 : 0\n        buttons.push(makePageButton(page, idx + offset))\n      })\n\n      // last Ellipsis\n      if (showLastDots.value) {\n        buttons.push(makeEllipsis(true))\n      }\n\n      if (lastNumberBoolean.value && pageNumbers[pageNumbers.length - 1] !== numberOfPages.value) {\n        buttons.push(makePageButton({number: numberOfPages.value}, -1))\n      }\n\n      //Next Button\n      const nextButton = makeEndBtn(\n        props.modelValue + 1,\n        props.labelNextPage,\n        SLOT_NAME_NEXT_TEXT,\n        props.nextText,\n        props.nextClass,\n        numberOfPages.value\n      )\n      buttons.push(nextButton)\n\n      // Goto last page button\n      if (!lastNumberBoolean.value && !hideGotoEndButtonsBoolean.value) {\n        const gotoLastPageButton = makeEndBtn(\n          numberOfPages.value,\n          props.labelLastPage,\n          SLOT_NAME_LAST_TEXT,\n          props.lastText,\n          props.lastClass,\n          numberOfPages.value\n        )\n        buttons.push(gotoLastPageButton)\n      }\n\n      //pagination\n      return h(\n        'ul',\n        {\n          'class': ['pagination', btnSize.value, alignment.value, styleClass.value],\n          'role': 'menubar',\n          'aria-disabled': disabledBoolean.value,\n          'aria-label': props.ariaLabel || null,\n        },\n        buttons\n      )\n    }\n  },\n})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"placeholder\" :class=\"computedClasses\" :style=\"computedStyle\" />\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, type StyleValue} from 'vue'\nimport type {ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\n\ninterface Props {\n  tag?: string\n  width?: string | number\n  cols?: string | number\n  variant?: ColorVariant\n  size?: PlaceholderSize\n  animation?: PlaceholderAnimation\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  tag: 'span',\n})\n\nconst widthString = computed<string | undefined>(() =>\n  props.width === undefined\n    ? undefined\n    : typeof props.width === 'number'\n    ? props.width.toString()\n    : props.width.includes('%')\n    ? props.width.replaceAll('%', '')\n    : props.width\n)\n\nconst colsString = computed<string | undefined>(() =>\n  props.cols === undefined\n    ? undefined\n    : typeof props.cols === 'number'\n    ? props.cols.toString()\n    : props.cols\n)\n\nconst computedClasses = computed(() => ({\n  [`col-${colsString.value}`]: colsString.value !== undefined && widthString.value === undefined,\n  [`bg-${props.variant}`]: props.variant !== undefined,\n  [`placeholder-${props.size}`]: props.size !== undefined,\n  [`placeholder-${props.animation}`]: props.animation !== undefined,\n}))\n\nconst computedStyle = computed<StyleValue | undefined>(() =>\n  widthString.value === undefined ? undefined : `width: ${widthString.value}%;`\n)\n</script>\n","<template>\n  <b-placeholder :class=\"computedClasses\" v-bind=\"computedAttrs\" />\n</template>\n\n<script setup lang=\"ts\">\nimport BPlaceholder from './BPlaceholder.vue'\nimport type {ColorVariant, PlaceholderAnimation} from '../../types'\nimport {computed} from 'vue'\n\ninterface Props {\n  tag?: string\n  width?: string | number\n  cols?: string | number\n  variant?: ColorVariant\n  animation?: PlaceholderAnimation\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  tag: 'div',\n  variant: 'primary',\n})\n\nconst computedClasses = computed<Array<string>>(() => ['btn', `btn-${props.variant}`, 'disabled'])\n\nconst computedAttrs = computed(() => ({\n  animation: props.animation,\n  width: props.width,\n  cols: props.cols,\n  tag: props.tag,\n}))\n</script>\n","<template>\n  <b-card :img-bottom=\"imgBottom\">\n    <template v-if=\"!noImgBoolean\" #img>\n      <slot name=\"img\">\n        <b-card-img v-bind=\"imgAttrs\" />\n      </slot>\n    </template>\n\n    <template v-if=\"!noHeaderBoolean\" #header>\n      <slot name=\"header\">\n        <b-placeholder v-bind=\"headerAttrs\" />\n      </slot>\n    </template>\n    <slot>\n      <b-placeholder cols=\"7\" />\n      <b-placeholder cols=\"4\" />\n      <b-placeholder cols=\"4\" />\n      <b-placeholder cols=\"6\" />\n      <b-placeholder cols=\"8\" />\n    </slot>\n    <template v-if=\"!noFooterBoolean\" #footer>\n      <slot name=\"footer\">\n        <b-placeholder-button v-if=\"!noButtonBoolean\" v-bind=\"footerAttrs\" />\n        <b-placeholder v-else v-bind=\"footerAttrs\" />\n      </slot>\n    </template>\n  </b-card>\n</template>\n\n<script setup lang=\"ts\">\nimport BCard from '../BCard/BCard.vue'\nimport BCardImg from '../BCard/BCardImg.vue'\nimport BPlaceholder from './BPlaceholder.vue'\nimport BPlaceholderButton from './BPlaceholderButton.vue'\nimport type {Booleanish, ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ninterface Props {\n  noHeader?: Booleanish\n  headerWidth?: string | number\n  headerVariant?: ColorVariant\n  headerAnimation?: PlaceholderAnimation\n  headerSize?: PlaceholderSize\n  noFooter?: Booleanish\n  footerWidth?: string | number\n  footerVariant?: ColorVariant\n  footerAnimation?: PlaceholderAnimation\n  footerSize?: PlaceholderSize\n  animation?: PlaceholderAnimation\n  size?: PlaceholderSize\n  variant?: ColorVariant\n  noButton?: Booleanish\n  imgBottom?: Booleanish\n  imgSrc?: string\n  imgBlankColor?: string\n  imgHeight?: string | number\n  noImg?: Booleanish\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  noButton: false,\n  headerWidth: 100,\n  footerWidth: 100,\n  noHeader: false,\n  noFooter: false,\n  imgBlankColor: '#868e96',\n  imgHeight: 100,\n  imgBottom: false,\n  noImg: false,\n})\n\nconst noButtonBoolean = useBooleanish(toRef(props, 'noButton'))\nconst noHeaderBoolean = useBooleanish(toRef(props, 'noHeader'))\nconst noFooterBoolean = useBooleanish(toRef(props, 'noFooter'))\nconst noImgBoolean = useBooleanish(toRef(props, 'noImg'))\n\nconst headerAttrs = computed(() => ({\n  width: props.headerWidth,\n  variant: props.headerVariant,\n  animation: props.headerAnimation,\n  size: props.headerSize,\n}))\n\nconst footerAttrs = computed(() => ({\n  width: props.footerWidth,\n  animation: props.footerAnimation,\n  size: noButtonBoolean.value ? props.footerSize : undefined,\n  variant: props.footerVariant,\n}))\n\nconst imgAttrs = computed(() => ({\n  blank: !props.imgSrc ? true : false,\n  blankColor: props.imgBlankColor,\n  height: !props.imgSrc ? props.imgHeight : undefined,\n  src: props.imgSrc,\n  top: !props.imgBottom,\n  bottom: props.imgBottom,\n}))\n</script>\n","<template>\n  <table v-if=\"!responsive\" role=\"table\" :class=\"computedClasses\">\n    <slot />\n  </table>\n  <div v-else :class=\"responsiveClasses\">\n    <table role=\"table\" :class=\"computedClasses\">\n      <slot />\n    </table>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {Breakpoint} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ClassValue, ColorVariant} from '../../types'\n\ninterface BTableSimpleProps {\n  bordered?: Booleanish\n  borderless?: Booleanish\n  borderVariant?: ColorVariant\n  captionTop?: Booleanish\n  dark?: Booleanish\n  hover?: Booleanish\n  responsive?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl' // boolean | Breakpoint\n  stacked?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl' // boolean | Breakpoint\n  striped?: Booleanish\n  small?: Booleanish\n  tableClass?: ClassValue\n  tableVariant?: ColorVariant\n  stickyHeader?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BTableSimpleProps>(), {\n  bordered: false,\n  borderless: false,\n  captionTop: false,\n  dark: false,\n  hover: false,\n  responsive: false,\n  stacked: false,\n  striped: false,\n  small: false,\n  stickyHeader: false,\n})\n\nconst captionTopBoolean = useBooleanish(toRef(props, 'captionTop'))\nconst borderlessBoolean = useBooleanish(toRef(props, 'borderless'))\nconst borderedBoolean = useBooleanish(toRef(props, 'bordered'))\nconst darkBoolean = useBooleanish(toRef(props, 'dark'))\nconst hoverBoolean = useBooleanish(toRef(props, 'hover'))\nconst smallBoolean = useBooleanish(toRef(props, 'small'))\nconst stripedBoolean = useBooleanish(toRef(props, 'striped'))\nconst stickyHeaderBoolean = useBooleanish(toRef(props, 'stickyHeader'))\n\nconst computedClasses = computed(() => [\n  'table',\n  'b-table',\n  {\n    'table-bordered': borderedBoolean.value,\n    'table-borderless': borderlessBoolean.value,\n    [`border-${props.borderVariant}`]: props.borderVariant !== undefined,\n    'caption-top': captionTopBoolean.value,\n    'table-dark': darkBoolean.value,\n    'table-hover': hoverBoolean.value,\n    'b-table-stacked': typeof props.stacked === 'boolean' && props.stacked,\n    [`b-table-stacked-${props.stacked}`]: typeof props.stacked === 'string',\n    'table-striped': stripedBoolean.value,\n    'table-sm': smallBoolean.value,\n    [`table-${props.tableVariant}`]: props.tableVariant !== undefined,\n  },\n  props.tableClass,\n])\n\nconst responsiveClasses = computed(() => [\n  {\n    'table-responsive': props.responsive === true,\n    [`table-responsive-${props.responsive}`]: typeof props.responsive === 'string',\n    'b-table-sticky-header': stickyHeaderBoolean.value,\n  },\n])\n</script>\n","<template>\n  <b-table-simple>\n    <slot v-if=\"!hideHeaderBoolean\" name=\"thead\">\n      <thead>\n        <tr>\n          <th v-for=\"(_, i) in computedHeaderColumnsLength\" :key=\"i\">\n            <b-placeholder v-bind=\"headerAttrs\" />\n          </th>\n        </tr>\n      </thead>\n    </slot>\n    <slot>\n      <tbody>\n        <tr v-for=\"(_, j) in rowsNumber\" :key=\"j\">\n          <td v-for=\"(__, k) in columnsNumber\" :key=\"k\">\n            <b-placeholder v-bind=\"placeholderAttrs\" />\n          </td>\n        </tr>\n      </tbody>\n    </slot>\n    <slot v-if=\"showFooterBoolean\" name=\"tfoot\">\n      <tfoot>\n        <tr>\n          <th v-for=\"(_, l) in computedFooterColumnsLength\" :key=\"l\">\n            <b-placeholder v-bind=\"footerAttrs\" />\n          </th>\n        </tr>\n      </tfoot>\n    </slot>\n  </b-table-simple>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSkeletonTableProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BTableSimple from '../BTable/BTableSimple.vue'\nimport BPlaceholder from './BPlaceholder.vue'\nimport {stringToInteger} from '../../utils'\n\ninterface BSkeletonTableProps {\n  rows?: string | number\n  columns?: string | number\n  cellWidth?: string | number\n  size?: PlaceholderSize\n  animation?: PlaceholderAnimation\n  variant?: ColorVariant\n  headerColumns?: string | number\n  hideHeader?: Booleanish\n  headerCellWidth?: string | number\n  headerSize?: PlaceholderSize\n  headerAnimation?: PlaceholderAnimation\n  headerVariant?: ColorVariant\n  footerColumns?: string | number\n  showFooter?: Booleanish\n  footerCellWidth?: string | number\n  footerSize?: PlaceholderSize\n  footerAnimation?: PlaceholderAnimation\n  footerVariant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BSkeletonTableProps>(), {\n  columns: 5,\n  rows: 3,\n  cellWidth: 100,\n  showFooter: false,\n  footerCellWidth: 100,\n  hideHeader: false,\n  headerCellWidth: 100,\n})\n\nconst columnsNumber = computed<number>(() =>\n  // Keep '5' default in line with columns default above\n  typeof props.columns === 'string' ? stringToInteger(props.columns, 5) : props.columns\n)\nconst rowsNumber = computed<number>(() =>\n  // Keep '3' default in line with rows default above\n  typeof props.rows === 'string' ? stringToInteger(props.rows, 3) : props.rows\n)\nconst computedHeaderColumnsLength = computed<number>(() =>\n  props.headerColumns === undefined\n    ? columnsNumber.value\n    : typeof props.headerColumns === 'string'\n    ? stringToInteger(props.headerColumns, columnsNumber.value)\n    : props.headerColumns\n)\nconst computedFooterColumnsLength = computed<number>(() =>\n  props.footerColumns === undefined\n    ? columnsNumber.value\n    : typeof props.footerColumns === 'string'\n    ? stringToInteger(props.footerColumns, columnsNumber.value)\n    : props.footerColumns\n)\n\nconst placeholderAttrs = computed(() => ({\n  size: props.size,\n  variant: props.variant,\n  animation: props.animation,\n  width: props.cellWidth,\n}))\n\nconst headerAttrs = computed(() => ({\n  size: props.headerSize,\n  variant: props.headerVariant,\n  animation: props.headerAnimation,\n  width: props.headerCellWidth,\n}))\n\nconst footerAttrs = computed(() => ({\n  size: props.footerSize,\n  variant: props.footerVariant,\n  animation: props.footerAnimation,\n  width: props.footerCellWidth,\n}))\n\nconst hideHeaderBoolean = useBooleanish(toRef(props, 'hideHeader'))\nconst showFooterBoolean = useBooleanish(toRef(props, 'showFooter'))\n</script>\n","<template>\n  <slot v-if=\"loadingBoolean\" name=\"loading\" />\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {toRef} from 'vue'\n\ninterface BPlaceholderWrapperProps {\n  loading?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BPlaceholderWrapperProps>(), {\n  loading: false,\n})\n\nconst loadingBoolean = useBooleanish(toRef(props, 'loading'))\n</script>\n","<template>\n  <div\n    :id=\"id\"\n    ref=\"element\"\n    class=\"popover b-popover\"\n    :class=\"computedClasses\"\n    role=\"tooltip\"\n    tabindex=\"-1\"\n  >\n    <div ref=\"titleRef\">\n      <slot name=\"title\">\n        {{ title }}\n      </slot>\n    </div>\n    <div ref=\"contentRef\">\n      <slot>\n        {{ content }}\n      </slot>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  type ComponentPublicInstance,\n  computed,\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  type PropType,\n  ref,\n  toRef,\n  watch,\n} from 'vue'\nimport {Popover} from 'bootstrap'\nimport {useBooleanish} from '../composables'\nimport type {BPopoverDelayObject} from '../types/components'\nimport type {Booleanish, ColorVariant} from '../types'\n\nexport default defineComponent({\n  props: {\n    container: {\n      type: [String, Object] as PropType<\n        string | ComponentPublicInstance<HTMLElement> | HTMLElement\n      >,\n      default: 'body',\n    },\n    content: {type: String},\n    id: {type: String},\n    customClass: {type: String, default: ''},\n    noninteractive: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    placement: {type: String as PropType<Popover.Options['placement']>, default: 'right'},\n    target: {\n      type: [String, Object] as PropType<\n        string | ComponentPublicInstance<HTMLElement> | HTMLElement | undefined\n      >,\n      default: undefined,\n    },\n    title: {type: String},\n    delay: {type: [Number, Object] as PropType<number | BPopoverDelayObject>, default: 0},\n    triggers: {type: String as PropType<Popover.Options['trigger']>, default: 'click'},\n    show: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    variant: {type: String as PropType<ColorVariant>, default: undefined},\n    html: {type: [Boolean, String] as PropType<Booleanish>, default: true},\n    sanitize: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    offset: {type: String as PropType<Popover.Options['offset']>, default: '0'},\n  },\n  emits: ['show', 'shown', 'hide', 'hidden', 'inserted'],\n  setup(props, {emit, slots}) {\n    // TODO noninteractive is never used\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const noninteractiveBoolean = useBooleanish(toRef(props, 'noninteractive'))\n    const showBoolean = useBooleanish(toRef(props, 'show'))\n    const htmlBoolean = useBooleanish(toRef(props, 'html'))\n    const sanitizeBoolean = useBooleanish(toRef(props, 'sanitize'))\n\n    const element = ref<HTMLElement>()\n    const target = ref<HTMLElement | undefined>()\n    const instance = ref<Popover>()\n    const titleRef = ref<HTMLElement>()\n    const contentRef = ref<HTMLElement>()\n\n    const computedClasses = computed(() => ({\n      [`b-popover-${props.variant}`]: props.variant !== undefined,\n    }))\n\n    const cleanElementProp = (\n      target: string | ComponentPublicInstance<HTMLElement> | HTMLElement | undefined\n    ): HTMLElement | string | undefined => {\n      if (typeof target === 'string') {\n        return target\n      } else if (target instanceof HTMLElement) return target\n      else if (typeof target !== 'undefined')\n        return (target as ComponentPublicInstance<HTMLElement>).$el as HTMLElement\n      return undefined\n    }\n\n    const getElement = (element: HTMLElement | string | undefined): HTMLElement | undefined => {\n      if (!element) return undefined\n      if (typeof element === 'string') {\n        const idElement = document.getElementById(element)\n        return idElement ? idElement : undefined\n      }\n      return element\n    }\n\n    const bsEventHandlers = [\n      {event: 'show.bs.popover', handler: () => emit('show')},\n      {event: 'shown.bs.popover', handler: () => emit('shown')},\n      {event: 'hide.bs.popover', handler: () => emit('hide')},\n      {event: 'hidden.bs.popover', handler: () => emit('hidden')},\n      {event: 'inserted.bs.popover', handler: () => emit('inserted')},\n    ]\n\n    const attachTargetEventHandlers = (targetElement: HTMLElement) => {\n      for (const pair of bsEventHandlers) {\n        targetElement.addEventListener(pair.event, pair.handler)\n      }\n    }\n\n    const disposeTargetEventHandlers = (targetElement: HTMLElement) => {\n      for (const pair of bsEventHandlers) {\n        targetElement.removeEventListener(pair.event, pair.handler)\n      }\n    }\n\n    const generatePopoverInstance = (\n      targetValue: string | ComponentPublicInstance<HTMLElement> | HTMLElement | undefined\n    ) => {\n      target.value = getElement(cleanElementProp(targetValue))\n\n      if (!target.value) return\n\n      attachTargetEventHandlers(target.value)\n\n      instance.value = new Popover(target.value, {\n        customClass: props.customClass,\n        container: cleanElementProp(props.container),\n        trigger: props.triggers,\n        placement: props.placement,\n        title: props.title || slots.title ? titleRef.value : '',\n        content: contentRef.value,\n        html: htmlBoolean.value,\n        delay: props.delay,\n        sanitize: sanitizeBoolean.value,\n        offset: props.offset,\n      })\n    }\n\n    watch(\n      () => props.target,\n      (newValue) => {\n        instance.value?.dispose()\n        if (target.value instanceof HTMLElement) {\n          disposeTargetEventHandlers(target.value)\n        }\n        generatePopoverInstance(newValue)\n      }\n    )\n    watch(\n      () => showBoolean.value,\n      (show, oldVal) => {\n        if (show !== oldVal) {\n          if (show) {\n            instance.value?.show()\n          } else {\n            instance.value?.hide()\n          }\n        }\n      }\n    )\n\n    onMounted(() => {\n      nextTick(() => {\n        generatePopoverInstance(props.target)\n      })\n\n      element.value?.parentNode?.removeChild(element.value)\n\n      if (showBoolean.value) {\n        instance.value?.show()\n      }\n    })\n\n    onBeforeUnmount(() => {\n      instance.value?.dispose()\n      if (target.value instanceof HTMLElement) {\n        disposeTargetEventHandlers(target.value)\n      }\n    })\n\n    return {\n      element,\n      titleRef,\n      contentRef,\n      computedClasses,\n    }\n  },\n})\n</script>\n","<template>\n  <div\n    class=\"progress-bar\"\n    :class=\"computedClasses\"\n    role=\"progressbar\"\n    :aria-valuenow=\"value\"\n    aria-valuemin=\"0\"\n    :aria-valuemax=\"max\"\n    :style=\"{width: computedWidth}\"\n  >\n    <slot>\n      {{ computedLabel }}\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant} from '../../types'\nimport type {BProgressParentData} from '../../types/components'\nimport {useBooleanish} from '../../composables'\nimport {computed, inject, toRef} from 'vue'\nimport {injectionKey} from './BProgress.vue'\n\ninterface Props {\n  animated?: Booleanish\n  label?: string\n  labelHtml?: string\n  max?: string | number\n  precision?: string | number\n  showProgress?: Booleanish\n  showValue?: Booleanish\n  striped?: Booleanish\n  value?: string | number\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  animated: false,\n  precision: 0,\n  showProgress: false,\n  showValue: false,\n  striped: false,\n  value: 0,\n})\n\nconst parent = inject<BProgressParentData>(injectionKey)\n\nconst animatedBoolean = useBooleanish(toRef(props, 'animated'))\nconst showProgressBoolean = useBooleanish(toRef(props, 'showProgress'))\nconst showValueBoolean = useBooleanish(toRef(props, 'showValue'))\nconst stripedBoolean = useBooleanish(toRef(props, 'striped'))\n\nconst computedClasses = computed(() => ({\n  'progress-bar-animated': animatedBoolean.value || parent?.animated,\n  'progress-bar-striped':\n    stripedBoolean.value || parent?.striped || animatedBoolean.value || parent?.animated,\n  [`bg-${props.variant}`]: props.variant !== undefined,\n}))\n\nconst numberPrecision = computed<number>(() =>\n  typeof props.precision === 'number' ? props.precision : Number.parseFloat(props.precision)\n)\n\nconst numberValue = computed<number>(() =>\n  typeof props.value === 'number' ? props.value : Number.parseFloat(props.value)\n)\n\nconst numberMax = computed<number | undefined>(() =>\n  typeof props.max === 'number'\n    ? props.max\n    : props.max === undefined\n    ? undefined\n    : Number.parseFloat(props.max)\n)\n\nconst computedLabel = computed<string>(() =>\n  props.labelHtml !== undefined\n    ? props.labelHtml\n    : showValueBoolean.value || parent?.showValue\n    ? numberValue.value.toFixed(numberPrecision.value)\n    : showProgressBoolean.value || parent?.showProgress\n    ? ((numberValue.value * 100) / (numberMax.value || 100)).toFixed(numberPrecision.value)\n    : props.label !== undefined\n    ? props.label\n    : ''\n)\n\nconst computedWidth = computed<string>(() =>\n  parent?.max\n    ? `${\n        (numberValue.value * 100) /\n        (typeof parent.max === 'number' ? parent.max : Number.parseInt(parent.max))\n      }%`\n    : props.max\n    ? `${\n        (numberValue.value * 100) /\n        (typeof props.max === 'number' ? props.max : Number.parseInt(props.max))\n      }%`\n    : typeof props.value === 'string'\n    ? props.value\n    : `${props.value}%`\n)\n</script>\n","<template>\n  <div class=\"progress\" :style=\"{height}\">\n    <slot>\n      <b-progress-bar v-bind=\"computedAttrs\" />\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BProgressProps} from '../types/components'\nimport BProgressBar from './BProgressBar.vue'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, InjectionKey, provide, toRef} from 'vue'\n\ninterface BProgressProps {\n  variant?: ColorVariant\n  max?: number | string\n  height?: string\n  animated?: Booleanish\n  precision?: number | string\n  showProgress?: Booleanish\n  showValue?: Booleanish\n  striped?: Booleanish\n  value?: number | string\n}\n\nconst props = withDefaults(defineProps<BProgressProps>(), {\n  animated: false,\n  precision: 0,\n  showProgress: false,\n  showValue: false,\n  striped: false,\n  value: 0,\n})\n\nconst animatedBoolean = useBooleanish(toRef(props, 'animated'))\nconst showProgressBoolean = useBooleanish(toRef(props, 'showProgress'))\nconst showValueBoolean = useBooleanish(toRef(props, 'showValue'))\nconst stripedBoolean = useBooleanish(toRef(props, 'striped'))\n\nconst computedAttrs = computed(() => ({\n  animated: props.animated,\n  max: props.max,\n  precision: props.precision,\n  showProgress: props.showProgress,\n  showValue: props.showValue,\n  striped: props.striped,\n  value: props.value,\n  variant: props.variant,\n}))\n\nprovide(injectionKey, {\n  animated: animatedBoolean.value,\n  max: props.max,\n  showProgress: showProgressBoolean.value,\n  showValue: showValueBoolean.value,\n  striped: stripedBoolean.value,\n})\n</script>\n\n<script lang=\"ts\">\nimport type {BProgressParentData} from '../../types/components'\nexport const injectionKey: InjectionKey<BProgressParentData> = Symbol()\n</script>\n","<template>\n  <component :is=\"tag\" class=\"row\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, toRef} from 'vue'\nimport {getBreakpointProps, getClasses} from '../utils'\nimport type {Alignment, Booleanish} from '../types'\nimport {useAlignment, useBooleanish} from '../composables'\n\nconst rowColsProps = getBreakpointProps('cols', [''], {type: [String, Number], default: null})\n\nexport default defineComponent({\n  name: 'BRow',\n  props: {\n    tag: {type: String, default: 'div'},\n    gutterX: {type: String, default: null},\n    gutterY: {type: String, default: null},\n    noGutters: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    alignV: {type: String as PropType<Alignment.Vertical>, default: null},\n    alignH: {type: String as PropType<Alignment.JustifyContent>, default: null},\n    alignContent: {type: String as PropType<Alignment.Content>, default: null},\n    ...rowColsProps,\n  },\n  setup(props) {\n    const noGuttersBoolean = useBooleanish(toRef(props, 'noGutters'))\n    const alignment = useAlignment(toRef(props, 'alignH'))\n\n    const rowColsClasses = computed(() => getClasses(props, rowColsProps, 'cols', 'row-cols'))\n\n    const computedClasses = computed(() => [\n      rowColsClasses.value,\n      {\n        [`gx-${props.gutterX}`]: props.gutterX !== null,\n        [`gy-${props.gutterY}`]: props.gutterY !== null,\n        'g-0': noGuttersBoolean.value,\n        [`align-items-${props.alignV}`]: props.alignV !== null,\n        [alignment.value]: props.alignH !== null,\n        [`align-content-${props.alignContent}`]: props.alignContent !== null,\n      },\n    ])\n\n    return {\n      computedClasses,\n    }\n  },\n})\n</script>\n","<template>\n  <div class=\"b-skeleton\" :class=\"computedClasses\" :style=\"style\" />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSkeletonProps} from '../../types/components'\nimport {computed, type StyleValue} from 'vue'\nimport type {ColorVariant, SkeletonAnimation, SkeletonType} from '../../types'\n\ninterface BSkeletonProps {\n  height?: string\n  width?: string\n  size?: string\n  animation?: SkeletonAnimation\n  type?: SkeletonType\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BSkeletonProps>(), {\n  animation: 'wave',\n  type: 'text',\n})\n\nconst computedClasses = computed(() => [\n  `b-skeleton-${props.type}`,\n  {\n    [`b-skeleton-animate-${props.animation}`]:\n      typeof props.animation === 'boolean' ? false : props.animation,\n    [`bg-${props.variant}`]: props.variant !== undefined,\n  },\n])\n\nconst style = computed<StyleValue>(() => ({\n  width: props.size || props.width,\n  height: props.size || props.height,\n}))\n</script>\n","<template>\n  <div\n    class=\"b-skeleton-icon-wrapper position-relative d-inline-block overflow-hidden\"\n    :class=\"computedClasses\"\n  >\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSkeletonIconProps} from '../../types/components'\nimport {computed} from 'vue'\nimport type {SkeletonAnimation} from '../../types'\n\ninterface BSkeletonIconProps {\n  animation?: SkeletonAnimation\n}\n\nconst props = withDefaults(defineProps<BSkeletonIconProps>(), {\n  animation: 'wave',\n})\n\nconst computedClasses = computed(() => [`b-skeleton-animate-${props.animation}`])\n</script>\n","<template>\n  <b-table-simple v-bind=\"tableProps\">\n    <thead v-if=\"!hideHeaderBoolean\">\n      <tr>\n        <th v-for=\"(_th, i) in columns\" :key=\"i\">\n          <b-skeleton />\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr v-for=\"(_tr, j) in rows\" :key=\"j\">\n        <td v-for=\"(_td, k) in columns\" :key=\"k\">\n          <b-skeleton width=\"75%\" />\n        </td>\n      </tr>\n    </tbody>\n    <tfoot v-if=\"showFooterBoolean\">\n      <tr>\n        <th v-for=\"(_th, l) in columns\" :key=\"l\">\n          <b-skeleton />\n        </th>\n      </tr>\n    </tfoot>\n  </b-table-simple>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSkeletonTableProps} from '../../types/components'\nimport {toRef} from 'vue'\nimport type {Booleanish, SkeletonAnimation} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BTableSimple from '../BTable/BTableSimple.vue'\nimport BSkeleton from './BSkeleton.vue'\n\ninterface BSkeletonTableProps {\n  animation?: SkeletonAnimation\n  columns?: number\n  hideHeader?: Booleanish\n  rows?: number\n  showFooter?: Booleanish\n  tableProps?: Record<string, unknown>\n}\n\nconst props = withDefaults(defineProps<BSkeletonTableProps>(), {\n  animation: 'wave',\n  columns: 5,\n  hideHeader: false,\n  rows: 3,\n  showFooter: false,\n})\n\nconst hideHeaderBoolean = useBooleanish(toRef(props, 'hideHeader'))\nconst showFooterBoolean = useBooleanish(toRef(props, 'showFooter'))\n</script>\n","<template>\n  <slot v-if=\"loadingBoolean\" name=\"loading\" />\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSkeletonWrapperProps} from '../../types/components'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {toRef} from 'vue'\n\ninterface BSkeletonWrapperProps {\n  loading?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BSkeletonWrapperProps>(), {\n  loading: false,\n})\n\nconst loadingBoolean = useBooleanish(toRef(props, 'loading'))\n</script>\n","import {RX_STRIP_LOCALE_MODS} from '../constants/regex'\nimport {toString} from './stringUtils'\n\n// Languages that are RTL\nconst RTL_LANGS = [\n  'ar',\n  'az',\n  'ckb',\n  'fa',\n  'he',\n  'ks',\n  'lrc',\n  'mzn',\n  'ps',\n  'sd',\n  'te',\n  'ug',\n  'ur',\n  'yi',\n].map((locale) => locale.toLowerCase())\n\n// Returns true if the locale is RTL\nexport const isLocaleRTL = (locale: string) => {\n  // Determines if the locale is RTL (only single locale supported)\n  const parts = toString(locale).toLowerCase().replace(RX_STRIP_LOCALE_MODS, '').split('-')\n  const locale1 = parts.slice(0, 2).join('-')\n  const locale2 = parts[0]\n  return RTL_LANGS.includes(locale1) || RTL_LANGS.includes(locale2)\n}\n","import {HAS_PASSIVE_EVENT_SUPPORT} from './env'\nimport {isObject} from './inspect'\n\n// Normalize event options based on support of passive option\n// Exported only for testing purposes\nexport const parseEventOptions = (options: any): boolean | EventListenerOptions | undefined => {\n  /* istanbul ignore else: can't test in JSDOM, as it supports passive */\n  if (HAS_PASSIVE_EVENT_SUPPORT) {\n    return isObject(options) ? options : {capture: !!options || false}\n  } else {\n    // Need to translate to actual Boolean value\n    return !!(isObject(options) ? options.capture : options)\n  }\n}\n\n// Attach an event listener to an element\nexport const eventOn = (\n  el: Element,\n  eventName: string,\n  handler: EventListener,\n  options: boolean | EventListenerOptions | undefined\n) => {\n  if (el && el.addEventListener) {\n    el.addEventListener(eventName, handler, parseEventOptions(options))\n  }\n}\n\n// Remove an event listener from an element\nexport const eventOff = (\n  el: Element,\n  eventName: string,\n  handler: EventListener,\n  options: boolean | EventListenerOptions | undefined\n) => {\n  if (el && el.removeEventListener) {\n    el.removeEventListener(eventName, handler, options)\n  }\n}\n\n// Utility method to add/remove a event listener based on first argument (boolean)\n// It passes all other arguments to the `eventOn()` or `eventOff` method\nexport const eventOnOff = (on: Boolean, eventParams: Parameters<typeof eventOff>) => {\n  const method = on ? eventOn : eventOff\n  method(...eventParams)\n}\n\n//checks to see if keyboard event\nexport const isKeyBoardEvent = (event: Event): event is KeyboardEvent =>\n  ['keydown', 'keypress', 'keyup'].includes(event.type)\n\n// Utility method to prevent the default event handling and propagation\nexport const stopEvent = (\n  event: Event,\n  {preventDefault = true, propagation = true, immediatePropagation = false} = {}\n) => {\n  if (preventDefault) {\n    event.preventDefault()\n  }\n  if (propagation) {\n    event.stopPropagation()\n  }\n  if (immediatePropagation) {\n    event.stopImmediatePropagation()\n  }\n}\n","export const CODE_BACKSPACE: string = 'Backspace'\nexport const CODE_BREAK = 19\nexport const CODE_DELETE = 46\nexport const CODE_DOWN: string = 'ArrowDown'\nexport const CODE_END: string = 'End'\nexport const CODE_ENTER = 13\nexport const CODE_ESC = 27\nexport const CODE_HOME: string = 'Home'\nexport const CODE_LEFT = 37\nexport const CODE_PAGEDOWN: string = 'PageDown'\nexport const CODE_PAGEUP: string = 'PageUp'\nexport const CODE_RIGHT = 39\nexport const CODE_SPACE = 32\nexport const CODE_UP: string = 'ArrowUp'\n","<script lang=\"ts\">\nimport {computed, type ComputedRef, defineComponent, h, type PropType, ref, type Ref} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {toFloat, toInteger} from '../../utils/number'\nimport {isNull} from '../../utils/inspect'\nimport {isLocaleRTL} from '../../utils/locale'\nimport {eventOnOff, stopEvent} from '../../utils/event'\nimport {normalizeSlot} from '../../utils'\n// import {attemptBlur, attemptFocus, normalizeSlot} from '../../utils'\n//TODO alias\n// import {BIconDash, BIconPlus} from 'bootstrap-vue-3-icons'\n\nimport {\n  CODE_DOWN,\n  CODE_END,\n  CODE_HOME,\n  CODE_PAGEDOWN,\n  CODE_PAGEUP,\n  CODE_UP,\n} from '../../constants/codes'\n\n// Default for spin button range and step\nconst DEFAULT_MIN = 1\nconst DEFAULT_MAX = 100\nconst DEFAULT_STEP = 1\n\n// Delay before auto-repeat in ms\nconst DEFAULT_REPEAT_DELAY = 500\n// Repeat interval in ms\nconst DEFAULT_REPEAT_INTERVAL = 100\n// Repeat rate increased after number of repeats\nconst DEFAULT_REPEAT_THRESHOLD = 10\n// Repeat speed multiplier (step multiplier, must be an integer)\nconst DEFAULT_REPEAT_MULTIPLIER = 4\n\nconst KEY_CODES = [CODE_UP, CODE_DOWN, CODE_HOME, CODE_END, CODE_PAGEUP, CODE_PAGEDOWN]\n\nexport default defineComponent({\n  props: {\n    ariaControls: {type: String, required: false},\n    ariaLabel: {type: String, required: false},\n    labelIncrement: {type: String, default: 'Increment'},\n    labelDecrement: {type: String, default: 'Decrement'},\n    modelValue: {type: Number, default: null}, // V-model prop\n    name: {type: String, default: 'BFormSpinbutton'},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    placeholder: {type: String, required: false},\n    locale: {type: String, default: 'locale'},\n    form: {type: String, required: false},\n    inline: {type: Boolean, default: false},\n    size: {type: String, required: false},\n    formatterFn: {\n      type: Function as PropType<(value: number) => any>,\n    },\n    readonly: {type: Boolean, default: false},\n    vertical: {type: Boolean, default: false},\n    repeatDelay: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_DELAY,\n    },\n    repeatInterval: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_INTERVAL,\n    },\n    repeatStepMultiplier: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_MULTIPLIER,\n    },\n    repeatThreshold: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_THRESHOLD,\n    },\n    required: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    step: {type: [String, Number] as PropType<number | string>, default: DEFAULT_STEP},\n    min: {type: [String, Number] as PropType<number | string>, default: DEFAULT_MIN},\n    max: {type: [String, Number] as PropType<number | string>, default: DEFAULT_MAX},\n    wrap: {type: Boolean, default: false},\n    state: {type: [Boolean, String] as PropType<Booleanish | null>, default: null},\n  },\n  emits: ['update:modelValue', 'change'],\n  setup(props, {emit}) {\n    const hasFocus = ref(false)\n    const spinId = computed(() => 1) //TODO\n\n    const emitChange = () => {\n      emit('change', localValue.value)\n    }\n\n    // due to modelValue being optional we will need to store changes locally\n    const lvalue: Ref<null | number> = ref(null)\n\n    const localValue = computed({\n      get() {\n        return isNull(props.modelValue) ? lvalue.value : props.modelValue\n      },\n      set(newValue) {\n        if (isNull(props.modelValue)) {\n          lvalue.value = newValue\n        } else {\n          emit('update:modelValue', newValue)\n        }\n      },\n    })\n    //non reactive properties\n    let $_autoDelayTimer: ReturnType<typeof setTimeout> | undefined\n    let $_autoRepeatTimer: ReturnType<typeof setTimeout> | undefined\n    let $_keyIsDown = false\n\n    // const computedInline = computed(() => props.inline && !props.vertical)\n\n    // const computedReadonly = computed(() => props.readonly && !props.disabled)\n\n    const computedStep = computed(() => toFloat(props.step, DEFAULT_STEP))\n\n    const computedMin = computed(() => toFloat(props.min, DEFAULT_MIN))\n\n    const computedMax = computed(() => {\n      const max = toFloat(props.max, DEFAULT_MAX)\n      const step = computedStep.value\n      const min = computedMin.value\n      return Math.floor((max - min) / step) * step + min\n    })\n\n    const computedDelay = computed(() => {\n      const delay = toInteger(props.repeatDelay as number, 0)\n      return delay > 0 ? delay : DEFAULT_REPEAT_DELAY\n    })\n\n    const computedInterval = computed(() => {\n      const interval = toInteger(props.repeatInterval as number, 0)\n      return interval > 0 ? interval : DEFAULT_REPEAT_INTERVAL\n    })\n\n    const computedThreshold = computed(() =>\n      Math.max(toInteger(props.repeatThreshold as number, DEFAULT_REPEAT_THRESHOLD), 1)\n    )\n\n    const computedStepMultiplier = computed(() =>\n      Math.max(toInteger(props.repeatStepMultiplier as number, DEFAULT_REPEAT_MULTIPLIER), 1)\n    )\n\n    const computedPrecision = computed(() => {\n      const step = computedStep.value\n      return Math.floor(step) === step ? 0 : (step.toString().split('.')[1] || '').length\n    })\n\n    const computedMultiplier = computed(() => Math.pow(10, computedPrecision.value || 0))\n\n    const valueAsFixed = computed(() => {\n      const {value} = localValue\n      return value === null ? '' : value.toFixed(computedPrecision.value)\n    })\n\n    const computedLocale = computed(() => {\n      //todo\n      const locales = [props.locale]\n      const nf = new Intl.NumberFormat(locales)\n      return nf.resolvedOptions().locale\n    })\n\n    const computedRTL = computed(() =>\n      //todo\n      isLocaleRTL(computedLocale.value)\n    )\n\n    const defaultFormatter = () => {\n      //locale needs to be resolved\n      // Returns and `Intl.NumberFormat` formatter method reference\n      const precision = computedPrecision.value\n      const nf = new Intl.NumberFormat(computedLocale.value, {\n        style: 'decimal',\n        useGrouping: false,\n        minimumIntegerDigits: 1,\n        minimumFractionDigits: precision,\n        maximumFractionDigits: precision,\n        notation: 'standard',\n      })\n\n      return nf.format\n    }\n    //TODO allow for prop formatter function\n    const computedFormatter = computed(() =>\n      props.formatterFn ? props.formatterFn : defaultFormatter()\n    )\n\n    const computedAttrs = computed(() => ({\n      role: 'group',\n      lang: computedLocale.value,\n      tabindex: props.disabled ? null : '-1',\n      title: props.ariaLabel,\n    }))\n    const hasValue: ComputedRef = computed(() => !isNull(props.modelValue) || !isNull(lvalue.value))\n\n    const computedSpinAttrs = computed(() => ({\n      'dir': computedRTL.value,\n      'spinId': spinId.value,\n      'tabindex': props.disabled ? null : '0',\n      'role': 'spinbutton',\n      'aria-live': 'off',\n      'aria-label': props.ariaLabel || null,\n      'aria-controls': props.ariaControls || null,\n      'aria-invalid': props.state === false || (!hasValue.value && props.required) ? 'true' : null,\n      'aria-required': props.required ? 'true' : null,\n      'aria-valuemin': computedMin.value,\n      'aria-valuemax': computedMax.value,\n      'aria-valuenow': !isNull(localValue.value) ? localValue.value : null,\n      'aria-valuetext': !isNull(localValue.value)\n        ? computedFormatter.value(localValue.value)\n        : null,\n    }))\n\n    // methods\n\n    const stepValue = (direction: number) => {\n      // Sets a new incremented or decremented value, supporting optional wrapping\n      // Direction is either +1 or -1 (or a multiple thereof)\n      let {value} = localValue\n      if (!props.disabled && !isNull(value)) {\n        const step = computedStep.value * direction\n        const min = computedMin.value\n        const max = computedMax.value\n        const multiplier = computedMultiplier.value\n        const {wrap} = props\n        // We ensure that the value steps like a native input\n        value = Math.round((value - min) / step) * step + min + step\n        // We ensure that precision is maintained (decimals)\n        value = Math.round(value * multiplier) / multiplier\n        // Handle if wrapping is enabled\n        localValue.value =\n          value > max ? (wrap ? min : max) : value < min ? (wrap ? max : min) : value\n      }\n    }\n    // const onFocusBlur = (event: FocusEvent) => {\n    //   hasFocus.value = props.disabled ? false : event.type === 'focus'\n    // }\n\n    const stepUp = (multiplier = 1) => {\n      if (isNull(localValue.value)) {\n        localValue.value = computedMin.value\n      } else {\n        stepValue(+1 * multiplier)\n      }\n    }\n    const stepDown = (multiplier = 1) => {\n      if (isNull(localValue.value)) {\n        localValue.value = props.wrap ? computedMax.value : computedMin.value\n      } else {\n        stepValue(-1 * multiplier)\n      }\n    }\n\n    const onKeydown = (event: KeyboardEvent) => {\n      const {code, altKey, ctrlKey, metaKey} = event\n\n      /* istanbul ignore if */\n      if (props.disabled || props.readonly || altKey || ctrlKey || metaKey) {\n        return\n      }\n\n      if (KEY_CODES.includes(code)) {\n        // https://w3c.github.io/aria-practices/#spinbutton\n        stopEvent(event, {propagation: false})\n        /* istanbul ignore if */\n        if ($_keyIsDown) {\n          // Keypress is already in progress\n          return\n        }\n\n        resetTimers()\n        if ([CODE_UP, CODE_DOWN].includes(code)) {\n          // The following use the custom auto-repeat handling\n\n          $_keyIsDown = true\n          if (code === CODE_UP) {\n            handleStepRepeat(event, stepUp)\n          } else if (code === CODE_DOWN) {\n            handleStepRepeat(event, stepDown)\n          }\n        } else {\n          // These use native OS key repeating\n          if (code === CODE_PAGEUP) {\n            stepUp(computedStepMultiplier.value)\n          } else if (code === CODE_PAGEDOWN) {\n            stepDown(computedStepMultiplier.value)\n          } else if (code === CODE_HOME) {\n            localValue.value = computedMin.value\n          } else if (code === CODE_END) {\n            localValue.value = computedMax.value\n          }\n        }\n      }\n    }\n    const onKeyup = (event: KeyboardEvent) => {\n      // Emit a change event when the keyup happens\n\n      const {code, altKey, ctrlKey, metaKey} = event\n\n      /* istanbul ignore if */\n      if (props.disabled || props.readonly || altKey || ctrlKey || metaKey) {\n        return\n      }\n      if (KEY_CODES.includes(code)) {\n        stopEvent(event, {propagation: false})\n        resetTimers()\n        $_keyIsDown = false\n        emitChange()\n      }\n    }\n\n    // takes in a mount or Keyboard Event\n    const handleStepRepeat = (event: Event, stepper: (step: number) => void) => {\n      const {type} = event || {}\n\n      if (!props.disabled && !props.readonly) {\n        /* istanbul ignore if */\n        if (isMouseEvent(event)) {\n          if (type === 'mousedown' && event.button) {\n            // We only respond to left (main === 0) button clicks\n            return\n          }\n        }\n        resetTimers()\n        // Step the counter initially\n        stepper(1)\n        const threshold = computedThreshold.value\n        const multiplier = computedStepMultiplier.value\n        const delay = computedDelay.value\n        const interval = computedInterval.value\n\n        // Initiate the delay/repeat interval\n        $_autoDelayTimer = setTimeout(() => {\n          let count = 0\n          $_autoRepeatTimer = setInterval(() => {\n            // After N initial repeats, we increase the incrementing step amount\n            // We do this to minimize screen reader announcements of the value\n            // (values are announced every change, which can be chatty for SR users)\n            // And to make it easer to select a value when the range is large\n            stepper(count < threshold ? 1 : multiplier)\n            count++\n          }, interval)\n        }, delay)\n      }\n    }\n\n    function isMouseEvent(evt: Event): evt is MouseEvent {\n      return evt.type === 'mouseup' || evt.type === 'mousedown'\n    }\n    // eslint-disable-next-line no-undef\n    const onMouseup: EventListener = (event: Event) => {\n      // `<body>` listener, only enabled when mousedown starts\n\n      /* istanbul ignore if */\n      if (isMouseEvent(event)) {\n        if (event.type === 'mouseup' && event.button) {\n          // Ignore non left button (main === 0) mouse button click\n          return\n        }\n      }\n\n      stopEvent(event, {propagation: false})\n      resetTimers()\n      setMouseup(false)\n      // Trigger the change event\n      emitChange()\n    }\n\n    const setMouseup = (on: boolean) => {\n      // Enable or disabled the body mouseup/touchend handlers\n      // Use try/catch to handle case when called server side\n      try {\n        eventOnOff(on, [document.body, 'mouseup', onMouseup, false])\n        eventOnOff(on, [document.body, 'touchend', onMouseup, false])\n      } catch {\n        return 0\n      }\n    }\n    const resetTimers = () => {\n      clearTimeout($_autoDelayTimer)\n      clearInterval($_autoRepeatTimer)\n      $_autoDelayTimer = undefined\n      $_autoRepeatTimer = undefined\n    }\n\n    // const clearRepeat = () => {\n    //   resetTimers()\n    //   setMouseup(false)\n    //   $_keyIsDown = false\n    // }\n\n    // Render Helping functions\n    const makeButton = (\n      stepper: (multiplier?: number) => void,\n      label: string,\n      IconCmp: any,\n      keyRef: string,\n      shortcut: any,\n      btnDisabled: boolean,\n      slotName: string\n    ) => {\n      const $icon = h(IconCmp, {\n        props: {scale: hasFocus.value ? 1.5 : 1.25},\n        attrs: {'aria-hidden': 'true'},\n      })\n\n      const scope = {hasFocus: hasFocus.value}\n\n      const handler = (event: Event) => {\n        if (!props.disabled && !props.readonly) {\n          stopEvent(event, {propagation: false})\n          setMouseup(true)\n          // Since we `preventDefault()`, we must manually focus the button\n          // attemptFocus(event.currentTarget)\n          handleStepRepeat(event, stepper)\n        }\n      }\n\n      return h(\n        'button',\n        {\n          'class': [{'py-0': !props.vertical}, 'btn', 'btn-sm', 'border-0', 'rounded-0'],\n          'tabindex': '-1',\n          'type': 'button',\n          'disabled': props.disabled || props.readonly || btnDisabled,\n          'aria-disabled': props.disabled || props.readonly || btnDisabled ? 'true' : null,\n          'aria-controls': spinId.value,\n          'aria-label': label || null,\n          'aria-keyshortcuts': shortcut || null,\n          'onmousedown': handler,\n          'ontouchstart': handler,\n          // 'ref': keyRef,\n        },\n        [normalizeSlot(slotName, scope) || $icon]\n      )\n    }\n    return () => {\n      //component definitions\n      const $increment = makeButton(\n        stepUp,\n        props.labelIncrement,\n        h(\n          'svg',\n          {\n            xmlns: 'http://www.w3.org/2000/svg',\n            width: '16',\n            height: '16',\n            fill: 'currentColor',\n            class: 'bi bi-plus',\n            viewBox: '0 0 16 16',\n          },\n          h('path', {\n            d: 'M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z',\n          })\n        ),\n        'inc',\n        'ArrowUp',\n        false,\n        'increment'\n      )\n      const $decrement = makeButton(\n        stepDown,\n        props.labelDecrement,\n        h(\n          'svg',\n          {\n            xmlns: 'http://www.w3.org/2000/svg',\n            width: '16',\n            height: '16',\n            fill: 'currentColor',\n            class: 'bi bi-dash',\n            viewBox: '0 0 16 16',\n          },\n          h('path', {d: 'M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z'})\n        ),\n        'dec',\n        'ArrowDown',\n        false,\n        'decrement'\n      )\n\n      const $hidden = []\n\n      if (props.name && !props.disabled) {\n        $hidden.push(\n          h('input', {\n            type: 'hidden',\n            name: props.name,\n            form: props.form || null,\n            // TODO: Should this be set to '' if value is out of range?\n            value: valueAsFixed.value,\n            key: 'hidden',\n          })\n        )\n      }\n\n      const $spin = h(\n        // We use 'output' element to make this accept a `<label for=\"id\">` (Except IE)\n        'output',\n        {\n          class: [\n            {'d-flex': props.vertical},\n            {'align-self-center': !props.vertical},\n            {'align-items-center': props.vertical},\n            {'border-top': props.vertical},\n            {'border-bottom': props.vertical},\n            {'border-start': !props.vertical},\n            {'border-end': !props.vertical},\n            'flex-grow-1',\n          ],\n          ...computedSpinAttrs.value,\n          key: 'output',\n          // ref: 'spinner',\n        },\n        [\n          h(\n            'bdi',\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            //@ts-ignore How can we narrow this type down\n            hasValue.value ? computedFormatter.value(localValue.value) : props.placeholder || ''\n          ),\n        ]\n      )\n\n      return h(\n        'div',\n        {\n          class: [\n            'b-form-spinbutton form-control',\n            {disabled: props.disabled},\n            {readonly: props.readonly},\n            {focus: hasFocus},\n            {'d-inline-flex': props.inline || props.vertical},\n            {'d-flex': !props.inline && !props.vertical},\n            {'align-items-stretch': !props.vertical},\n            {'flex-column': props.vertical},\n            props.size ? `form-control-${props.size}` : null,\n            // this.stateClass //TODO\n          ],\n          ...computedAttrs.value,\n          onkeydown: onKeydown,\n          onkeyup: onKeyup,\n          // We use capture phase (`!` prefix) since focus and blur do not bubble\n          // 'focus': onFocusBlur, //TODO\n          // 'blur': onFocusBlur, //TODO\n        },\n        props.vertical\n          ? [$increment, $hidden, $spin, $decrement]\n          : [$decrement, $hidden, $spin, $increment]\n      )\n    }\n  },\n})\n</script>\n","import {closest, getAttr, getById, matches, select} from '../../../utils/dom'\n\nconst TABLE_TAG_NAMES = ['TD', 'TH', 'TR']\n\n// Filter CSS selector for click/dblclick/etc. events\n// If any of these selectors match the clicked element, we ignore the event\nexport const EVENT_FILTER = [\n  'a',\n  'a *', // Include content inside links\n  'button',\n  'button *', // Include content inside buttons\n  'input:not(.disabled):not([disabled])',\n  'select:not(.disabled):not([disabled])',\n  'textarea:not(.disabled):not([disabled])',\n  '[role=\"link\"]',\n  '[role=\"link\"] *',\n  '[role=\"button\"]',\n  '[role=\"button\"] *',\n  '[tabindex]:not(.disabled):not([disabled])',\n].join(',')\n\n// Returns `true` if we should ignore the click/double-click/keypress event\n// Avoids having the user need to use `@click.stop` on the form control\nexport const filterEvent = (event: Event) => {\n  // Exit early when we don't have a target element\n  if (!event || !event.target) {\n    return false\n  }\n  const el = event.target as HTMLElement\n  // Exit early when element is disabled or a table element\n  if (('disabled' in el && (el as any).disabled) || TABLE_TAG_NAMES.indexOf(el.tagName) !== -1) {\n    return false\n  }\n  // Ignore the click when it was inside a dropdown menu\n  if (closest('.dropdown-menu', el)) {\n    return true\n  }\n  const label = el.tagName === 'LABEL' ? el : closest('label', el)\n  // If the label's form control is not disabled then we don't propagate event\n  // Modern browsers have `label.control` that references the associated input, but IE 11\n  // does not have this property on the label element, so we resort to DOM lookups\n  if (label) {\n    const labelFor = getAttr(label, 'for')\n    const input = labelFor ? getById(labelFor) : select('input, select, textarea', label)\n    if (input && !input.disabled) {\n      return true\n    }\n  }\n  // Otherwise check if the event target matches one of the selectors in the\n  // event filter (i.e. anchors, non disabled inputs, etc.)\n  // Return `true` if we should ignore the event\n  return matches(el, EVENT_FILTER)\n}\n","import {ref, type Ref} from 'vue'\nimport type {TableField, TableFieldObject, TableItem} from '../../types'\nimport {isObject, startCase} from '../../utils'\nimport {BTableSortCompare} from './../../types/components'\nimport {cloneDeep, cloneDeepAsync} from './../../utils/object'\n\nexport default () => {\n  const normaliseFields = (origFields: TableField[], items: TableItem[]): TableFieldObject[] => {\n    const fields: TableFieldObject[] = []\n\n    if (!origFields?.length && items?.length) {\n      Object.keys(items[0]).forEach((k) => fields.push({key: k, label: startCase(k)}))\n      return fields\n    }\n\n    if (Array.isArray(origFields)) {\n      origFields.forEach((f) => {\n        if (typeof f === 'string') {\n          fields.push({key: f, label: startCase(f)})\n        } else if (isObject(f) && f.key && typeof f.key === 'string') {\n          fields.push({...f})\n        }\n        // todo handle Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }\n      })\n      return fields\n    }\n    return fields\n  }\n\n  const internalItems = ref<TableItem[]>([])\n\n  const mapItems = (\n    fields: TableField[],\n    items: TableItem[],\n    props: any,\n    flags: Record<string, Ref<boolean>>\n  ): TableItem[] => {\n    internalItems.value = cloneDeep(items)\n    if ('isFilterableTable' in flags && flags.isFilterableTable.value === true && props.filter) {\n      internalItems.value = filterItems(internalItems.value, props.filter, props.filterable)\n      // if (filterEvent.value) {\n      //   filterEvent.value(internalItems.value)\n      // }\n    }\n    if ('isSortable' in flags && flags.isSortable.value === true) {\n      internalItems.value = sortItems(\n        fields,\n        internalItems.value,\n        {\n          key: props.sortBy,\n          desc: flags.sortDescBoolean.value,\n        },\n        props.sortCompare\n      )\n    }\n    // if (props.perPage !== undefined) {\n    //   const startIndex = (props.currentPage - 1) * props.perPage\n    //   internalItems.value = internalItems.value.splice(startIndex, props.perPage)\n    // }\n    return internalItems.value\n  }\n\n  const filterEvent: Ref<((items: TableItem[]) => void) | undefined> = ref(undefined)\n\n  const sortItems = (\n    fields: TableField[],\n    items: TableItem<Record<string, any>>[],\n    sort: {key: string; desc: boolean},\n    sorter?: BTableSortCompare\n  ) => {\n    if (!sort || !sort.key) return items\n    const sortKey = sort.key\n    return items.sort((a, b) => {\n      if (sorter !== undefined) {\n        return sorter(a, b, sort.key, sort.desc)\n      }\n      const realVal = (ob: any) => (typeof ob === 'object' ? JSON.stringify(ob) : ob)\n      const aHigher = realVal(a[sortKey]) > realVal(b[sortKey])\n      if (aHigher) {\n        return sort.desc ? -1 : 1\n      }\n      const bHigher = realVal(b[sortKey]) > realVal(a[sortKey])\n      if (bHigher) {\n        return sort.desc ? 1 : -1\n      }\n      return 0\n    })\n  }\n\n  const filterItems = (\n    items: TableItem<Record<string, any>>[],\n    filter: string,\n    filterable: string[]\n  ) =>\n    items.filter(\n      (item) =>\n        Object.entries(item).filter((item) => {\n          const [key, val] = item\n          if (!val || key[0] === '_' || (filterable.length > 0 && !filterable.includes(key)))\n            return false\n          const itemValue: string =\n            typeof val === 'object'\n              ? JSON.stringify(Object.values(val))\n              : typeof val === 'string'\n              ? val\n              : val.toString()\n          return itemValue.toLowerCase().includes(filter.toLowerCase())\n        }).length > 0\n    )\n\n  const updateInternalItems = async (\n    items: TableItem<Record<string, any>>[]\n  ): Promise<TableItem[] | undefined> => {\n    try {\n      internalItems.value = await cloneDeepAsync(items)\n      return internalItems.value\n    } catch (err) {\n      return undefined\n    }\n  }\n\n  const notifyFilteredItems = () => {\n    if (filterEvent.value) {\n      filterEvent.value(internalItems.value)\n    }\n  }\n\n  const formatItem = (item: TableItem, fields: TableFieldObject) => {\n    const value = item[fields.key]\n    if (fields.formatter && typeof fields.formatter === 'function') {\n      return fields.formatter(value, fields.key, item)\n    }\n    return item[fields.key]\n  }\n\n  return {\n    normaliseFields,\n    mapItems,\n    internalItems,\n    updateInternalItems,\n    filterEvent,\n    notifyFilteredItems,\n    formatItem,\n  }\n}\n","<template>\n  <b-table-simple v-bind=\"containerAttrs\">\n    <!-- <table :class=\"classes\"> -->\n    <thead>\n      <slot v-if=\"$slots['thead-top']\" name=\"thead-top\" />\n      <tr>\n        <th\n          v-if=\"addSelectableCell\"\n          class=\"b-table-selection-column\"\n          :class=\"{\n            'b-table-sticky-column': stickySelectBoolean,\n          }\"\n        >\n          <slot name=\"select-head\">\n            {{ typeof selectHead === 'boolean' ? 'Selected' : selectHead }}\n          </slot>\n        </th>\n        <th\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :class=\"getFieldColumnClasses(field)\"\n          :title=\"field.headerTitle\"\n          :abbr=\"field.headerAbbr\"\n          :style=\"field.thStyle\"\n          v-bind=\"field.thAttr\"\n          @click=\"headerClicked(field, $event)\"\n        >\n          <div class=\"d-inline-flex flex-nowrap align-items-center gap-1\">\n            <slot\n              name=\"sort-icon\"\n              :field=\"field\"\n              :sort-by=\"sortBy\"\n              :selected=\"field.key === sortBy\"\n              :is-desc=\"sortDescBoolean\"\n              :direction=\"sortDescBoolean ? 'desc' : 'asc'\"\n            >\n              <span\n                v-if=\"isSortable && field.sortable\"\n                class=\"b-table-sort-icon\"\n                :class=\"{\n                  sorted: field.key === sortBy,\n                  [`sorted-${sortDescBoolean ? 'desc' : 'asc'}`]: field.key === sortBy,\n                }\"\n              />\n            </slot>\n            <div>\n              <slot\n                v-if=\"$slots['head(' + field.key + ')'] || $slots['head()']\"\n                :name=\"$slots['head(' + field.key + ')'] ? 'head(' + field.key + ')' : 'head()'\"\n                :label=\"field.label\"\n              />\n              <template v-else>{{ getFieldHeadLabel(field) }}</template>\n            </div>\n          </div>\n        </th>\n      </tr>\n      <tr v-if=\"$slots['thead-sub']\">\n        <td\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :class=\"[field.class, field.thClass, field.variant ? `table-${field.variant}` : '']\"\n        >\n          <slot\n            v-if=\"$slots['thead-sub']\"\n            name=\"thead-sub\"\n            :items=\"computedFields\"\n            v-bind=\"field\"\n          />\n          <template v-else>{{ field.label }}</template>\n        </td>\n      </tr>\n    </thead>\n    <tbody>\n      <template v-for=\"(item, itemIndex) in computedItems\" :key=\"itemIndex\">\n        <tr\n          :class=\"getRowClasses(item)\"\n          @click=\"!filterEvent($event) && onRowClick(item, itemIndex, $event)\"\n          @dblclick=\"!filterEvent($event) && onRowDblClick(item, itemIndex, $event)\"\n          @mouseenter=\"!filterEvent($event) && onRowMouseEnter(item, itemIndex, $event)\"\n          @mouseleave=\"!filterEvent($event) && onRowMouseLeave(item, itemIndex, $event)\"\n        >\n          <td\n            v-if=\"addSelectableCell\"\n            class=\"b-table-selection-column\"\n            :class=\"{\n              'b-table-sticky-column': stickySelectBoolean,\n            }\"\n          >\n            <slot name=\"select-cell\">\n              <span :class=\"selectedItems.has(item) ? 'text-primary' : ''\"></span>\n            </slot>\n          </td>\n          <td\n            v-for=\"field in computedFields\"\n            :key=\"field.key\"\n            v-bind=\"field.tdAttr\"\n            :class=\"getFieldRowClasses(field, item)\"\n          >\n            <label v-if=\"stacked && labelStackedBoolean\" class=\"b-table-stacked-label\">{{\n              getFieldHeadLabel(field)\n            }}</label>\n            <slot\n              v-if=\"$slots['cell(' + field.key + ')'] || $slots['cell()']\"\n              :name=\"$slots['cell(' + field.key + ')'] ? 'cell(' + field.key + ')' : 'cell()'\"\n              :value=\"item[field.key]\"\n              :index=\"itemIndex\"\n              :item=\"item\"\n              :field=\"field\"\n              :items=\"items\"\n              :toggle-details=\"() => toggleRowDetails(item)\"\n              :details-showing=\"item._showDetails\"\n            />\n            <template v-else>{{ itemHelper.formatItem(item, field) }}</template>\n          </td>\n        </tr>\n\n        <tr v-if=\"item._showDetails === true && $slots['row-details']\" :class=\"getRowClasses(item)\">\n          <td :colspan=\"computedFieldsTotal\">\n            <slot name=\"row-details\" :item=\"item\" :toggle-details=\"() => toggleRowDetails(item)\" />\n          </td>\n        </tr>\n      </template>\n      <tr\n        v-if=\"internalBusyFlag\"\n        class=\"b-table-busy-slot\"\n        :class=\"{'b-table-static-busy': computedItems.length == 0}\"\n      >\n        <td :colspan=\"computedFieldsTotal\">\n          <slot name=\"table-busy\">\n            <div class=\"d-flex align-items-center justify-content-center gap-2\">\n              <b-spinner class=\"align-middle\" />\n              <strong>Loading...</strong>\n            </div>\n          </slot>\n        </td>\n      </tr>\n      <tr v-if=\"showEmptyBoolean && computedItems.length === 0\" class=\"b-table-empty-slot\">\n        <td :colspan=\"computedFieldsTotal\">\n          <slot name=\"empty\" :items=\"computedItems\" :filtered=\"isFilterableTable\">\n            {{ isFilterableTable ? emptyFilteredText : emptyText }}\n          </slot>\n        </td>\n      </tr>\n    </tbody>\n    <tfoot v-if=\"footCloneBoolean\">\n      <tr>\n        <th\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          v-bind=\"field.thAttr\"\n          scope=\"col\"\n          :class=\"[field.class, field.thClass, field.variant ? `table-${field.variant}` : '']\"\n          :title=\"field.headerTitle\"\n          :abbr=\"field.headerAbbr\"\n          :style=\"field.thStyle\"\n          @click=\"headerClicked(field, $event, true)\"\n        >\n          {{ field.label }}\n        </th>\n      </tr>\n    </tfoot>\n    <tfoot v-else-if=\"$slots['custom-foot']\">\n      <slot\n        name=\"custom-foot\"\n        :fields=\"computedFields\"\n        :items=\"items\"\n        :columns=\"computedFields?.length\"\n      />\n    </tfoot>\n    <caption v-if=\"$slots['table-caption']\">\n      <slot name=\"table-caption\" />\n    </caption>\n    <caption v-else-if=\"caption\">\n      {{\n        caption\n      }}\n    </caption>\n    <!-- </table> -->\n  </b-table-simple>\n</template>\n\n<script setup lang=\"ts\">\n// import type {Breakpoint} from '../../types'\nimport {computed, onMounted, ref, toRef, useSlots, watch} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport {cloneDeepAsync} from '../../utils/object'\nimport {titleCase} from '../../utils/stringUtils'\nimport BSpinner from '../BSpinner.vue'\n\nimport type {\n  Booleanish,\n  ColorVariant,\n  TableField,\n  TableFieldObject,\n  TableItem,\n  VerticalAlign,\n} from '../../types'\nimport type {BTableProvider, BTableSortCompare} from '../../types/components'\nimport BTableSimple from './BTableSimple.vue'\nimport {filterEvent} from './helpers/filter-event'\nimport useItemHelper from './itemHelper'\n\ntype NoProviderTypes = 'paging' | 'sorting' | 'filtering'\n\ninterface BTableProps {\n  align?: VerticalAlign\n  caption?: string\n  captionTop?: Booleanish\n  borderless?: Booleanish\n  bordered?: Booleanish\n  borderVariant?: ColorVariant\n  dark?: Booleanish\n  fields?: Array<TableField>\n  footClone?: Booleanish\n  hover?: Booleanish\n  items?: Array<TableItem>\n  provider?: BTableProvider\n  sortCompare?: BTableSortCompare\n  noProvider?: Array<NoProviderTypes>\n  noProviderPaging?: Booleanish\n  noProviderSorting?: Booleanish\n  noProviderFiltering?: Booleanish\n  responsive?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'\n  small?: Booleanish\n  striped?: Booleanish\n  stacked?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl' // boolean | Breakpoint\n  labelStacked?: boolean\n  variant?: ColorVariant\n  sortBy?: string\n  sortDesc?: Booleanish\n  sortInternal?: Booleanish\n  selectable?: Booleanish\n  stickySelect?: Booleanish\n  selectHead?: boolean | string\n  selectMode?: 'multi' | 'single' | 'range'\n  selectionVariant?: ColorVariant\n  stickyHeader?: Booleanish\n  busy?: Booleanish\n  showEmpty?: Booleanish\n  perPage?: number\n  currentPage?: number\n  filter?: string\n  filterable?: string[]\n  emptyText?: string\n  emptyFilteredText?: string\n}\n\nconst props = withDefaults(defineProps<BTableProps>(), {\n  captionTop: false,\n  borderless: false,\n  bordered: false,\n  dark: false,\n  fields: () => [],\n  footClone: false,\n  hover: false,\n  items: () => [],\n  responsive: false,\n  small: false,\n  striped: false,\n  labelStacked: false,\n  stacked: false,\n  sortDesc: false,\n  sortInternal: true,\n  selectable: false,\n  stickySelect: false,\n  selectHead: true,\n  selectMode: 'single',\n  selectionVariant: 'primary',\n  stickyHeader: false,\n  busy: false,\n  showEmpty: false,\n  currentPage: 1,\n  emptyText: 'There are no records to show',\n  emptyFilteredText: 'There are no records matching your request',\n})\n\ninterface BTableEmits {\n  (\n    e: 'headClicked',\n    ...value: Parameters<\n      (key: TableFieldObject['key'], field: TableField, event: MouseEvent, isFooter: boolean) => any\n    >\n  ): void\n  (\n    e: 'rowClicked',\n    ...value: Parameters<(item: TableItem, index: number, event: MouseEvent) => any>\n  ): void\n  (\n    e: 'rowDblClicked',\n    ...value: Parameters<(item: TableItem, index: number, event: MouseEvent) => any>\n  ): void\n  (\n    e: 'rowHovered',\n    ...value: Parameters<(item: TableItem, index: number, event: MouseEvent) => any>\n  ): void\n  (\n    e: 'rowUnhovered',\n    ...value: Parameters<(item: TableItem, index: number, event: MouseEvent) => any>\n  ): void\n  (e: 'rowSelected', value: TableItem): void\n  (e: 'rowUnselected', value: TableItem): void\n  (e: 'selection', value: TableItem[]): void\n  (e: 'update:busy', value: boolean): void\n  (e: 'update:sortBy', value: string): void\n  (e: 'update:sortDesc', value: boolean): void\n  (e: 'sorted', ...value: Parameters<(sortBy: string, isDesc: boolean) => any>): void\n  (e: 'filtered', value: TableItem[]): void\n}\n\nconst emit = defineEmits<BTableEmits>()\nconst slots = useSlots()\n\nconst itemHelper = useItemHelper()\n\nconst footCloneBoolean = useBooleanish(toRef(props, 'footClone'))\nconst sortDescBoolean = useBooleanish(toRef(props, 'sortDesc'))\nconst sortInternalBoolean = useBooleanish(toRef(props, 'sortInternal'))\nconst selectableBoolean = useBooleanish(toRef(props, 'selectable'))\nconst stickySelectBoolean = useBooleanish(toRef(props, 'stickySelect'))\nconst labelStackedBoolean = useBooleanish(toRef(props, 'labelStacked'))\nconst busyBoolean = useBooleanish(toRef(props, 'busy'))\nconst showEmptyBoolean = useBooleanish(toRef(props, 'showEmpty'))\nconst noProviderPagingBoolean = useBooleanish(toRef(props, 'noProviderPaging'))\nconst noProviderSortingBoolean = useBooleanish(toRef(props, 'noProviderSorting'))\nconst noProviderFilteringBoolean = useBooleanish(toRef(props, 'noProviderFiltering'))\n\nconst internalBusyFlag = ref(busyBoolean.value)\nitemHelper.filterEvent.value = async (items) => {\n  if (usesProvider.value) {\n    await callItemsProvider()\n    return\n  }\n  const clone = await cloneDeepAsync(items)\n  emit('filtered', clone)\n}\n\nconst selectedItems = ref<Set<TableItem>>(new Set([]))\nconst isSelecting = computed(() => selectedItems.value.size > 0)\n\nconst tableClasses = computed(() => ({\n  [`align-${props.align}`]: props.align !== undefined,\n  'b-table-selectable': selectableBoolean.value,\n  [`b-table-select-${props.selectMode}`]: selectableBoolean.value,\n  'b-table-selecting user-select-none': selectableBoolean.value && isSelecting.value,\n  'b-table-busy': internalBusyFlag.value,\n  'b-table-sortable': isSortable.value,\n  'b-table-sort-desc': isSortable.value && sortDescBoolean.value === true,\n  'b-table-sort-asc': isSortable.value && sortDescBoolean.value === false,\n}))\n\nconst containerAttrs = computed(() => ({\n  bordered: props.bordered,\n  borderless: props.borderless,\n  borderVariant: props.borderVariant,\n  captionTop: props.captionTop,\n  dark: props.dark,\n  hover: props.hover,\n  responsive: props.responsive,\n  striped: props.striped,\n  stacked: props.stacked,\n  small: props.small,\n  tableClass: tableClasses.value,\n  tableVariant: props.variant,\n  stickyHeader: props.stickyHeader,\n}))\n\nconst computedFields = computed(() => itemHelper.normaliseFields(props.fields, props.items))\nconst computedFieldsTotal = computed(\n  () => computedFields.value.length + (selectableBoolean.value ? 1 : 0)\n)\n\nconst isFilterableTable = computed(() => props.filter !== undefined && props.filter !== '')\nconst usesProvider = computed(() => props.provider !== undefined)\n\nconst addSelectableCell = computed(\n  () => selectableBoolean.value && (!!props.selectHead || slots.selectHead !== undefined)\n)\n\nconst isSortable = computed(\n  () =>\n    props.fields.filter((field) => (typeof field === 'string' ? false : field.sortable)).length > 0\n)\n\nconst requireItemsMapping = computed(() => isSortable.value && sortInternalBoolean.value === true)\nconst computedItems = computed(() => {\n  const items = usesProvider.value\n    ? itemHelper.internalItems.value\n    : requireItemsMapping.value\n    ? itemHelper.mapItems(props.fields, props.items, props, {\n        isSortable,\n        isFilterableTable,\n        sortDescBoolean,\n      })\n    : props.items\n\n  if (props.perPage !== undefined) {\n    const startIndex = (props.currentPage - 1) * props.perPage\n    return items.splice(startIndex, props.perPage)\n  }\n  return items\n})\n\nconst getFieldHeadLabel = (field: TableField) => {\n  if (typeof field === 'string') return titleCase(field)\n  if (field.label !== undefined) return field.label\n  if (typeof field.key === 'string') return titleCase(field.key)\n  return field.key\n}\n\nconst headerClicked = (field: TableField, event: MouseEvent, isFooter = false) => {\n  const fieldKey = typeof field === 'string' ? field : field.key\n  emit('headClicked', fieldKey, field, event, isFooter)\n\n  handleFieldSorting(field)\n}\n\nconst onRowClick = (row: TableItem, index: number, e: MouseEvent) => {\n  emit('rowClicked', row, index, e)\n\n  handleRowSelection(row, index, e.shiftKey)\n}\nconst onRowDblClick = (row: TableItem, index: number, e: MouseEvent) =>\n  emit('rowDblClicked', row, index, e)\n\nconst onRowMouseEnter = (row: TableItem, index: number, e: MouseEvent) =>\n  emit('rowHovered', row, index, e)\n\nconst onRowMouseLeave = (row: TableItem, index: number, e: MouseEvent) =>\n  emit('rowUnhovered', row, index, e)\n\nconst handleFieldSorting = (field: TableField) => {\n  if (!isSortable.value) return\n\n  const fieldKey = typeof field === 'string' ? field : field.key\n  const fieldSortable = typeof field === 'string' ? false : field.sortable\n  if (isSortable.value === true && fieldSortable === true) {\n    const sortDesc = !sortDescBoolean.value\n    if (fieldKey !== props.sortBy) {\n      emit('update:sortBy', fieldKey)\n    }\n    emit('update:sortDesc', sortDesc)\n    emit('sorted', fieldKey, sortDesc)\n  }\n}\n\nconst notifySelectionEvent = () => {\n  if (!selectableBoolean.value) return\n  emit('selection', Array.from(selectedItems.value))\n}\n\nconst handleRowSelection = (row: TableItem, index: number, shiftClicked = false) => {\n  if (!selectableBoolean.value) return\n\n  if (selectedItems.value.has(row)) {\n    selectedItems.value.delete(row)\n    emit('rowUnselected', row)\n  } else {\n    if (props.selectMode === 'single' && selectedItems.value.size > 0) {\n      selectedItems.value.forEach((item) => emit('rowUnselected', item))\n      selectedItems.value.clear()\n    }\n\n    if (props.selectMode === 'range' && selectedItems.value.size > 0 && shiftClicked) {\n      const lastSelectedItem = Array.from(selectedItems.value).pop()\n      const lastSelectedIndex = computedItems.value.findIndex((i) => i === lastSelectedItem)\n      const selectStartIndex = Math.min(lastSelectedIndex, index)\n      const selectEndIndex = Math.max(lastSelectedIndex, index)\n      computedItems.value.slice(selectStartIndex, selectEndIndex + 1).forEach((item) => {\n        if (!selectedItems.value.has(item)) {\n          selectedItems.value.add(item)\n          emit('rowSelected', item)\n        }\n      })\n    } else {\n      selectedItems.value.add(row)\n      emit('rowSelected', row)\n    }\n  }\n\n  notifySelectionEvent()\n}\n\nconst callItemsProvider = async () => {\n  if (!usesProvider.value || !props.provider || internalBusyFlag.value) return\n  internalBusyFlag.value = true\n  const context = new Proxy(\n    {\n      currentPage: props.currentPage,\n      filter: props.filter,\n      sortBy: props.sortBy,\n      sortDesc: props.sortDesc,\n      perPage: props.perPage,\n    },\n    {\n      get(target: any, prop) {\n        return prop in target ? target[prop] : undefined\n      },\n      set() {\n        console.error('BTable provider context is a read-only object.')\n        return true\n      },\n    }\n  )\n  const response = props.provider(context, itemHelper.updateInternalItems)\n  if (response === undefined) return\n  if (response instanceof Promise) {\n    try {\n      const items = await response\n      if (!Array.isArray(items)) return\n      const internalItems = await itemHelper.updateInternalItems(items)\n      return internalItems\n    } finally {\n      if (internalBusyFlag.value) {\n        internalBusyFlag.value = false\n      }\n    }\n  }\n\n  try {\n    const internalItems = await itemHelper.updateInternalItems(response)\n    return internalItems\n  } finally {\n    if (internalBusyFlag.value) {\n      internalBusyFlag.value = false\n    }\n  }\n}\n\nconst toggleRowDetails = (tr: TableItem) => {\n  tr._showDetails = !tr._showDetails\n}\n\nconst getFieldColumnClasses = (field: TableFieldObject) => [\n  field.class,\n  field.thClass,\n  field.variant ? `table-${field.variant}` : undefined,\n  {\n    'b-table-sortable-column': isSortable.value && field.sortable,\n    'b-table-sticky-column': field.stickyColumn,\n  },\n]\n\nconst getFieldRowClasses = (field: TableFieldObject, tr: TableItem) => [\n  field.class,\n  field.tdClass,\n  field.variant ? `table-${field.variant}` : undefined,\n  tr?._cellVariants && tr?._cellVariants[field.key]\n    ? `table-${tr?._cellVariants[field.key]}`\n    : undefined,\n  {\n    'b-table-sticky-column': field.stickyColumn,\n  },\n]\n\nconst getRowClasses = (item: TableItem) => [\n  item._rowVariant ? `table-${item._rowVariant}` : null,\n  item._rowVariant ? `table-${item._rowVariant}` : null,\n  selectableBoolean.value && selectedItems.value.has(item)\n    ? `selected table-${props.selectionVariant}`\n    : null,\n]\n\nconst selectAllRows = () => {\n  if (!selectableBoolean.value) return\n  const unselectableItems = selectedItems.value.size > 0 ? Array.from(selectedItems.value) : []\n  selectedItems.value = new Set([...computedItems.value])\n  selectedItems.value.forEach((item) => {\n    if (unselectableItems.includes(item)) return\n    emit('rowSelected', item)\n  })\n  notifySelectionEvent()\n}\n\nconst clearSelected = () => {\n  if (!selectableBoolean.value) return\n  selectedItems.value.forEach((item) => {\n    emit('rowUnselected', item)\n  })\n  selectedItems.value = new Set([])\n  notifySelectionEvent()\n}\n\nconst selectRow = (index: number) => {\n  if (!selectableBoolean.value) return\n  const item = computedItems.value[index]\n  if (!item || selectedItems.value.has(item)) return\n  selectedItems.value.add(item)\n  emit('rowSelected', item)\n  notifySelectionEvent()\n}\n\nconst unselectRow = (index: number) => {\n  if (!selectableBoolean.value) return\n  const item = computedItems.value[index]\n  if (!item || !selectedItems.value.has(item)) return\n  selectedItems.value.delete(item)\n  emit('rowUnselected', item)\n  notifySelectionEvent()\n}\n\nconst providerPropsWatch = async (prop: string, val: any, oldVal: any) => {\n  if (val === oldVal) return\n\n  //stop provide when paging\n  const inNoProvider = (key: NoProviderTypes) => props.noProvider && props.noProvider.includes(key)\n  const notifyFiltered = !['currentPage', 'perPage'].includes(prop)\n  const noProvideWhenPaging =\n    ['currentPage', 'perPage'].includes(prop) &&\n    (inNoProvider('paging') || noProviderPagingBoolean.value === true)\n  const noProvideWhenFiltering =\n    ['filter'].includes(prop) &&\n    (inNoProvider('filtering') || noProviderFilteringBoolean.value === true)\n  const noProvideWhenSorting =\n    ['sortBy', 'sortDesc'].includes(prop) &&\n    (inNoProvider('sorting') || noProviderSortingBoolean.value === true)\n\n  if (noProvideWhenPaging || noProvideWhenFiltering || noProvideWhenSorting) {\n    return\n  }\n\n  await callItemsProvider()\n\n  if (notifyFiltered) itemHelper.notifyFilteredItems()\n}\n\nwatch(\n  () => props.filter,\n  (filter, oldFilter) => {\n    if (filter === oldFilter || usesProvider.value) return\n    if (!filter) {\n      cloneDeepAsync(props.items).then((item) => emit('filtered', item))\n    }\n  }\n)\n\nwatch(\n  () => internalBusyFlag.value,\n  () => internalBusyFlag.value !== busyBoolean.value && emit('update:busy', internalBusyFlag.value)\n)\nwatch(\n  () => busyBoolean.value,\n  () => internalBusyFlag.value !== busyBoolean.value && (internalBusyFlag.value = busyBoolean.value)\n)\nwatch(\n  () => props.filter,\n  (val, oldVal) => providerPropsWatch('filter', val, oldVal)\n)\nwatch(\n  () => props.currentPage,\n  (val, oldVal) => providerPropsWatch('currentPage', val, oldVal)\n)\nwatch(\n  () => props.perPage,\n  (val, oldVal) => providerPropsWatch('perPage', val, oldVal)\n)\nwatch(\n  () => props.sortBy,\n  (val, oldVal) => providerPropsWatch('sortBy', val, oldVal)\n)\nwatch(\n  () => props.sortDesc,\n  (val, oldVal) => providerPropsWatch('sortDesc', val, oldVal)\n)\n\nonMounted(() => {\n  if (usesProvider.value) {\n    callItemsProvider()\n  }\n})\n\ndefineExpose({\n  selectAllRows,\n  clearSelected,\n  selectRow,\n  unselectRow,\n})\n</script>\n","<template>\n  <tbody role=\"rowgroup\" :class=\"computedClasses\">\n    <slot />\n  </tbody>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTBodyProps} from '../../types/components'\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BTBodyProps {\n  variant?: ColorVariant\n}\n\nconst props = defineProps<BTBodyProps>()\n\nconst computedClasses = computed(() => ({\n  [`thead-${props.variant}`]: props.variant !== undefined,\n}))\n</script>\n","<template>\n  <td\n    role=\"cell\"\n    :scope=\"scope\"\n    :class=\"computedClasses\"\n    :colspan=\"colspan\"\n    :rowspan=\"rowspan\"\n    :data-label=\"stackedHeading\"\n  >\n    <div v-if=\"stackedHeading\">\n      <slot />\n    </div>\n    <slot v-else />\n  </td>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BTdProps {\n  colspan?: string | number\n  rowspan?: string | number\n  stackedHeading?: string\n  stickyColumn?: Booleanish\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BTdProps>(), {\n  stickyColumn: false,\n})\n\nconst stickyColumnBoolean = useBooleanish(toRef(props, 'stickyColumn'))\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== undefined,\n  'b-table-sticky-column': stickyColumnBoolean.value,\n  'table-b-table-default': stickyColumnBoolean.value && props.variant === undefined,\n}))\n\nconst scope = computed(() => (props.colspan ? 'colspan' : props.rowspan ? 'rowspan' : 'col'))\n</script>\n","<template>\n  <tfoot role=\"rowgroup\" :class=\"computedClasses\">\n    <slot />\n  </tfoot>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTfootProps} from '../../types/components'\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BTfootProps {\n  variant?: ColorVariant\n}\n\nconst props = defineProps<BTfootProps>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== undefined,\n}))\n</script>\n","<template>\n  <th\n    role=\"columnheader\"\n    :scope=\"scope\"\n    :class=\"computedClasses\"\n    :colspan=\"colspan\"\n    :rowspan=\"rowspan\"\n    :data-label=\"stackedHeading\"\n  >\n    <div v-if=\"stackedHeading !== undefined\">\n      <slot />\n    </div>\n    <slot v-else />\n  </th>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BThProps {\n  colspan?: string | number\n  rowspan?: string | number\n  stackedHeading?: string\n  stickyColumn?: Booleanish\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BThProps>(), {\n  stickyColumn: false,\n})\n\nconst stickyColumnBoolean = useBooleanish(toRef(props, 'stickyColumn'))\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== undefined,\n  'b-table-sticky-column': stickyColumnBoolean.value,\n  'table-b-table-default': stickyColumnBoolean.value && props.variant === undefined,\n}))\n\nconst scope = computed(() => (props.colspan ? 'colspan' : props.rowspan ? 'rowspan' : 'col'))\n</script>\n","<template>\n  <thead role=\"rowgroup\" :class=\"computedClasses\">\n    <slot />\n  </thead>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTheadProps} from '../../types/components'\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BTheadProps {\n  variant?: ColorVariant\n}\n\nconst props = defineProps<BTheadProps>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== undefined,\n}))\n</script>\n","<template>\n  <tr role=\"row\" :class=\"computedClasses\">\n    <slot />\n  </tr>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTrProps} from '../../types/components'\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BTrProps {\n  variant?: ColorVariant\n}\n\nconst props = defineProps<BTrProps>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" class=\"tabs\" :class=\"computedClasses\">\n    <!-- Tab Content Above Tabs -->\n    <div v-if=\"endBoolean\" class=\"tab-content\" :class=\"contentClass\">\n      <component\n        :is=\"tabComponent()\"\n        v-for=\"({tabComponent, contentId, tabClasses, active}, i) in tabs\"\n        :id=\"contentId\"\n        :key=\"i\"\n        :class=\"tabClasses\"\n        :active=\"active\"\n      />\n      <div\n        v-if=\"showEmpty\"\n        key=\"bv-empty-tab\"\n        class=\"tab-pane active\"\n        :class=\"{'card-body': cardBoolean}\"\n      >\n        <slot name=\"empty\" />\n      </div>\n    </div>\n    <div\n      :class=\"[navWrapperClass, {'card-header': cardBoolean, 'ms-auto': vertical && endBoolean}]\"\n    >\n      <!-- Render Tabs -->\n      <ul class=\"nav\" :class=\"[navTabsClasses, navClass]\" role=\"tablist\">\n        <slot name=\"tabs-start\" />\n        <li\n          v-for=\"({tab, buttonId, contentId, navItemClasses, active, target}, idx) in tabs\"\n          :key=\"idx\"\n          class=\"nav-item\"\n          :class=\"tab.props['title-item-class']\"\n        >\n          <button\n            :id=\"buttonId\"\n            class=\"nav-link\"\n            :class=\"navItemClasses\"\n            data-bs-toggle=\"tab\"\n            :data-bs-target=\"target\"\n            role=\"tab\"\n            :aria-controls=\"contentId\"\n            :aria-selected=\"active\"\n            v-bind=\"tab.props['title-link-attributes']\"\n            @click.stop.prevent=\"(e) => handleClick(e, idx)\"\n          >\n            <component :is=\"tab.children.title\" v-if=\"tab.children && tab.children.title\" />\n            <template v-else>\n              {{ tab.props.title }}\n            </template>\n          </button>\n        </li>\n        <slot name=\"tabs-end\" />\n      </ul>\n    </div>\n    <!-- Tab Content Below Tabs-->\n    <div v-if=\"!endBoolean\" class=\"tab-content\" :class=\"contentClass\">\n      <component\n        :is=\"tabComponent()\"\n        v-for=\"({tabComponent, contentId, tabClasses, active}, i) in tabs\"\n        :id=\"contentId\"\n        :key=\"i\"\n        :class=\"tabClasses\"\n        :active=\"active\"\n      />\n      <div\n        v-if=\"showEmpty\"\n        key=\"bv-empty-tab\"\n        class=\"tab-pane active\"\n        :class=\"{'card-body': cardBoolean}\"\n      >\n        <slot name=\"empty\" />\n      </div>\n    </div>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTabsProps, BTabsEmits} from '../types/components'\nimport type {BTabsParentData} from '../../types/components'\nimport {computed, InjectionKey, onMounted, provide, ref, toRef, useSlots, watch} from 'vue'\nimport {BvEvent, getId} from '../../utils'\nimport {useAlignment, useBooleanish} from '../../composables'\nimport type {Alignment, Booleanish, ClassValue} from '../../types'\n\ninterface BTabsProps {\n  activeNavItemClass?: ClassValue\n  activeTabClass?: ClassValue\n  align?: Alignment.JustifyContent\n  card?: Booleanish\n  contentClass?: ClassValue\n  end?: Booleanish\n  fill?: Booleanish\n  id?: string\n  justified?: Booleanish\n  lazy?: Booleanish\n  navClass?: ClassValue\n  navWrapperClass?: ClassValue\n  noFade?: Booleanish\n  // noKeyNav?: Booleanish\n  noNavStyle?: Booleanish\n  pills?: Booleanish\n  small?: Booleanish\n  tag?: string\n  vertical?: Booleanish\n  modelValue?: number\n}\n\nconst props = withDefaults(defineProps<BTabsProps>(), {\n  card: false,\n  end: false,\n  fill: false,\n  justified: false,\n  lazy: false,\n  noFade: false,\n  noNavStyle: false,\n  pills: false,\n  small: false,\n  tag: 'div',\n  vertical: false,\n  modelValue: -1,\n})\n\ninterface BTabsEmits {\n  (e: 'update:modelValue', value: number): void\n  (e: 'activate-tab', v1: number, v2: number, v3: BvEvent): void\n  (e: 'click'): void // TODO click event is never used\n}\n\nconst emit = defineEmits<BTabsEmits>()\n\nconst slots = useSlots()\n\nconst cardBoolean = useBooleanish(toRef(props, 'card'))\nconst endBoolean = useBooleanish(toRef(props, 'end'))\nconst fillBoolean = useBooleanish(toRef(props, 'fill'))\nconst justifiedBoolean = useBooleanish(toRef(props, 'justified'))\nconst lazyBoolean = useBooleanish(toRef(props, 'lazy'))\nconst noFadeBoolean = useBooleanish(toRef(props, 'noFade'))\nconst noNavStyleBoolean = useBooleanish(toRef(props, 'noNavStyle'))\nconst pillsBoolean = useBooleanish(toRef(props, 'pills'))\nconst smallBoolean = useBooleanish(toRef(props, 'small'))\nconst verticalBoolean = useBooleanish(toRef(props, 'vertical'))\n\nconst _tabIndex = ref(props.modelValue)\nconst _currentTabButton = ref('')\n\nconst tabIndex = computed({\n  get: () => _tabIndex.value,\n  set: (value: number) => {\n    _tabIndex.value = value\n    if (tabs.value.length > 0 && value >= 0 && value < tabs.value.length) {\n      _currentTabButton.value = tabs.value[value].buttonId\n    } else {\n      _currentTabButton.value = ''\n    }\n    emit('update:modelValue', value)\n  },\n})\n\nconst tabs = computed(() => {\n  let tabs: any[] = []\n\n  if (slots.default) {\n    tabs = getTabs(slots).map((tab: any, idx) => {\n      if (!tab.props) tab.props = {}\n\n      const buttonId = tab.props['button-id'] || getId('tab')\n      const contentId = tab.props.id || getId()\n      const active = tabIndex.value > -1 ? idx === tabIndex.value : tab.props.active === ''\n      const titleItemClass = tab.props['title-item-class']\n      const titleLinkAttributes = tab.props['title-link-attributes']\n\n      return {\n        buttonId,\n        contentId,\n        active,\n        disabled: tab.props.disabled === '' || tab.props.disabled === true,\n        navItemClasses: [\n          {\n            active,\n            disabled: tab.props.disabled === '' || tab.props.disabled === true,\n          },\n          active && props.activeNavItemClass ? props.activeNavItemClass : null,\n          tab.props['title-link-class'],\n        ],\n        tabClasses: [\n          {\n            fade: !noFadeBoolean.value,\n          },\n          active && props.activeTabClass ? props.activeTabClass : null,\n        ],\n        target: `#${contentId}`,\n        title: tab.props.title,\n        titleItemClass,\n        titleLinkAttributes,\n        onClick: tab.props.onClick,\n        tab, //TODO remove this in future since the mapped value does not provide a direct reference to the actual slot component.\n        tabComponent: () => getTabs(slots)[idx],\n      }\n    })\n  }\n  return tabs\n})\n\nconst showEmpty = computed(() => !(tabs?.value && tabs.value.length > 0))\n\nconst computedClasses = computed(() => ({\n  'd-flex': verticalBoolean.value,\n  'align-items-start': verticalBoolean.value,\n}))\n\nconst alignment = useAlignment(toRef(props, 'align'))\n\nconst navTabsClasses = computed(() => ({\n  'nav-pills': pillsBoolean.value,\n  'flex-column me-3': verticalBoolean.value,\n  [alignment.value]: props.align !== undefined,\n  'nav-fill': fillBoolean.value,\n  'card-header-tabs': cardBoolean.value,\n  'nav-justified': justifiedBoolean.value,\n  'nav-tabs': !noNavStyleBoolean.value && !pillsBoolean.value,\n  'small': smallBoolean.value,\n}))\n\nconst activateTab = (index: number): boolean => {\n  let result = false\n  if (index !== undefined) {\n    if (\n      index > -1 &&\n      index < tabs.value.length &&\n      !tabs.value[index].disabled &&\n      (tabIndex.value < 0 || tabs.value[index].buttonId !== _currentTabButton.value)\n    ) {\n      const tabEvent = new BvEvent('activate-tab', {cancelable: true})\n      emit('activate-tab', index, tabIndex.value, tabEvent)\n      if (!tabEvent.defaultPrevented) {\n        tabIndex.value = index\n        result = true\n      }\n    }\n  }\n  if (!result && props.modelValue !== tabIndex.value) {\n    emit('update:modelValue', tabIndex.value)\n  }\n  return result\n}\n\nconst handleClick = (event: MouseEvent, index: number) => {\n  activateTab(index)\n  if (\n    index >= 0 &&\n    !tabs.value[index].disabled &&\n    tabs.value[index]?.onClick &&\n    typeof tabs.value[index].onClick === 'function'\n  ) {\n    tabs.value[index].onClick(event)\n  }\n}\n\nconst getTabs = (slots: any): any[] => {\n  if (!slots || !slots.default) return []\n\n  return slots\n    .default()\n    .reduce((arr: number[], slot: any) => {\n      if (typeof slot.type === 'symbol') {\n        arr = arr.concat(slot.children)\n      } else {\n        arr.push(slot)\n      }\n      return arr\n    }, [])\n    .filter((child: any) => child.type?.__name === 'BTab')\n}\n\nactivateTab(_tabIndex.value)\n\nwatch(\n  () => props.modelValue,\n  (newValue, oldValue) => {\n    if (newValue === oldValue) return\n    newValue = Math.max(newValue, -1)\n    oldValue = Math.max(oldValue, -1)\n\n    if (tabs.value.length <= 0) {\n      tabIndex.value = -1\n      return\n    }\n\n    const goForward = newValue > oldValue\n    let index = newValue\n    const maxIdx = tabs.value.length - 1\n    while (index >= 0 && index <= maxIdx && tabs.value[index].disabled) {\n      index += goForward ? 1 : -1\n    }\n\n    if (index < 0) {\n      activateTab(0)\n      return\n    }\n    if (index >= tabs.value.length) {\n      activateTab(tabs.value.length - 1)\n      return\n    }\n    activateTab(index)\n  }\n)\n\nwatch(\n  () => tabs.value,\n  () => {\n    // find last active tab\n    let activeTabIndex = tabs.value.map((tab: any) => tab.active && !tab.disabled).lastIndexOf(true)\n\n    if (activeTabIndex < 0) {\n      if (tabIndex.value >= tabs.value.length) {\n        // handle last tab removed, so find the last non-disabled tab\n        activeTabIndex = tabs.value.map((tab: any) => !tab.disabled).lastIndexOf(true)\n      } else {\n        if (tabs.value[tabIndex.value] && !tabs.value[tabIndex.value].disabled)\n          activeTabIndex = tabIndex.value\n      }\n    }\n    // still no active tab found, find first non-disabled tab\n    if (activeTabIndex < 0) {\n      activeTabIndex = tabs.value.map((tab: any) => !tab.disabled).indexOf(true)\n    }\n    // ensure only one tab active at a time\n    tabs.value.forEach((tab: any, idx: number) => (tab.active = idx === activeTabIndex))\n\n    activateTab(activeTabIndex)\n  }\n)\n\nonMounted(() => {\n  // If there are tabs available, make sure a tab is set active\n  if (tabIndex.value < 0 && tabs.value.length > 0 && !tabs.value.some((tab: any) => tab.active)) {\n    const firstTab = tabs.value.map((t) => !t.disabled).indexOf(true)\n    activateTab(firstTab >= 0 ? firstTab : -1)\n  }\n})\n\nprovide(injectionKey, {\n  lazy: lazyBoolean.value,\n  card: cardBoolean.value,\n})\n</script>\n\n<script lang=\"ts\">\nexport const injectionKey: InjectionKey<BTabsParentData> = Symbol()\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"id\"\n    class=\"tab-pane\"\n    :class=\"computedClasses\"\n    role=\"tabpanel\"\n    aria-labelledby=\"profile-tab\"\n  >\n    <slot v-if=\"showSlot\" />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTabProps} from '../../types/components'\nimport {computed, inject, ref, toRef, watch} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ClassValue} from '../../types'\nimport {injectionKey} from './BTabs.vue'\n\ninterface BTabProps {\n  id?: string\n  title?: string\n  active?: Booleanish\n  buttonId?: string\n  disabled?: Booleanish\n  lazy?: Booleanish\n  lazyOnce?: Booleanish\n  noBody?: boolean | string\n  tag?: string\n  titleItemClass?: ClassValue\n  titleLinkAttributes?: Record<string, unknown>\n  titleLinkClass?: ClassValue\n}\n\nconst props = withDefaults(defineProps<BTabProps>(), {\n  active: false,\n  buttonId: undefined,\n  disabled: false,\n  lazy: undefined,\n  lazyOnce: undefined,\n  noBody: false,\n  tag: 'div',\n  titleLinkAttributes: undefined,\n})\n\nconst parentData = inject(injectionKey, null)\n\nconst activeBoolean = useBooleanish(toRef(props, 'active'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst lazyBoolean = useBooleanish(toRef(props, props.lazyOnce !== undefined ? 'lazyOnce' : 'lazy'))\n\nconst lazyRenderCompleted = ref(false)\n\nconst computedLazy = computed<boolean>(() => !!(parentData?.lazy || lazyBoolean.value))\nconst computedLazyOnce = computed<boolean>(() => props.lazyOnce !== undefined)\n\nconst computedActive = computed<boolean>(() => activeBoolean.value && !disabledBoolean.value)\nconst showSlot = computed<boolean>(() => {\n  const hasLazyRenderedOnce =\n    computedLazy.value && computedLazyOnce.value && lazyRenderCompleted.value\n  return computedActive.value || !computedLazy.value || hasLazyRenderedOnce\n})\n\nconst computedClasses = computed(() => ({\n  'active': activeBoolean.value,\n  'show': activeBoolean.value,\n  'card-body': parentData?.card && props.noBody === false,\n}))\n\nwatch(\n  () => showSlot.value,\n  (shown) => {\n    if (shown && !lazyRenderCompleted.value) lazyRenderCompleted.value = true\n  }\n)\n</script>\n","import {App, Plugin} from 'vue'\n\nimport './styles/styles.scss'\n\nimport * as Components from './components'\nimport * as Directives from './directives/exports'\nimport {createBreadcrumb} from './composables'\nimport {BootstrapVueOptions} from './types'\n\n// Inject all components into the global @vue/runtime-core\n// This allows intellisense in templates w/out direct importing\ndeclare module '@vue/runtime-core' {\n  export interface GlobalComponents {\n    BAccordion: typeof Components.BAccordion\n    BAccordionItem: typeof Components.BAccordionItem\n    BAlert: typeof Components.BAlert\n    BAvatar: typeof Components.BAvatar\n    BAvatarGroup: typeof Components.BAvatarGroup\n    BBadge: typeof Components.BBadge\n    BBreadcrumb: typeof Components.BBreadcrumb\n    BBreadcrumbItem: typeof Components.BBreadcrumbItem\n    BButton: typeof Components.BButton\n    BButtonGroup: typeof Components.BButtonGroup\n    BButtonToolbar: typeof Components.BButtonToolbar\n    BCard: typeof Components.BCard\n    BCardBody: typeof Components.BCardBody\n    BCardFooter: typeof Components.BCardFooter\n    BCardGroup: typeof Components.BCardGroup\n    BCardHeader: typeof Components.BCardHeader\n    BCardImg: typeof Components.BCardImg\n    BCardSubtitle: typeof Components.BCardSubtitle\n    BCardText: typeof Components.BCardText\n    BCardTitle: typeof Components.BCardTitle\n    BCarousel: typeof Components.BCarousel\n    BCarouselSlide: typeof Components.BCarouselSlide\n    BCloseButton: typeof Components.BCloseButton\n    BCol: typeof Components.BCol\n    BCollapse: typeof Components.BCollapse\n    BContainer: typeof Components.BContainer\n    BDropdown: typeof Components.BDropdown\n    BDropdownDivider: typeof Components.BDropdownDivider\n    BDropdownForm: typeof Components.BDropdownForm\n    BDropdownGroup: typeof Components.BDropdownGroup\n    BDropdownHeader: typeof Components.BDropdownHeader\n    BDropdownItem: typeof Components.BDropdownItem\n    BDropdownItemButton: typeof Components.BDropdownItemButton\n    BDropdownText: typeof Components.BDropdownText\n    BForm: typeof Components.BForm\n    BFormCheckbox: typeof Components.BFormCheckbox\n    BFormCheckboxGroup: typeof Components.BFormCheckboxGroup\n    BFormFloatingLabel: typeof Components.BFormFloatingLabel\n    BFormGroup: typeof Components.BFormGroup\n    BFormInput: typeof Components.BFormInput\n    BFormInvalidFeedback: typeof Components.BFormInvalidFeedback\n    BFormRadio: typeof Components.BFormRadio\n    BFormRadioGroup: typeof Components.BFormRadioGroup\n    BFormRow: typeof Components.BFormRow\n    BFormSelect: typeof Components.BFormSelect\n    BFormSelectOption: typeof Components.BFormSelectOption\n    BFormSelectOptionGroup: typeof Components.BFormSelectOptionGroup\n    BFormText: typeof Components.BFormText\n    BFormTextarea: typeof Components.BFormTextarea\n    BFormTag: typeof Components.BFormTag\n    BFormTags: typeof Components.BFormTags\n    BFormSpinButton: typeof Components.BFormSpinButton\n    BFormValidFeedback: typeof Components.BFormValidFeedback\n    BImg: typeof Components.BImg\n    BInputGroup: typeof Components.BInputGroup\n    BInputGroupAddon: typeof Components.BInputGroupAddon\n    BInputGroupAppend: typeof Components.BInputGroupAppend\n    BInputGroupPrepend: typeof Components.BInputGroupPrepend\n    BInputGroupText: typeof Components.BInputGroupText\n    BLink: typeof Components.BLink\n    BListGroup: typeof Components.BListGroup\n    BListGroupItem: typeof Components.BListGroupItem\n    BModal: typeof Components.BModal\n    BNav: typeof Components.BNav\n    BNavForm: typeof Components.BNavForm\n    BNavText: typeof Components.BNavText\n    BNavbar: typeof Components.BNavbar\n    BNavbarBrand: typeof Components.BNavbarBrand\n    BNavbarNav: typeof Components.BNavbarNav\n    BNavbarToggle: typeof Components.BNavbarToggle\n    BNavItem: typeof Components.BNavItem\n    BNavItemDropdown: typeof Components.BNavItemDropdown\n    BOffcanvas: typeof Components.BOffcanvas\n    BOverlay: typeof Components.BOverlay\n    BPagination: typeof Components.BPagination\n    BPlaceholder: typeof Components.BPlaceholder\n    BPlaceholderButton: typeof Components.BPlaceholderButton\n    BPlaceholderCard: typeof Components.BPlaceholderCard\n    BPlaceholderTable: typeof Components.BPlaceholderTable\n    BPlaceholderWrapper: typeof Components.BPlaceholderWrapper\n    BPopover: typeof Components.BPopover\n    BProgress: typeof Components.BProgress\n    BProgressBar: typeof Components.BProgressBar\n    BRow: typeof Components.BRow\n    BSkeleton: typeof Components.BSkeleton\n    BSkeletonIcon: typeof Components.BSkeletonIcon\n    BSkeletonTable: typeof Components.BSkeletonTable\n    BSkeletonWrapper: typeof Components.BSkeletonWrapper\n    BSpinner: typeof Components.BSpinner\n    BTab: typeof Components.BTab\n    BTable: typeof Components.BTable\n    BTableSimple: typeof Components.BTableSimple\n    BTbody: typeof Components.BTbody\n    BTd: typeof Components.BTd\n    BTfoot: typeof Components.BTfoot\n    BTh: typeof Components.BTh\n    BThead: typeof Components.BThead\n    BTr: typeof Components.BTr\n    BToast: typeof Components.BToast\n    BToaster: typeof Components.BToaster\n    BToastContainer: typeof Components.BToastContainer\n    BTabs: typeof Components.BTabs\n    BTransition: typeof Components.BTransition\n    BToastPlugin: typeof Components.BToastPlugin\n  }\n}\n\n// Main app plugin\nconst plugin: Plugin = {\n  // TODO: use options in the future\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  install(app: App, options: BootstrapVueOptions = {}) {\n    Object.entries(Components).forEach(([name, component]) => {\n      app.component(name, component)\n    })\n\n    Object.entries(Directives).forEach(([name, component]) => {\n      app.directive(name, component)\n    })\n\n    createBreadcrumb(app)\n  },\n}\n\nexport * from './components'\nexport * as Components from './components'\nexport * from './directives/exports'\nexport * as Directives from './directives/exports'\nexport * from './composables/exports'\nexport * as Composables from './composables/exports'\nexport * from './utils/exports'\nexport * as Utils from './utils/exports'\nexport * from './types/exports'\nexport * as Types from './types/exports'\nexport {useToast} from './components/BToast/'\n\nexport {plugin as BootstrapVue3}\nexport default plugin\n"],"names":["__defProp$9","__defProps$6","__getOwnPropDescs$6","__getOwnPropSymbols$b","__hasOwnProp$b","__propIsEnum$b","__defNormalProp$9","obj","key","value","__spreadValues$9","a","b","prop","__spreadProps$6","computedEager","fn","options","_a","result","shallowRef","watchEffect","readonly","isClient","isFunction","val","isString","noop","resolveUnref","r","unref","createFilterWrapper","filter","wrapper","args","bypassFilter","invoke","pausableFilter","extendFilter","isActive","ref","pause","resume","identity","arg","tryOnScopeDispose","getCurrentScope","onScopeDispose","resolveRef","computed","tryOnMounted","sync","getCurrentInstance","onMounted","nextTick","useIntervalFn","cb","interval","immediate","immediateCallback","timer","clean","isRef","stopWatch","watch","__getOwnPropSymbols$6","__hasOwnProp$6","__propIsEnum$6","__objRest$5","source","exclude","target","watchWithFilter","eventFilter","watchOptions","__defProp$2","__defProps$2","__getOwnPropDescs$2","__getOwnPropSymbols$2","__hasOwnProp$2","__propIsEnum$2","__defNormalProp$2","__spreadValues$2","__spreadProps$2","__objRest$1","watchPausable","unrefElement","elRef","plain","defaultWindow","useEventListener","events","listeners","cleanups","cleanup","register","el","event","listener","stop","useSupported","callback","isSupported","update","useMediaQuery","query","window","mediaQuery","matches","_global","globalKey","handlers","getSSRHandler","fallback","guessSerializerType","rawInit","__defProp$j","__getOwnPropSymbols$l","__hasOwnProp$l","__propIsEnum$l","__defNormalProp$j","__spreadValues$j","StorageSerializers","v","useStorage","defaults","storage","flush","deep","listenToStorageChanges","writeDefaults","mergeDefaults","shallow","onError","e","data","_a2","type","serializer","pauseWatch","resumeWatch","pausableWatch","write","serialized","oldValue","read","rawValue","usePreferredDark","__defProp$i","__getOwnPropSymbols$k","__hasOwnProp$k","__propIsEnum$k","__defNormalProp$i","__spreadValues$i","useColorMode","selector","attribute","initialValue","storageKey","storageRef","emitAuto","modes","preferredDark","preferredMode","store","state","updateHTMLAttrs","selector2","attribute2","current","i","defaultOnChanged","mode","resolvedMode","onChanged","SwipeDirection","SwipeDirection2","__defProp","__getOwnPropSymbols","__hasOwnProp","__propIsEnum","__defNormalProp","__spreadValues","useAlignment","align","eagerComputed","BvEvent","eventType","eventInit","__publicField","setter","BvModalEvent","isObject","isNumeric","isPlainObject","isNull","RX_UNDERSCORE","RX_LOWER_UPPER","RX_START_SPACE_WORD","RX_FIRST_START_SPACE_WORD","RX_SPACE_SPLIT","RX_HASH","RX_HASH_ID","RX_STRIP_LOCALE_MODS","toString","spaces","startCase","str","_","$1","$2","titleCase","upperFirst","trim","escapeChar","cssEscape","length","firstCharCode","char","index","charCode","HAS_WINDOW_SUPPORT","IS_BROWSER","WINDOW","HAS_PASSIVE_EVENT_SUPPORT","passiveEventSupported","HAS_DOCUMENT_SUPPORT","HAS_ELEMENT_SUPPORT","HAS_NAVIGATOR_SUPPORT","DOCUMENT","NAVIGATOR","USER_AGENT","ELEMENT_PROTO","matchesEl","isElement","getBCR","getActiveElement","excludes","activeElement","isActiveElement","attemptFocus","getStyle","isVisible","bcr","isEmptySlot","slot","vnode","Comment","select","root","selectAll","getAttr","attr","getById","id","setAttr","removeAttr","isTag","tag","name","requestAF","closestEl","sel","closest","includeRoot","getBreakpointProps","prefix","breakpoints","definition","props","breakpoint","getClasses$1","els","propPrefix","classPrefix","arr","getId","suffix","resolveAriaInvalid","ariaInvalid","_isObject","item","mergeDeep","extendArray","output","normalizeSlot","scope","$slots","names","toInteger","defaultValue","stringToInteger","integer","toFloat","float","omit","objToPluck","keysToPluck","cloneDeep","o","cloneDeepAsync","resolve","suffixPropName","pluckProps","memo","resolveBooleanish","input","isLink","useBooleanish","BREADCRUMB_SYMBOL","BREADCRUMB_OBJECT","reactive","createBreadcrumb","app","useBreadcrumb","inject","element","onBeforeUnmount","getClasses","items","getInputClasses","getLabelClasses","getGroupAttr","getGroupClasses","slotsToElements","slots","nodeType","disabled","acc","txtChild","optionToElement","option","bindGroupProps","idx","computedName","computedId","useId","COMMON_INPUT_PROPS","useFormInput","emit","inputValue","neverFormatted","toRef","_formatValue","evt","force","_getModelValue","handleAutofocus","onActivated","computedAriaInvalid","onInput","formattedValue","nextModel","onChange","onBlur","focus","blur","newValue","_getNested","path","paths","_normalizeOption","componentName","text","html","normalizeOptions","persist","opts","_b","injectionKey","flushBoolean","freeBoolean","computedClasses","provide","modelValueBoolean","toggleBoolean","visibleBoolean","isNavBoolean","instance","close","Collapse","setTheme","BColorMode","binding","BPopover$1","placement","trigger","Popover","resolveToggleType","getTargets","modifiers","targets","localValue","href","t","vBToggle","targetIds","targetAttrs","targetAttr","targetId","resolveTrigger","resolvePlacement","resolveDelay","values","resolveTitle","BTooltip","isHtml","delay","title","Tooltip","originalTitle","observerInstances","VisibilityObserver","margin","once","entries","entry","isIntersecting","destroy","observer","bind","mod","BVisible","parent","appearBoolean","noFadeBoolean","fadeProperties","NO_FADE_PROPS","FADE_PROPS","baseProperties","computedAttrs","disabledBoolean","whiteBoolean","useSlots","smallBoolean","hasLabelSlot","BLINK_PROPS","_sfc_main$1w","defineComponent","attrs","activeBoolean","appendBoolean","exactBoolean","replaceBoolean","link","routerName","computedHref","toFallback","to","hash","routerAttr","_sfc_render","_ctx","_cache","$props","$setup","$data","$options","_resolveDynamicComponent","_withCtx","navigate","isExactActive","_openBlock","_createBlock","_mergeProps","_sfc_main$1v","BLink","BSpinner","pillBoolean","pressedBoolean","squaredBoolean","loadingBoolean","isToggle","isButton","computedLink","isBLink","nonStandardTag","computedTag","_resolveComponent","_normalizeClass","_createVNode","_component_b_spinner","_createCommentVNode","_createElementVNode","useCountdown","intervalOpts","isPaused","intervalsPassed","resolvedLength","intervalLength","amountOfIntervals","restart","newVal","oldVal","myPause","myResume","dismissibleBoolean","fadeBoolean","immediateBoolean","showOnPauseBoolean","hasCloseSlot","remainingMs","isAlertVisible","closeClicked","expose","squareBoolean","computedSize","computeSize","overlapScale","computeOverlap","paddingStyle","calcValue","parentData","SIZES","FONT_SIZE_SCALE","BADGE_FONT_SIZE_SCALE","badgeLeftBoolean","badgeTopBoolean","buttonBoolean","hasDefaultSlot","hasBadgeSlot","showBadge","computedVariant","computedRounded","badgeClasses","badgeText","badgeTextClasses","computeContrastVariant","textClasses","badgeStyle","offset","textFontStyle","fontSize","marginStyle","computedStyle","colorVariant","clicked","onImgError","linkProps","_sfc_main$1r","textIndicatorBoolean","dotIndicatorBoolean","computedLinkProps","_sfc_main$1q","computedAriaCurrent","breadcrumb","breadcrumbItemObjects","localItems","activeDefined","verticalBoolean","justifyBoolean","BLANK_TEMPLATE","lazyBoolean","blankBoolean","blockBoolean","centerBoolean","fluidBoolean","fluidGrowBoolean","leftBoolean","startBoolean","rightBoolean","endBoolean","thumbnailBoolean","computedSrcset","x","computedSizes","computedDimentions","parser","width","height","computedBlankImgSrc","makeBlankImgSrc","alignment","color","bottomBoolean","topBoolean","baseClass","coomputedClasses","overlayBoolean","hasTitleSlot","hasSubtitleSlot","imgBottomBoolean","imgEndBoolean","imgLeftBoolean","imgRightBoolean","imgStartBoolean","noBodyBoolean","hasHeaderSlot","hasFooterSlot","headerAttrs","bodyAttrs","footerAttrs","imgAttr","columnsBoolean","deckBoolean","cardTypeClass","controlsBoolean","indicatorsBoolean","noTouchBoolean","slides","payload","Carousel","child","computedAttr","computedContentClasses","parentWidth","parentHeight","breakpointCol","breakpointOffset","breakpointOrder","_sfc_main$19","properties","colBoolean","classList","defaultToastOptions","ToastInstance","vm","isReactive","s","toast","position","forDeletion","content","topts","ToastController","useToast","injectkey","fetchKey","getKey","controller","vm_id","local_vm","vm_instance","BToastPlugin","_d","_c","SLOT_NAME_TOAST_TITLE","MIN_DURATION","_sfc_main$18","isStatusBoolean","autoHideBoolean","noCloseButtonBoolean","noHoverPauseBoolean","isTransitioning","isHiding","localShow","classes","dismissTimer","dismissStarted","resumeDismiss","clearDismissTimer","computedDuration","hide","show","onPause","passed","onUnPause","startDismissTimer","OnBeforeEnter","OnAfterEnter","OnBeforeLeave","OnAfterLeave","onUnmounted","onLinkClick","makeToast","$headerContent","$title","h","BCloseButton","$innertoast","$body","BTransition","toastPositions","positionClass","handleDestroy","_sfc_main$16","container","toastInstance","subContainers","BToaster","darkBoolean","dropupBoolean","droprightBoolean","dropleftBoolean","splitBoolean","noCaretBoolean","dropdown","buttonClasses","dropdownMenuClasses","buttonAttr","splitAttr","onSplitClick","Dropdown","defaultConfig","dropDownConfig","_hoisted_1","_createElementBlock","_hoisted_2","__default__","headerId","headerRole","useAttrs","componentAttrs","floatingBoolean","novalidateBoolean","validatedBoolean","submitted","forceShowBoolean","stateBoolean","tooltipBoolean","computedShow","inlineBoolean","computedAriaAtomic","indeterminateBoolean","autofocusBoolean","plainBoolean","switchBoolean","requiredBoolean","isFocused","emitValue","isChecked","classesObject","inputClasses","labelClasses","slotsName","buttonsBoolean","stackedBoolean","switchesBoolean","sortByOptions","it","checkboxList","INPUTS","INPUT_SELECTOR","LEGEND_INTERACTIVE_ELEMENTS","SLOT_NAME_LABEL","SLOT_NAME_INVALID_FEEDBACK","SLOT_NAME_VALID_FEEDBACK","SLOT_NAME_DESCRIPTION","SLOT_NAME_DEFAULT","_sfc_main$R","BCol","BFormInvalidFeedback","BFormRow","BFormText","BFormValidFeedback","labelSrOnlyBoolean","ariaDescribedby","breakPoints","getAlignClasses","propValue","getColProps","updateAriaDescribedby","$input","newIds","oldIds","ids","contentColProps","labelAlignClasses","labelColProps","isHorizontal","computedState","stateClass","tagName","inputs","isFieldset","$label","labelContent","labelId","labelTag","renderProps","$invalidFeedback","invalidFeedbackContent","invalidFeedbackId","$validFeedback","validFeedbackContent","validFeedbackId","$description","descriptionContent","descriptionId","contentBlocks","$content","rowProps","allowedTypes","_sfc_main$Q","isHighlighted","isRange","isColor","localType","$event","formOptions","multipleBoolean","computedSelectSize","noRemoveBoolean","tagText","taglabelId","addOnChangeBoolean","noAddOnEnterBoolean","noOuterFocusBoolean","noTagRemoveBoolean","removeOnDeleteBoolean","tagPillsBoolean","_inputId","tags","shouldRemoveOnDelete","lastRemovedTag","validTags","invalidTags","duplicateTags","isDuplicate","isInvalid","isLimitReached","disableAddButton","slotAttrs","addTag","onKeydown","removeTag","checkAutofocus","onFocusin","onFocus","tagIndex","_sfc_main$I","noResizeBoolean","computedStyles","hasAppend","hasPrepend","isTextBoolean","numberedBoolean","horizontal","actionBoolean","tagComputed","isAction","localAttrs","busyBoolean","cancelDisabledBoolean","centeredBoolean","hideBackdropBoolean","hideFooterBoolean","hideHeaderBoolean","hideHeaderCloseBoolean","noCloseOnBackdropBoolean","noCloseOnEscBoolean","noFocusBoolean","okDisabledBoolean","okOnlyBoolean","scrollableBoolean","titleSrOnlyBoolean","staticBoolean","lazyLoadCompleted","modalClasses","hasHeaderCloseSlot","modalDialogClasses","bodyClasses","headerClasses","footerClasses","titleClasses","disableCancel","disableOk","buildModalEvent","onBeforeEnter","onAfterEnter","onLeave","onAfterLeave","cardHeaderBoolean","fillBoolean","justifiedBoolean","pillsBoolean","tabsBoolean","_sfc_main$x","_component_b_link","printBoolean","computedRole","computedNavbarExpand","containerClass","_sfc_main$t","onClick","bodyScrollingBoolean","backdropBoolean","noHeaderCloseBoolean","noHeaderBoolean","Offcanvas","positionStyles","fixedBoolean","noCenterBoolean","noWrapBoolean","showBoolean","spinnerSmallBoolean","computedAriaBusy","spinnerAttrs","overlayStyles","overlayClasses","blurClasses","blurStyles","spinWrapperStyles","DEFAULT_LIMIT","DEFAULT_PER_PAGE","DEFAULT_TOTAL_ROWS","ELLIPSIS_THRESHOLD","SLOT_NAME_ELLIPSIS_TEXT","SLOT_NAME_FIRST_TEXT","SLOT_NAME_LAST_TEXT","SLOT_NAME_NEXT_TEXT","SLOT_NAME_PAGE","SLOT_NAME_PREV_TEXT","sanitizePerPage","sanitizeTotalRows","sanitizeCurrentPage","numberOfPages","page","_sfc_main$o","firstNumberBoolean","hideEllipsisBoolean","hideGotoEndButtonsBoolean","lastNumberBoolean","justifyAlign","startNumber","lStartNumber","numberOfLinks","showFirstDots","pagesLeft","rShowDots","n","showLastDots","paginationWindowEnd","lastPageNumber","pagination","pageClick","pageNumber","clickEvent","btnSize","styleClass","calculatedValue","pages","buttons","pageNumbers","p","isActivePage","noCurrentPage","fill","makeEndBtn","linkTo","ariaLabel","btnSlot","btnText","btnClass","pageTest","isDisabled","btnContent","makeEllipsis","isLast","makePageButton","active","tabIndex","inner","gotoFirstPageButton","previousButton","nextButton","gotoLastPageButton","widthString","colsString","noButtonBoolean","noFooterBoolean","noImgBoolean","imgAttrs","captionTopBoolean","borderlessBoolean","borderedBoolean","hoverBoolean","stripedBoolean","stickyHeaderBoolean","responsiveClasses","columnsNumber","rowsNumber","computedHeaderColumnsLength","computedFooterColumnsLength","placeholderAttrs","showFooterBoolean","_sfc_main$h","htmlBoolean","sanitizeBoolean","titleRef","contentRef","cleanElementProp","getElement","idElement","bsEventHandlers","attachTargetEventHandlers","targetElement","pair","disposeTargetEventHandlers","generatePopoverInstance","targetValue","_renderSlot","_hoisted_3","animatedBoolean","showProgressBoolean","showValueBoolean","numberPrecision","numberValue","numberMax","computedLabel","computedWidth","rowColsProps","_sfc_main$e","noGuttersBoolean","rowColsClasses","style","RTL_LANGS","locale","isLocaleRTL","parts","locale1","locale2","parseEventOptions","eventOn","eventName","handler","eventOff","eventOnOff","on","eventParams","stopEvent","preventDefault","propagation","immediatePropagation","CODE_DOWN","CODE_END","CODE_HOME","CODE_PAGEDOWN","CODE_PAGEUP","CODE_UP","DEFAULT_MIN","DEFAULT_MAX","DEFAULT_STEP","DEFAULT_REPEAT_DELAY","DEFAULT_REPEAT_INTERVAL","DEFAULT_REPEAT_THRESHOLD","DEFAULT_REPEAT_MULTIPLIER","KEY_CODES","_sfc_main$9","hasFocus","spinId","emitChange","lvalue","$_autoDelayTimer","$_autoRepeatTimer","$_keyIsDown","computedStep","computedMin","computedMax","max","step","min","computedDelay","computedInterval","computedThreshold","computedStepMultiplier","computedPrecision","computedMultiplier","valueAsFixed","computedLocale","locales","computedRTL","defaultFormatter","precision","computedFormatter","hasValue","computedSpinAttrs","stepValue","direction","multiplier","wrap","stepUp","stepDown","code","altKey","ctrlKey","metaKey","resetTimers","handleStepRepeat","onKeyup","stepper","isMouseEvent","threshold","count","onMouseup","setMouseup","makeButton","label","IconCmp","keyRef","shortcut","btnDisabled","slotName","$icon","$increment","$decrement","$hidden","$spin","TABLE_TAG_NAMES","EVENT_FILTER","filterEvent","labelFor","useItemHelper","normaliseFields","origFields","fields","k","f","internalItems","mapItems","flags","filterItems","sortItems","sort","sorter","sortKey","realVal","ob","filterable","itemHelper","footCloneBoolean","sortDescBoolean","sortInternalBoolean","selectableBoolean","stickySelectBoolean","labelStackedBoolean","showEmptyBoolean","noProviderPagingBoolean","noProviderSortingBoolean","noProviderFilteringBoolean","internalBusyFlag","usesProvider","callItemsProvider","clone","selectedItems","isSelecting","tableClasses","isSortable","containerAttrs","computedFields","computedFieldsTotal","isFilterableTable","addSelectableCell","field","requireItemsMapping","computedItems","startIndex","getFieldHeadLabel","headerClicked","isFooter","fieldKey","handleFieldSorting","onRowClick","row","handleRowSelection","onRowDblClick","onRowMouseEnter","onRowMouseLeave","fieldSortable","sortDesc","notifySelectionEvent","shiftClicked","lastSelectedItem","lastSelectedIndex","selectStartIndex","selectEndIndex","context","response","toggleRowDetails","tr","getFieldColumnClasses","getFieldRowClasses","getRowClasses","selectAllRows","unselectableItems","clearSelected","selectRow","unselectRow","providerPropsWatch","inNoProvider","notifyFiltered","noProvideWhenPaging","noProvideWhenFiltering","noProvideWhenSorting","oldFilter","stickyColumnBoolean","cardBoolean","noNavStyleBoolean","_tabIndex","_currentTabButton","tabs","getTabs","tab","buttonId","contentId","titleItemClass","titleLinkAttributes","showEmpty","navTabsClasses","activateTab","tabEvent","handleClick","goForward","maxIdx","activeTabIndex","firstTab","lazyRenderCompleted","computedLazy","computedLazyOnce","computedActive","showSlot","hasLazyRenderedOnce","shown","plugin","Components","component","Directives"],"mappings":"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"}